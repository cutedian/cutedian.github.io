<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在前面</title>
    <url>/2023/07/13/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="此文章为何存在"><a href="#此文章为何存在" class="headerlink" title="此文章为何存在"></a>此文章为何存在</h2><p>搭建个人博客不是一件容易的事，也不是仅凭着一腔孤勇就能完成的任务。值得一提的是，该博客搭建全程基于<code>macOS</code>系统。<del>整个过程中，Diandian有不下20次想砸电脑的冲动😭</del></p>
<p>当然，此文章存在的意义不是为了抱怨搭建过程，而是希望面向访问蜜罐的朋友们回答一些问题。</p>
<h3 id="搭建个人博客的初衷"><a href="#搭建个人博客的初衷" class="headerlink" title="搭建个人博客的初衷"></a>搭建个人博客的初衷</h3><p>相信很多朋友们都知道，Diandian是一个乐于分享的人。</p>
<p>从大一开始，Diandian便持续搜集各科目资料<strong>（包括但不限于往年考题、实验报告、课程讲义）</strong>，其不仅是为了日后自我复习，还是为了分享给往后许多届的同学们。</p>
<p>毕竟，大学里要学会互帮互助，才能走得长远。因此，该博客内包括但不限于以下内容并将持续更新：</p>
<div class="note-large blue"><div class="notel-title"><p>2系：电路分析</p>
</div><div class="notel-content"><p>往年题12套</p>
<p>自写答案</p>
<p>学习方法</p>
</div></div>

<div class="note-large red"><div class="notel-title"><p>2系：基础物理学（2）</p>
</div><div class="notel-content"><p>练习题+往年题25套（题过于简单，因此无需给出答案。需要者请在首页邮箱联系或在评论区dd我）</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large purple"><div class="notel-title"><p>2系：复变函数与积分变换</p>
</div><div class="notel-content"><p>往年题16套</p>
<p>自写答案（仅给出部分，需要者请dd我）</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large cyan"><div class="notel-title"><p>2系：电子电路（1）</p>
</div><div class="notel-content"><p>期中与期末题库（几乎涵盖所有考题，详见专栏）</p>
<p>自写答案</p>
<p>全套课程讲义</p>
<p>仿真实验报告与硬件实验报告</p>
</div></div>

<div class="note-large orange"><div class="notel-title"><p>2系：电磁场理论</p>
</div><div class="notel-content"><p>6套期中+8套期末</p>
<p>自写答案</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large yellow"><div class="notel-title"><p>2系：信号与系统</p>
</div><div class="notel-content"><p>8套期末+1套题库</p>
<p>全套课程讲义</p>
<p>仿真实验报告</p>
</div></div>

<div class="note-large green"><div class="notel-title"><p>2系：FPGA基础</p>
</div><div class="notel-content"><p>（由于该门课程为21级新开设，上机实验是否祖传尚不清楚😭）</p>
<p>仿真实验报告+代码打包</p>
</div></div>

<div class="note-large blue"><div class="notel-title"><p>助教资料</p>
</div><div class="notel-content"><p>数据结构与程序设计</p>
<p>复变函数与积分变换</p>
<p>信号与系统（待定）</p>
</div></div>

<div class="note-large orange"><div class="notel-title"><p>视频剪辑</p>
</div><div class="notel-content"><p>剪辑工具如何搭配</p>
<p>剪辑思路</p>
<p>Premiere（简称pr）900个转场预设（自创，无版权要求）</p>
<p>Adobe 全家桶（2022Win&#x2F;Mac版）（无需收费与解压密码）</p>
</div></div>

<h3 id="评论模块"><a href="#评论模块" class="headerlink" title="评论模块"></a>评论模块</h3><p>此博客的评论模块采取<code>Giscus</code>评论系统，该系统基于<code>GitHub Discussions</code>实现，让各位蜜罐访客们能够借助<code>GitHub</code>在文章末尾留下评论。因此，评论员需要一个<code>GitHub</code>账号，如果没有的话赶快注册一个哦～</p>
<a class="button  center large" href='https://github.com/' title='GitHub账号注册'><i class='fa-brands fa-github'></i> GitHub账号注册</a>

<p>当然，此步骤可能需要你会科学上网。在此提供一种macOS上自测有效（Windows也可）的方法</p>
<a class="button  center large" href='https://doc.miyun.app/clashx/' title='免费开启ClashX代理'><i class='fa-solid fa-face-awesome'></i> 免费开启ClashX代理</a>

<p>当然，如果各位不想通过评论区的方式与我交流联系，也可直接访问首页大字<code>Dian·Stay Curious</code>下三个图标中的<code>邮箱</code>，此按钮会引导你编辑内容发送到<code>zhongyd2004@163.com</code>。</p>
<blockquote>
<p>注意：</p>
<p><code>Giscus</code>仍处于活跃开发中，<code>GitHub</code>也还在活跃地开发<code>Discussions</code>及其<code>API</code>，因此一些<code>Giscus</code>的特性可能随时间损坏或变更。当然，Diandian将密切关注此情况。</p>
</blockquote>
<h3 id="文章编写：Typora"><a href="#文章编写：Typora" class="headerlink" title="文章编写：Typora"></a>文章编写：Typora</h3><p>该博客中所有文章均为<code>.md</code>格式（全称<code>markdown</code>），采用<code>Typora</code>软件进行编写。</p>
<p>如果你想更方便地自创与编辑<code>.md</code>格式文件，不妨用一下<code>Typora</code>软件，虽然要收费（不打折时，终身使用仅需89元），但是非常好用😋</p>
<a class="button  center large" href='https://typoraio.cn/' title='Typora软件下载'><i class='fa-solid fa-t'></i> Typora软件下载</a>

<p>当然，<code>markdown</code>语法请自己搜索学习。</p>
<h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>内容分发网络（CDN）是一种分布式系统，<strong>它将内容存储在离用户最近的服务器上</strong>，从而提高用户访问网站的速度和性能。<code>CDN</code>会将用户的请求转发到最近的服务器上，而不是将请求转发到网站的源服务器上。这样可以减少源服务器的负载，同时也可以提高用户访问网站的速度。</p>
<p>本博客基于<code>EvanNotFound</code>大佬的阿里云<code>OSS</code>采取CDN加速，以期望带给各位更顺畅的体验。</p>
<h3 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h3><p>该博客已开通友链模块，想要申请加入的请私信Diandian哦～</p>
<p>（悄悄说一声，如果能提供首页缩略图和头像图就更好啦）</p>
<h2 id="开源相关"><a href="#开源相关" class="headerlink" title="开源相关"></a>开源相关</h2><p><a class="link"   href="https://github.com/XPoet/hexo-theme-keep" >https://github.com/XPoet/hexo-theme-keep <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/volantis-x/hexo-theme-volantis" >https://github.com/volantis-x/hexo-theme-volantis <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/theme-next/hexo-theme-next" >https://github.com/theme-next/hexo-theme-next <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/jerryc127/hexo-theme-butterfly" >https://github.com/jerryc127/hexo-theme-butterfly <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://m3.material.io/" >https://m3.material.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://developer.apple.com/design/human-interface-guidelines/" >https://developer.apple.com/design/human-interface-guidelines/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://fluent2.microsoft.design/" >https://fluent2.microsoft.design/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.sketch.com/" >https://www.sketch.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://hexo.io/zh-cn/" >https://hexo.io/zh-cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://highlightjs.org/" >https://highlightjs.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/next-theme/hexo-filter-mathjax" >https://github.com/next-theme/hexo-filter-mathjax <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" >https://github.com/webappdevelp/hexo-filter-mermaid-diagrams <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/theme-next/hexo-generator-searchdb" >https://github.com/theme-next/hexo-generator-searchdb <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/hexojs/hexo-generator-feed" >https://github.com/hexojs/hexo-generator-feed <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/yanyiwu/nodejieba" >https://github.com/yanyiwu/nodejieba <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://aplayer.js.org/#/" >https://aplayer.js.org/#/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://fontawesome.com/" >https://fontawesome.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.zhheo.com/p/557c9e72.html" >https://blog.zhheo.com/p/557c9e72.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/mattboldt/typed.js/" >https://github.com/mattboldt/typed.js/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="Stay-Curious-Stay-Interesting"><a href="#Stay-Curious-Stay-Interesting" class="headerlink" title="Stay Curious, Stay Interesting"></a>Stay Curious, Stay Interesting</h2><p>在此篇博客的主页会出现<code>Dian·Stay curious</code>，侧边公告栏中出现<code>Stay curious, stay interesting.</code></p>
<p>此句是Diandian最喜欢的英语句子，源于Diandian的高中英语老师<code>Chelsea</code>。我们每次英语课前的老师问好环节，<code>Chelsea</code>会喊出前一句，我们则说出后一句😋。</p>
<p><strong>因此，让我们也在文章末尾大声地说出：“Stay curious, stay interesting!”</strong></p>
]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第一期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%B8%80%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="什么是猪脚说"><a href="#什么是猪脚说" class="headerlink" title="什么是猪脚说"></a>什么是猪脚说</h2><p>为了改善同学们的上机体验，减轻同学们的压力，集中回答编程中常见问题，继承上一辈助教的优良传统，我们<strong>为大家精心准备了猪脚说</strong>。</p>
<p>猪脚说，就是<del>猪脚</del>助教们想对大家说的话。每次上机后，我们会及时总结大家<strong>提问相对较多</strong>或<strong>比较重要</strong>的问题，在猪脚说中以详细的篇幅加以阐述，希望同学们或多或少得到一些启发。</p>
<p>猪脚说包括但不限于<strong>共性问题</strong>, <strong>coding 小技巧</strong>, <strong>课外习题</strong>。</p>
<h2 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h2><h3 id="指针详详详解"><a href="#指针详详详解" class="headerlink" title="指针详详详解"></a>指针详详详解</h3><h4 id="指针与地址"><a href="#指针与地址" class="headerlink" title="指针与地址"></a>指针与地址</h4><p>考虑如下代码，发生了什么？</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure></div>

<p>要回答这个问题，我们要从最开始的地方说起。</p>
<h5 id="你好，世界！"><a href="#你好，世界！" class="headerlink" title="你好，世界！"></a>你好，世界！</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>我们知道，数据总是存储在计算机里的。我们要打印的字符串，应该存在哪里呢？为了便于说明这个问题，我们把计算机内部存储数据的地方<strong>想象成一个大柜子，柜子有一个一个的抽屉</strong>；每个抽屉的容量是有限的，只能放得下一个字符，也就是一个<code>char</code>的内容。这里为了避免引入“字节”的概念，给出如下的大小关系：<code>4个char的大小 = 1个int的大小</code>，<code>8个char的大小 = 2个int的大小 = 1个double的大小 = 1个long long</code>的大小。</p>
<p>上述语句中的字符串，用<strong>双引号</strong>括起来，称为<strong>“字符串字面值常量”</strong>。作为字符串，它由若干字符拼接而成，后来的故事我们都知道了，在它的最后还有一个看不见的<code>&#39;\0&#39;</code>作为结束的标志；作为常量，这类字符串的内容不能被修改。</p>
<p>这样的字符串常量，储存在大柜子里的一块特定区域，称为<strong>常量区</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 15.50.21.png"
                      alt="截屏2023-02-24 15.50.21" style="zoom:40%;" 
                >

<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="type">int</span>  i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>

<p>后来我们学了变量，它们当然也装在这个大柜子里。如果这只是个有很多抽屉的柜子，那么数据的存取将变得异常困难，一个很显然的做法是，<strong>为每个抽屉编号</strong>。但另一个问题又来了，计算机自然可以通过编号访问数据；但作为编程者，我们并不知道每个变量存在哪个编号的抽屉里。于是另一个很显然的做法是，我们可以为存有变量的抽屉<strong>贴上标签</strong>，这就是<strong>标识符</strong>，例如<code>c</code>和<code>i</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.12.35.png"
                      alt="截屏2023-02-24 16.12.35" style="zoom:40%;" 
                >

<p><strong>特别要注意的是，<code>int</code>变量<code>i</code>占用了 4 个抽屉。</strong>有了这个模型，我们就能知道<code>int i = 10;</code>中，<code>i</code>表示的是存放了数字 10 的那 4 个抽屉的标签；它的编号是 21；从编号 21 开始之所以放了 4 个抽屉，是类型<code>int</code>决定的。</p>
<p><strong>后来我们知道了，这个编号，就是指针。指针，就是地址。</strong></p>
<h5 id="回答一下前面的问题"><a href="#回答一下前面的问题" class="headerlink" title="回答一下前面的问题"></a>回答一下前面的问题</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.22.14.png"
                      alt="截屏2023-02-24 16.22.14" style="zoom:40%;" 
                >

<ul>
<li>首先定义一个普通变量<code>a</code>，被装在 4 个抽屉里，抽屉的起始编号是 21，抽屉的内容是 10。</li>
<li>然后定义了一个指针变量<code>p</code>，<code>p</code>也需要 4 个抽屉存放<strong>（因为<code>p</code>的本质也是一个整数！！！）</strong>，<code>p</code>也有自己的编号 44，<code>p</code>的内容是存放<code>a</code>的抽屉的起始编号，即 21。</li>
<li><code>p</code>只存放了<code>a</code>的起始地址，<code>p</code>怎么知道<code>a</code>从 21 开始占了多少个抽屉呢？这由定义<code>p</code>的<code>int *</code>中的<code>int</code>决定。<strong>换言之，</strong><ul>
<li><code>char *p</code>表示<code>p</code>中存放一个整数，这个整数是一个地址，从那个地址开始的 1 个抽屉的内容是一个<code>char</code>变量，因为<code>char</code>只需要 1 个抽屉。</li>
<li><code>int *p</code>表示<code>p</code>中存放一个整数，这个整数是一个地址，从那个地址开始的 4 个抽屉的内容是一个<code>int</code>变量，因为<code>int</code>需要 4 个抽屉。</li>
<li><code>double *p</code>表示<code>p</code>中存放了一个整数，这个整数是一个地址，从那个地址开始的 8 个抽屉的内容是一个<code>double</code>变量，因为<code>double</code>需要 8 个抽屉。</li>
<li>……</li>
</ul>
</li>
</ul>
<h5 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h5><p>有了指针，在我们的程序里，要访问一个变量就有两种方法了。一方面，可以通过<strong>抽屉的标签</strong>，也就是<strong>变量名</strong>访问；另一方面，可以通过<strong>抽屉的编号 —— 指针</strong>，间接地访问。后者自然要加上**指针运算符（解引用）<code>*</code>**。</p>
<p>显然，在多数情况下，偏要用指针间接访问一个变量是毫无意义的。但在某些情况下，我们只能通过指针访问。考察下面的程序</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pass_by_value</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pass_by_pointer</span><span class="params">(<span class="type">int</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    pass_by_value(x);</span><br><span class="line">    pass_by_pointer(&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>稍有经验的同学不难看出，<code>x</code>的值不会被修改，<code>y</code>的值会被修改。为什么呢？</p>
<p><strong>C 程序的函数参数都是值传递的。</strong>这句话的意思是，一个函数的运行，自然会涉及一些变量，其中的一部分是函数参数，另一部分是函数内部定义的变量；<strong>在函数运行期间，函数需要借用一些抽屉来存放这些变量的值</strong>。对于<code>pass_by_value(x);</code>中的<code>x</code>，函数只会把**<code>x</code>的值<strong>放在自己借用的抽屉里，而不会意识到<code>x</code>是某处的一个标签；对于<code>pass_by_pointer(&amp;y);</code>中的<code>&amp;y</code>，函数只会把</strong><code>&amp;y</code>的值** —— <strong>这个值是一个普通整数，并且是一个地址</strong> —— 放在自己借用的抽屉里。两者的不同之处在于，前者真的只是传了一个普通整数；而<strong>后者传入的整数同时也是地址</strong>，我们在函数内部确实访问了这个地址的内容，从而真的修改了<code>y</code>的值。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.56.33.png"
                      alt="截屏2023-02-24 16.56.33" style="zoom:35%;" 
                >

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><blockquote>
<p>为了绘图简便，我们考察<code>short</code>型的数组。一个<code>short</code>变量占两个抽屉。此处我们仅考虑数组和指针的关系，数组的定义、初始化、元素访问等不再赘述。</p>
</blockquote>
<p>我们会说，<strong>数组名就是指针</strong>，这句话的意思是</p>
<ul>
<li><strong>只要知道了数组的首地址，就可以访问数组的每个元素。</strong>假设<code>p</code>存放着数组的首地址，下标从 0 开始，我们要访问下标为<code>index</code>的元素，一种写法是<code>p[index]</code> —— 相当于从数组首元素<strong>往后数</strong><code>index</code>个元素，然后访问那个元素 —— 等价于<code>*(p + index)</code>，即将<code>p</code><strong>偏移</strong>，从而使之指向欲访问的元素，然后解引用。</li>
<li>系统手里有一张表，叫做<strong>符号表</strong>。数组名是符号表中的一项，它是一个<strong>不可修改的常量</strong>，指代数组的首地址。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 17.30.56.png"
                      alt="截屏2023-02-24 17.30.56" style="zoom:40%;" 
                >

<p>当数组作为函数参数传递的时候，<strong>统一当成指针处理</strong>，所以以下三种函数声明等价：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *arr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arr[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arr[<span class="number">999</span>])</span>; <span class="comment">// 并不关心数组多大</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>后面两种声明会被翻译成第一种声明，也就是指针的形式。<ul>
<li>数组可以通过首地址访问，所以传入首地址是可行的。</li>
<li>通过指针，在<code>main</code>函数里定义的数组，可以在<code>func</code>中被修改，这与普通变量的值传递不同。</li>
</ul>
</li>
<li>前面说到，函数参数需要借一些抽屉临时存放。而函数能借到的抽屉是<strong>有限的</strong>，如果真的把一个长度为 999 的数组传入，则需要 999 × 4 个抽屉，这不太现实。只传入指针，则只需要 4 个抽屉即可 —— 通过指针间接访问数组。</li>
<li>此外，上一点也提醒我们，<strong>函数内部并不知道数组有多大，它只知道数组的首地址</strong>。所以对数组操作的函数，一般需要再加上一个<code>size</code>参数，保证函数中不会出现<strong>数组越界</strong>的情况。</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>在最开始的地方谈到，用双引号扩起来的字符串常量，被存放在大柜子的一块特定区域，即常量区。事实上，不仅是我们想要输出的文本信息，<strong>C 程序中任何地方</strong>出现的字符串常量，都会被存在那里。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="type">char</span> *s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br></pre></td></tr></table></figure></div>

<p>这里的<code>&quot;%d %d&quot;</code> <code>&quot;hello world&quot;</code> <code>&quot;%s\n&quot;</code>都是字符串常量，都会被预先存在常量区。另一方面，这种字符串常量的最后都默认有一个看不见的<code>&#39;\0&#39;</code>作为结束的标志，这是系统自动加上的。</p>
<p>我们想象这样的画面，每个抽屉只能装一个字符，<strong>只要我们知道了字符串的第一个字符装在哪个抽屉，然后依次往后拉开抽屉，直到拉开了存放<code>&#39;\0&#39;</code>的那个抽屉为止，我们就获得了字符串的所有内容</strong>。于是，<strong>字符串的首地址就成为了确定一个字符串唯一所需要的信息。</strong><code>char *s = &quot;hello world&quot;;</code>的那个指针<code>s</code>，做的就是这件事。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 11.57.03.png"
                      alt="截屏2023-02-25 11.57.03" style="zoom:40%;" 
                >

<p><strong>另一方面，字符串也可以存在我们自定义的数组里，但是其初始化值得考察。</strong>假设我们要存入的是<code>&quot;abc&quot;</code>。</p>
<ul>
<li><p>数组大小应该开够，因为需要有<code>&#39;\0&#39;</code>作为结束标志</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 开得足够大，并且别忘了 \0</span></span><br><span class="line"><span class="type">char</span> s[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;   <span class="comment">// 不写大小，由系统自动判断，此处 s 大小即为 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">4</span>]; s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>; s[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>; s[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span> = s[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 更加麻烦的逐一赋值，但 OK</span></span><br></pre></td></tr></table></figure></div>

  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 12.02.53.png"
                      alt="截屏2023-02-25 12.02.53" style="zoom:40%;" 
                >
</li>
<li><p>有一种<strong>便捷手段</strong>，在初始化的时候，<strong>用字符串字面值常量为字符数组赋初值</strong></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 开大点总是保险</span></span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>;   <span class="comment">// 这么做默认 s 大小为 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严禁这么做！</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>]; <span class="comment">// 定义了一个数组，数组名是符号表中的常量</span></span><br><span class="line">s = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 给一个符号常量赋值，是绝对不行的</span></span><br></pre></td></tr></table></figure></div>

  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 12.08.20.png"
                      alt="截屏2023-02-25 12.08.20" style="zoom:40%;" 
                ></li>
</ul>
<h4 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h4><p><strong>指针是工具，是用来使用的。</strong></p>
<p>对指针的本质进行解析，为的是让大家理解其使用方式。使用指针，需要的是在脑海中形成意识“我们就是这么做的”“这么做是合理的”。对于指针的基本理解包括但不限于以下几点</p>
<ul>
<li>指针是个<strong>变量</strong>，指针是个<strong>整数</strong>。</li>
<li>取变量的地址赋值给指针，我们就说指针指向了那个变量。</li>
<li>指针“指向”，只是说指针中存了一个整数地址；<strong>要访问变量，需要一次解引用</strong>。</li>
<li><strong>数组名是一个符号</strong>，等价于数组首地址。</li>
<li>双引号扩起来的字符串是常量，只读不写。</li>
</ul>
<p>我们需要培养一些基本的意识，要知道“我可以写什么，不可以写什么”。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr; <span class="comment">// arr符号代表首地址，赋值给指针，当然可以</span></span><br><span class="line">p[<span class="number">1</span>] = <span class="number">5</span>;     <span class="comment">// 指针也可以像数组一样访问</span></span><br><span class="line">*(p + <span class="number">2</span>) = <span class="number">2</span>; <span class="comment">// 指针自己也具备了“偏移 + 解引用”操作</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *s  = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 这是指针指向字符串常量</span></span><br><span class="line"><span class="type">char</span> t[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 这是一个普通数组，并使用了便捷方式初始化</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span>;       <span class="comment">// 字符串常量不能修改！</span></span><br><span class="line">t[<span class="number">1</span>] = <span class="string">&#x27;y&#x27;</span>;       <span class="comment">// 数组当然可以修改</span></span><br></pre></td></tr></table></figure></div>

<p>最后补充的是<code>NULL</code>和<code>const</code>指针。</p>
<h5 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a><code>NULL</code></h5><p>指针是一个<strong>整型变量</strong>，它的取值无非有这么几种</p>
<ul>
<li>只定义但未初始化，是一个随机值。</li>
<li>进行初始化或赋值，“指向了其他的变量”。</li>
<li>初始化为 0。（编号为 0 的那个抽屉存了啥？）</li>
</ul>
<p><code>NULL</code>是一个宏，代表整数 0，用于指针的初始化：<code>int *p = NULL;</code> 当然也可以写 <code>int *p = 0;</code>。</p>
<p>当一个指针未初始化时，它可能指向任何地方，但是那里究竟能不能访问是未知的，这就是<strong>野指针</strong>。在有些情况下，访问了不该访问的地方，可能导致系统崩溃。人们规定，<strong>编号为 0 的那个抽屉是一个无效的抽屉，一旦访问，程序运行就强制结束了</strong>（总比系统崩溃好）。所以在将指针指向某个变量之前，初始化为 0 或<code>NULL</code>，是有必要的。</p>
<h5 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a><code>const</code>指针</h5><p>我们知道字符串常量存在常量区，但其他常量，如<code>const int</code>，还是和普通变量放在一起的。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></div>

<p>当编译器看到这两行代码，它会说：“<code>a</code>被定义为常量，你却要为<code>a</code>赋其他值，不可以！”于是报错。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line">*p = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></div>

<p>当编译器看到这两行代码，它会说：“<code>a</code>是常量，存在内存里了。<code>p</code>想要指向它，当然可以。对指针<code>p</code>解引用进行赋值，当然可以。”于是真的，一个<code>const int</code>的值通过指针被修改了。</p>
<p>所以我们有必要避免这种情况，手段就是<strong>“指向常量的指针”</strong>。前文说到，<strong>指针是统一的一种类型，就是整型</strong>。定义指针时前面的类型，只是告诉系统，“连续打开几个抽屉”。打开抽屉后，无非有两种操作：看一下里面是什么（<strong>读</strong>操作）和修改一下内容（<strong>写</strong>操作）。对于后者，如果抽屉里装的是常量，则应该避免。</p>
<p>在定义指针的最前面加上<code>const</code>修饰，如<code>const int *p = &amp;a;</code>，就定义了指向常量的指针。这么做的好处是，<code>p</code>说：“我是指针，我指向<code>a</code>，但你<strong>无法通过我</strong>修改<code>a</code>的值，<strong>你有没有其他手段修改<code>a</code>的值，与我无关。</strong>”</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a; <span class="comment">// 这是正确的，定义了指向常量的指针</span></span><br><span class="line">*p = <span class="number">100</span>;          <span class="comment">// 通过 p 无法修改 a</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *q = &amp;b; <span class="comment">// 指向常量的指针指向了普通变量</span></span><br><span class="line"><span class="type">int</span> *r = &amp;b;       <span class="comment">// 普通的指针指向了普通变量</span></span><br><span class="line">*q = <span class="number">100</span>;          <span class="comment">// 无法通过 q 修改 b 了，哪怕 b 是一个普通变量</span></span><br><span class="line">*r = <span class="number">100</span>;          <span class="comment">// 这么改当然可以</span></span><br></pre></td></tr></table></figure></div>

<p>于是我们会在大量字符串处理函数的原型中，看到参数都定义为<code>const char *p</code>类型，这就是说，字符串通过<code>p</code>传入函数，<strong>保证在函数内部，不会修改字符串的内容</strong>。这么做是严谨的。</p>
<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><h4 id="库函数功能介绍"><a href="#库函数功能介绍" class="headerlink" title="库函数功能介绍"></a>库函数功能介绍</h4><p><code>size_t</code> 为无符号整数类型，它是 <strong><code>sizeof</code></strong> 关键字的结果。</p>
<p>下列常用字符串处理函数均定义在头文件  <code>&lt;string.h&gt;</code> 中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 把 str1 和 str2 的前 n 个字节进行比较。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 从 src 复制 n 个字符到 dest。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复制字符 c （一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</span></span><br><span class="line"><span class="comment">	e.g.想要将一个 int 类型数组 a[50] 全部置为0:</span></span><br><span class="line"><span class="comment">		memset(a, 0, sizeof(a));</span></span><br><span class="line"><span class="comment">	等效于 for (i=0; i &lt; 50; i++) a[i] = 0;</span></span><br><span class="line"><span class="comment">	【特别注意】一般此函数仅用于全部归零，其他值不能随便设置！！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="comment">// 把 src 所指向的字符串（包括&#x27;\0&#x27;）追加到 dest 所指向的字符串的结尾（删除 dest 原来末尾的&#x27;\0&#x27;）。</span></span><br><span class="line"><span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 的字符串。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 把 src 所指向的字符串的前 n 个字符追加到 dest 所指向的字符串的结尾（删除 dest 原来末尾的&#x27;\0&#x27;）。</span></span><br><span class="line"><span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 的字符串。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="comment">	返回值为该字符串中第一次出现的字符的指针，若不包含该字符则返回 NULL 空指针。</span></span><br><span class="line"><span class="comment">	char *strrchr(const char *str, int c);</span></span><br><span class="line"><span class="comment">	在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	把 str1 所指向的字符串和 str2 所指向的字符串进行比较并返回整数。若两字符串相等，则返回零。</span></span><br><span class="line"><span class="comment">	若 str1 &lt; str2, 则返回负数; 若 str1 &gt; str2, 则返回正数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line">	<span class="comment">// 把含有&#x27;\0&#x27;结束符的字符串 src 复制到以 dest 开始的地址空间。</span></span><br><span class="line">	<span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 字符串。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line">	<span class="comment">// 把字符串 src 的前 n 个字符复制到以 dest 开始的地址空间。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">// 计算字符串 str 的长度，知道空结束字符但不包括空结束字符。返回值数据类型为无符号整型。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="comment">// 在字符串 dest 中查找第一次出现字符串 src（不包含空结束字符）的位置。</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>补充练习：字符串处理函数与指针的使用。<strong>此题将在下周上机详细讲评。</strong></p>
<p>输入 n 个字符串，将每个字符串中的<code>good</code>子串全部替换为<code>perfect</code>后输出。（不用担心数据范围，写代码实现此功能即可）。</p>
<p><strong>样例输入</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">abc123</span><br><span class="line">BUAA  goodddd 123 Good</span><br><span class="line">godgoodgodgoooood goo? gooD good!</span><br></pre></td></tr></table></figure></div>

<p><strong>样例输出</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc123</span><br><span class="line">BUAA perfectddd 123 Good</span><br><span class="line">godperfectgodgoooood goo? gooD perfect!</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="读取字符串"><a href="#读取字符串" class="headerlink" title="读取字符串"></a>读取字符串</h4><p>很多同学在使用 <code>gets()</code> 函数读取字符串时，可能在 judge 平台的编译器上收到这样的提示:</p>
<p><strong>Warning: the ‘gets’ function is dangerous and should not be used.</strong></p>
<p>原因在于：**<code>gets()</code>函数不做地址越界检查！**若输入的字符串大于既定数组的长度，程序运行会出现难以预期的错误。<a class="link"   href="https://blog.csdn.net/weixin_33748818/article/details/89776085" >有兴趣的同学可以从这篇文章中作详细了解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>在此，我们建议使用如下两种方式读取字符串:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"><span class="comment">// 该函数更多被用来读取单词，而非整行字符串。它从一个非空白字符开始，读到下一个空白字符为止。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[BUFSIZ] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">fgets(buf, BUFSIZ, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="comment">// 该函数的第二个参数代表规定从标准输入读取字符上限的数量，这也是它优于 gets() 函数的地方。</span></span><br><span class="line"><span class="comment">// 我们更推荐大家使用此种方法来读取整行字符串。</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>BUFSIZ</code>是宏定义在头文件里的常数，一般值为 512，对于大家完成上机作业已经够用了。</p>
</li>
<li><p><code>stdin</code>为标准输入，也就是键盘输入。在之后的文件输入输出时，可以修改此参数为文件指针。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong></p>
<p><code>fgets()</code> 函数会读取 <code>&#39;\n&#39;</code> 并写进数组中, 因此使用<code>strlen()</code> 函数求取数组长度时, 得到的长度比实际可见字符数多 1，其中包含了最后一个换行符。</p>
</blockquote>
<h3 id="char与int的转换"><a href="#char与int的转换" class="headerlink" title="char与int的转换"></a><code>char</code>与<code>int</code>的转换</h3><p>先来看第一次作业填空题第四题:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">invert</span><span class="params">(<span class="type">char</span> str[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>, j = <span class="built_in">strlen</span>(str)<span class="number">-1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">		k = str[i];</span><br><span class="line">		str[i] = str[j];</span><br><span class="line">		str[j] = k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不少同学都来提问: <code>k</code>不是<code>int</code>类型的变量吗，怎么能够和一个字符进行相应的运算关系？</p>
<p>需要指出的是：某个字符和它由 <strong>ASCII 码表</strong>所对应的整型值是等价的。即如果用整型值 48 赋值给某个字符，则其输出结果会是 ‘0’; 如果用字符常量 ‘0’ 赋值给某个整型变量，则其输出后为 48。</p>
<p><code>char</code>型实际上就是 0 到 127 的整型数经过 <strong>ASCII 码表</strong>映射的结果，其与<code>int</code>型的转换需要代入映射后得到对应值。</p>
<p>如果还有同学有疑问或者想要了解更多例子，不妨看下面一些代码:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) </span><br><span class="line">    <span class="comment">// do something</span></span><br></pre></td></tr></table></figure></div>

<p>上述代码为最简单的两个字符比较大小，其本质上是以相应的<strong>ASCII码表</strong>值的大小作为字符比较的标准。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">char</span> str[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line"> 			str[i] += <span class="number">32</span>; </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码可以实现把一段字符串中的大写字母全部转化为小写字母，其中倒数第三行就是字符与整型量的运算。</p>
<h2 id="第一次作业补充练习"><a href="#第一次作业补充练习" class="headerlink" title="第一次作业补充练习"></a>第一次作业补充练习</h2><p><a class="link"   href="https://www.luogu.com.cn/training/48079" >此链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>可以收藏起来，若有需求可以去做一些练习。</p>
<p>1、 <a class="link"   href="https://www.luogu.com.cn/problem/P5734" >处理字符串，主要考察大家对常用字符串处理库函数的运用。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>2、 <a class="link"   href="https://www.luogu.com.cn/problem/P1308" >单词统计，注意题干要求处理大小写字母。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>3、 <a class="link"   href="https://www.luogu.com.cn/problem/P1022" >改良计算器，为第一次上机第二道编程的拓展。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>4、 <a class="link"   href="https://www.luogu.com.cn/problem/P8652" >对于小数点后位数的处理。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>5、<a class="link"   href="https://www.luogu.com.cn/problem/P2293" >高精度开根，第一次上机第四道编程的拓展。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
