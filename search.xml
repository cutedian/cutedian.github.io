<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在前面</title>
    <url>/2023/07/13/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="此文章为何存在"><a href="#此文章为何存在" class="headerlink" title="此文章为何存在"></a>此文章为何存在</h2><p>搭建个人博客不是一件容易的事，也不是仅凭着一腔孤勇就能完成的任务。值得一提的是，该博客搭建全程基于<code>macOS</code>系统。<del>整个过程中，Diandian有不下20次想砸电脑的冲动😭</del></p>
<p>当然，此文章存在的意义不是为了抱怨搭建过程，而是希望面向访问蜜罐的朋友们回答一些问题。</p>
<h3 id="搭建个人博客的初衷"><a href="#搭建个人博客的初衷" class="headerlink" title="搭建个人博客的初衷"></a>搭建个人博客的初衷</h3><p>相信很多朋友们都知道，Diandian是一个乐于分享的人。</p>
<p>从大一开始，Diandian便持续搜集各科目资料<strong>（包括但不限于往年考题、实验报告、课程讲义）</strong>，其不仅是为了日后自我复习，还是为了分享给往后许多届的同学们。</p>
<p>毕竟，大学里要学会互帮互助，才能走得长远。因此，该博客内包括但不限于以下内容并将持续更新：</p>
<div class="note-large blue"><div class="notel-title"><p>2系：电路分析</p>
</div><div class="notel-content"><p>往年题12套</p>
<p>自写答案</p>
<p>学习方法</p>
</div></div>

<div class="note-large red"><div class="notel-title"><p>2系：基础物理学（2）</p>
</div><div class="notel-content"><p>练习题+往年题25套（题过于简单，因此无需给出答案。需要者请在首页邮箱联系或在评论区dd我）</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large purple"><div class="notel-title"><p>2系：复变函数与积分变换</p>
</div><div class="notel-content"><p>往年题16套</p>
<p>自写答案（仅给出部分，需要者请dd我）</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large cyan"><div class="notel-title"><p>2系：电子电路（1）</p>
</div><div class="notel-content"><p>期中与期末题库（几乎涵盖所有考题，详见专栏）</p>
<p>自写答案</p>
<p>全套课程讲义</p>
<p>仿真实验报告与硬件实验报告</p>
</div></div>

<div class="note-large orange"><div class="notel-title"><p>2系：电磁场理论</p>
</div><div class="notel-content"><p>6套期中+8套期末</p>
<p>自写答案</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large yellow"><div class="notel-title"><p>2系：信号与系统</p>
</div><div class="notel-content"><p>8套期末+1套题库</p>
<p>全套课程讲义</p>
<p>仿真实验报告</p>
</div></div>

<div class="note-large green"><div class="notel-title"><p>2系：FPGA基础</p>
</div><div class="notel-content"><p>（由于该门课程为21级新开设，上机实验是否祖传尚不清楚😭）</p>
<p>仿真实验报告+代码打包</p>
</div></div>

<div class="note-large blue"><div class="notel-title"><p>助教资料</p>
</div><div class="notel-content"><p>数据结构与程序设计</p>
<p>复变函数与积分变换</p>
<p>信号与系统（待定）</p>
</div></div>

<div class="note-large orange"><div class="notel-title"><p>视频剪辑</p>
</div><div class="notel-content"><p>剪辑工具如何搭配</p>
<p>剪辑思路</p>
<p>Premiere（简称pr）900个转场预设（自创，无版权要求）</p>
<p>Adobe 全家桶（2022Win&#x2F;Mac版）（无需收费与解压密码）</p>
</div></div>

<h3 id="评论模块"><a href="#评论模块" class="headerlink" title="评论模块"></a>评论模块</h3><p>此博客的评论模块采取<code>Giscus</code>评论系统，该系统基于<code>GitHub Discussions</code>实现，让各位蜜罐访客们能够借助<code>GitHub</code>在文章末尾留下评论。因此，评论员需要一个<code>GitHub</code>账号，如果没有的话赶快注册一个哦～</p>
<a class="button  center large" href='https://github.com/' title='GitHub账号注册'><i class='fa-brands fa-github'></i> GitHub账号注册</a>

<p>当然，此步骤可能需要你会科学上网。在此提供一种macOS上自测有效（Windows也可）的方法</p>
<a class="button  center large" href='https://doc.miyun.app/clashx/' title='免费开启ClashX代理'><i class='fa-solid fa-face-awesome'></i> 免费开启ClashX代理</a>

<p>当然，如果各位不想通过评论区的方式与我交流联系，也可直接访问首页大字<code>Dian·Stay Curious</code>下三个图标中的<code>邮箱</code>，此按钮会引导你编辑内容发送到<code>zhongyd2004@163.com</code>。</p>
<blockquote>
<p>注意：</p>
<p><code>Giscus</code>仍处于活跃开发中，<code>GitHub</code>也还在活跃地开发<code>Discussions</code>及其<code>API</code>，因此一些<code>Giscus</code>的特性可能随时间损坏或变更。当然，Diandian将密切关注此情况。</p>
</blockquote>
<h3 id="文章编写：Typora"><a href="#文章编写：Typora" class="headerlink" title="文章编写：Typora"></a>文章编写：Typora</h3><p>该博客中所有文章均为<code>.md</code>格式（全称<code>markdown</code>），采用<code>Typora</code>软件进行编写。</p>
<p>如果你想更方便地自创与编辑<code>.md</code>格式文件，不妨用一下<code>Typora</code>软件，虽然要收费（不打折时，终身使用仅需89元），但是非常好用😋</p>
<a class="button  center large" href='https://typoraio.cn/' title='Typora软件下载'><i class='fa-solid fa-t'></i> Typora软件下载</a>

<p>当然，<code>markdown</code>语法请自己搜索学习。</p>
<h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>内容分发网络（CDN）是一种分布式系统，<strong>它将内容存储在离用户最近的服务器上</strong>，从而提高用户访问网站的速度和性能。<code>CDN</code>会将用户的请求转发到最近的服务器上，而不是将请求转发到网站的源服务器上。这样可以减少源服务器的负载，同时也可以提高用户访问网站的速度。</p>
<p>本博客基于<code>EvanNotFound</code>大佬的阿里云<code>OSS</code>采取CDN加速，以期望带给各位更顺畅的体验。</p>
<h3 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h3><p>该博客已开通友链模块，想要申请加入的请私信Diandian哦～</p>
<p>（悄悄说一声，如果能提供首页缩略图和头像图就更好啦）</p>
<h2 id="开源相关"><a href="#开源相关" class="headerlink" title="开源相关"></a>开源相关</h2><p><a class="link"   href="https://github.com/XPoet/hexo-theme-keep" >https://github.com/XPoet/hexo-theme-keep <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/volantis-x/hexo-theme-volantis" >https://github.com/volantis-x/hexo-theme-volantis <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/theme-next/hexo-theme-next" >https://github.com/theme-next/hexo-theme-next <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/jerryc127/hexo-theme-butterfly" >https://github.com/jerryc127/hexo-theme-butterfly <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://m3.material.io/" >https://m3.material.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://developer.apple.com/design/human-interface-guidelines/" >https://developer.apple.com/design/human-interface-guidelines/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://fluent2.microsoft.design/" >https://fluent2.microsoft.design/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.sketch.com/" >https://www.sketch.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://hexo.io/zh-cn/" >https://hexo.io/zh-cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://highlightjs.org/" >https://highlightjs.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/next-theme/hexo-filter-mathjax" >https://github.com/next-theme/hexo-filter-mathjax <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" >https://github.com/webappdevelp/hexo-filter-mermaid-diagrams <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/theme-next/hexo-generator-searchdb" >https://github.com/theme-next/hexo-generator-searchdb <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/hexojs/hexo-generator-feed" >https://github.com/hexojs/hexo-generator-feed <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/yanyiwu/nodejieba" >https://github.com/yanyiwu/nodejieba <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://aplayer.js.org/#/" >https://aplayer.js.org/#/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://fontawesome.com/" >https://fontawesome.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.zhheo.com/p/557c9e72.html" >https://blog.zhheo.com/p/557c9e72.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/mattboldt/typed.js/" >https://github.com/mattboldt/typed.js/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="Stay-Curious-Stay-Interesting"><a href="#Stay-Curious-Stay-Interesting" class="headerlink" title="Stay Curious, Stay Interesting"></a>Stay Curious, Stay Interesting</h2><p>在此篇博客的主页会出现<code>Dian·Stay curious</code>，侧边公告栏中出现<code>Stay curious, stay interesting.</code></p>
<p>此句是Diandian最喜欢的英语句子，源于Diandian的高中英语老师<code>Chelsea</code>。我们每次英语课前的老师问好环节，<code>Chelsea</code>会喊出前一句，我们则说出后一句😋。</p>
<p><strong>因此，让我们也在文章末尾大声地说出：“Stay curious, stay interesting!”</strong></p>
]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第一期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%B8%80%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="什么是猪脚说"><a href="#什么是猪脚说" class="headerlink" title="什么是猪脚说"></a>什么是猪脚说</h2><p>为了改善同学们的上机体验，减轻同学们的压力，集中回答编程中常见问题，继承上一辈助教的优良传统，我们<strong>为大家精心准备了猪脚说</strong>。</p>
<p>猪脚说，就是<del>猪脚</del>助教们想对大家说的话。每次上机后，我们会及时总结大家<strong>提问相对较多</strong>或<strong>比较重要</strong>的问题，在猪脚说中以详细的篇幅加以阐述，希望同学们或多或少得到一些启发。</p>
<p>猪脚说包括但不限于<strong>共性问题</strong>, <strong>coding 小技巧</strong>, <strong>课外习题</strong>。</p>
<h2 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h2><h3 id="指针详详详解"><a href="#指针详详详解" class="headerlink" title="指针详详详解"></a>指针详详详解</h3><h4 id="指针与地址"><a href="#指针与地址" class="headerlink" title="指针与地址"></a>指针与地址</h4><p>考虑如下代码，发生了什么？</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure></div>

<p>要回答这个问题，我们要从最开始的地方说起。</p>
<h5 id="你好，世界！"><a href="#你好，世界！" class="headerlink" title="你好，世界！"></a>你好，世界！</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>我们知道，数据总是存储在计算机里的。我们要打印的字符串，应该存在哪里呢？为了便于说明这个问题，我们把计算机内部存储数据的地方<strong>想象成一个大柜子，柜子有一个一个的抽屉</strong>；每个抽屉的容量是有限的，只能放得下一个字符，也就是一个<code>char</code>的内容。这里为了避免引入“字节”的概念，给出如下的大小关系：<code>4个char的大小 = 1个int的大小</code>，<code>8个char的大小 = 2个int的大小 = 1个double的大小 = 1个long long</code>的大小。</p>
<p>上述语句中的字符串，用<strong>双引号</strong>括起来，称为<strong>“字符串字面值常量”</strong>。作为字符串，它由若干字符拼接而成，后来的故事我们都知道了，在它的最后还有一个看不见的<code>&#39;\0&#39;</code>作为结束的标志；作为常量，这类字符串的内容不能被修改。</p>
<p>这样的字符串常量，储存在大柜子里的一块特定区域，称为<strong>常量区</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 15.50.21.png"
                      alt="截屏2023-02-24 15.50.21" style="zoom:40%;" 
                >

<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="type">int</span>  i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>

<p>后来我们学了变量，它们当然也装在这个大柜子里。如果这只是个有很多抽屉的柜子，那么数据的存取将变得异常困难，一个很显然的做法是，<strong>为每个抽屉编号</strong>。但另一个问题又来了，计算机自然可以通过编号访问数据；但作为编程者，我们并不知道每个变量存在哪个编号的抽屉里。于是另一个很显然的做法是，我们可以为存有变量的抽屉<strong>贴上标签</strong>，这就是<strong>标识符</strong>，例如<code>c</code>和<code>i</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.12.35.png"
                      alt="截屏2023-02-24 16.12.35" style="zoom:40%;" 
                >

<p><strong>特别要注意的是，<code>int</code>变量<code>i</code>占用了 4 个抽屉。</strong>有了这个模型，我们就能知道<code>int i = 10;</code>中，<code>i</code>表示的是存放了数字 10 的那 4 个抽屉的标签；它的编号是 21；从编号 21 开始之所以放了 4 个抽屉，是类型<code>int</code>决定的。</p>
<p><strong>后来我们知道了，这个编号，就是指针。指针，就是地址。</strong></p>
<h5 id="回答一下前面的问题"><a href="#回答一下前面的问题" class="headerlink" title="回答一下前面的问题"></a>回答一下前面的问题</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.22.14.png"
                      alt="截屏2023-02-24 16.22.14" style="zoom:40%;" 
                >

<ul>
<li>首先定义一个普通变量<code>a</code>，被装在 4 个抽屉里，抽屉的起始编号是 21，抽屉的内容是 10。</li>
<li>然后定义了一个指针变量<code>p</code>，<code>p</code>也需要 4 个抽屉存放<strong>（因为<code>p</code>的本质也是一个整数！！！）</strong>，<code>p</code>也有自己的编号 44，<code>p</code>的内容是存放<code>a</code>的抽屉的起始编号，即 21。</li>
<li><code>p</code>只存放了<code>a</code>的起始地址，<code>p</code>怎么知道<code>a</code>从 21 开始占了多少个抽屉呢？这由定义<code>p</code>的<code>int *</code>中的<code>int</code>决定。<strong>换言之，</strong><ul>
<li><code>char *p</code>表示<code>p</code>中存放一个整数，这个整数是一个地址，从那个地址开始的 1 个抽屉的内容是一个<code>char</code>变量，因为<code>char</code>只需要 1 个抽屉。</li>
<li><code>int *p</code>表示<code>p</code>中存放一个整数，这个整数是一个地址，从那个地址开始的 4 个抽屉的内容是一个<code>int</code>变量，因为<code>int</code>需要 4 个抽屉。</li>
<li><code>double *p</code>表示<code>p</code>中存放了一个整数，这个整数是一个地址，从那个地址开始的 8 个抽屉的内容是一个<code>double</code>变量，因为<code>double</code>需要 8 个抽屉。</li>
<li>……</li>
</ul>
</li>
</ul>
<h5 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h5><p>有了指针，在我们的程序里，要访问一个变量就有两种方法了。一方面，可以通过<strong>抽屉的标签</strong>，也就是<strong>变量名</strong>访问；另一方面，可以通过<strong>抽屉的编号 —— 指针</strong>，间接地访问。后者自然要加上**指针运算符（解引用）<code>*</code>**。</p>
<p>显然，在多数情况下，偏要用指针间接访问一个变量是毫无意义的。但在某些情况下，我们只能通过指针访问。考察下面的程序</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pass_by_value</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pass_by_pointer</span><span class="params">(<span class="type">int</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    pass_by_value(x);</span><br><span class="line">    pass_by_pointer(&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>稍有经验的同学不难看出，<code>x</code>的值不会被修改，<code>y</code>的值会被修改。为什么呢？</p>
<p><strong>C 程序的函数参数都是值传递的。</strong>这句话的意思是，一个函数的运行，自然会涉及一些变量，其中的一部分是函数参数，另一部分是函数内部定义的变量；<strong>在函数运行期间，函数需要借用一些抽屉来存放这些变量的值</strong>。对于<code>pass_by_value(x);</code>中的<code>x</code>，函数只会把**<code>x</code>的值<strong>放在自己借用的抽屉里，而不会意识到<code>x</code>是某处的一个标签；对于<code>pass_by_pointer(&amp;y);</code>中的<code>&amp;y</code>，函数只会把</strong><code>&amp;y</code>的值** —— <strong>这个值是一个普通整数，并且是一个地址</strong> —— 放在自己借用的抽屉里。两者的不同之处在于，前者真的只是传了一个普通整数；而<strong>后者传入的整数同时也是地址</strong>，我们在函数内部确实访问了这个地址的内容，从而真的修改了<code>y</code>的值。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.56.33.png"
                      alt="截屏2023-02-24 16.56.33" style="zoom:35%;" 
                >

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><blockquote>
<p>为了绘图简便，我们考察<code>short</code>型的数组。一个<code>short</code>变量占两个抽屉。此处我们仅考虑数组和指针的关系，数组的定义、初始化、元素访问等不再赘述。</p>
</blockquote>
<p>我们会说，<strong>数组名就是指针</strong>，这句话的意思是</p>
<ul>
<li><strong>只要知道了数组的首地址，就可以访问数组的每个元素。</strong>假设<code>p</code>存放着数组的首地址，下标从 0 开始，我们要访问下标为<code>index</code>的元素，一种写法是<code>p[index]</code> —— 相当于从数组首元素<strong>往后数</strong><code>index</code>个元素，然后访问那个元素 —— 等价于<code>*(p + index)</code>，即将<code>p</code><strong>偏移</strong>，从而使之指向欲访问的元素，然后解引用。</li>
<li>系统手里有一张表，叫做<strong>符号表</strong>。数组名是符号表中的一项，它是一个<strong>不可修改的常量</strong>，指代数组的首地址。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 17.30.56.png"
                      alt="截屏2023-02-24 17.30.56" style="zoom:40%;" 
                >

<p>当数组作为函数参数传递的时候，<strong>统一当成指针处理</strong>，所以以下三种函数声明等价：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *arr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arr[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arr[<span class="number">999</span>])</span>; <span class="comment">// 并不关心数组多大</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>后面两种声明会被翻译成第一种声明，也就是指针的形式。<ul>
<li>数组可以通过首地址访问，所以传入首地址是可行的。</li>
<li>通过指针，在<code>main</code>函数里定义的数组，可以在<code>func</code>中被修改，这与普通变量的值传递不同。</li>
</ul>
</li>
<li>前面说到，函数参数需要借一些抽屉临时存放。而函数能借到的抽屉是<strong>有限的</strong>，如果真的把一个长度为 999 的数组传入，则需要 999 × 4 个抽屉，这不太现实。只传入指针，则只需要 4 个抽屉即可 —— 通过指针间接访问数组。</li>
<li>此外，上一点也提醒我们，<strong>函数内部并不知道数组有多大，它只知道数组的首地址</strong>。所以对数组操作的函数，一般需要再加上一个<code>size</code>参数，保证函数中不会出现<strong>数组越界</strong>的情况。</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>在最开始的地方谈到，用双引号扩起来的字符串常量，被存放在大柜子的一块特定区域，即常量区。事实上，不仅是我们想要输出的文本信息，<strong>C 程序中任何地方</strong>出现的字符串常量，都会被存在那里。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="type">char</span> *s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br></pre></td></tr></table></figure></div>

<p>这里的<code>&quot;%d %d&quot;</code> <code>&quot;hello world&quot;</code> <code>&quot;%s\n&quot;</code>都是字符串常量，都会被预先存在常量区。另一方面，这种字符串常量的最后都默认有一个看不见的<code>&#39;\0&#39;</code>作为结束的标志，这是系统自动加上的。</p>
<p>我们想象这样的画面，每个抽屉只能装一个字符，<strong>只要我们知道了字符串的第一个字符装在哪个抽屉，然后依次往后拉开抽屉，直到拉开了存放<code>&#39;\0&#39;</code>的那个抽屉为止，我们就获得了字符串的所有内容</strong>。于是，<strong>字符串的首地址就成为了确定一个字符串唯一所需要的信息。</strong><code>char *s = &quot;hello world&quot;;</code>的那个指针<code>s</code>，做的就是这件事。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 11.57.03.png"
                      alt="截屏2023-02-25 11.57.03" style="zoom:40%;" 
                >

<p><strong>另一方面，字符串也可以存在我们自定义的数组里，但是其初始化值得考察。</strong>假设我们要存入的是<code>&quot;abc&quot;</code>。</p>
<ul>
<li><p>数组大小应该开够，因为需要有<code>&#39;\0&#39;</code>作为结束标志</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 开得足够大，并且别忘了 \0</span></span><br><span class="line"><span class="type">char</span> s[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;   <span class="comment">// 不写大小，由系统自动判断，此处 s 大小即为 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">4</span>]; s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>; s[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>; s[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span> = s[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 更加麻烦的逐一赋值，但 OK</span></span><br></pre></td></tr></table></figure></div>

  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 12.02.53.png"
                      alt="截屏2023-02-25 12.02.53" style="zoom:40%;" 
                >
</li>
<li><p>有一种<strong>便捷手段</strong>，在初始化的时候，<strong>用字符串字面值常量为字符数组赋初值</strong></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 开大点总是保险</span></span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>;   <span class="comment">// 这么做默认 s 大小为 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严禁这么做！</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>]; <span class="comment">// 定义了一个数组，数组名是符号表中的常量</span></span><br><span class="line">s = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 给一个符号常量赋值，是绝对不行的</span></span><br></pre></td></tr></table></figure></div>

  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 12.08.20.png"
                      alt="截屏2023-02-25 12.08.20" style="zoom:40%;" 
                ></li>
</ul>
<h4 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h4><p><strong>指针是工具，是用来使用的。</strong></p>
<p>对指针的本质进行解析，为的是让大家理解其使用方式。使用指针，需要的是在脑海中形成意识“我们就是这么做的”“这么做是合理的”。对于指针的基本理解包括但不限于以下几点</p>
<ul>
<li>指针是个<strong>变量</strong>，指针是个<strong>整数</strong>。</li>
<li>取变量的地址赋值给指针，我们就说指针指向了那个变量。</li>
<li>指针“指向”，只是说指针中存了一个整数地址；<strong>要访问变量，需要一次解引用</strong>。</li>
<li><strong>数组名是一个符号</strong>，等价于数组首地址。</li>
<li>双引号扩起来的字符串是常量，只读不写。</li>
</ul>
<p>我们需要培养一些基本的意识，要知道“我可以写什么，不可以写什么”。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr; <span class="comment">// arr符号代表首地址，赋值给指针，当然可以</span></span><br><span class="line">p[<span class="number">1</span>] = <span class="number">5</span>;     <span class="comment">// 指针也可以像数组一样访问</span></span><br><span class="line">*(p + <span class="number">2</span>) = <span class="number">2</span>; <span class="comment">// 指针自己也具备了“偏移 + 解引用”操作</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *s  = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 这是指针指向字符串常量</span></span><br><span class="line"><span class="type">char</span> t[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 这是一个普通数组，并使用了便捷方式初始化</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span>;       <span class="comment">// 字符串常量不能修改！</span></span><br><span class="line">t[<span class="number">1</span>] = <span class="string">&#x27;y&#x27;</span>;       <span class="comment">// 数组当然可以修改</span></span><br></pre></td></tr></table></figure></div>

<p>最后补充的是<code>NULL</code>和<code>const</code>指针。</p>
<h5 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a><code>NULL</code></h5><p>指针是一个<strong>整型变量</strong>，它的取值无非有这么几种</p>
<ul>
<li>只定义但未初始化，是一个随机值。</li>
<li>进行初始化或赋值，“指向了其他的变量”。</li>
<li>初始化为 0。（编号为 0 的那个抽屉存了啥？）</li>
</ul>
<p><code>NULL</code>是一个宏，代表整数 0，用于指针的初始化：<code>int *p = NULL;</code> 当然也可以写 <code>int *p = 0;</code>。</p>
<p>当一个指针未初始化时，它可能指向任何地方，但是那里究竟能不能访问是未知的，这就是<strong>野指针</strong>。在有些情况下，访问了不该访问的地方，可能导致系统崩溃。人们规定，<strong>编号为 0 的那个抽屉是一个无效的抽屉，一旦访问，程序运行就强制结束了</strong>（总比系统崩溃好）。所以在将指针指向某个变量之前，初始化为 0 或<code>NULL</code>，是有必要的。</p>
<h5 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a><code>const</code>指针</h5><p>我们知道字符串常量存在常量区，但其他常量，如<code>const int</code>，还是和普通变量放在一起的。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></div>

<p>当编译器看到这两行代码，它会说：“<code>a</code>被定义为常量，你却要为<code>a</code>赋其他值，不可以！”于是报错。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line">*p = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></div>

<p>当编译器看到这两行代码，它会说：“<code>a</code>是常量，存在内存里了。<code>p</code>想要指向它，当然可以。对指针<code>p</code>解引用进行赋值，当然可以。”于是真的，一个<code>const int</code>的值通过指针被修改了。</p>
<p>所以我们有必要避免这种情况，手段就是<strong>“指向常量的指针”</strong>。前文说到，<strong>指针是统一的一种类型，就是整型</strong>。定义指针时前面的类型，只是告诉系统，“连续打开几个抽屉”。打开抽屉后，无非有两种操作：看一下里面是什么（<strong>读</strong>操作）和修改一下内容（<strong>写</strong>操作）。对于后者，如果抽屉里装的是常量，则应该避免。</p>
<p>在定义指针的最前面加上<code>const</code>修饰，如<code>const int *p = &amp;a;</code>，就定义了指向常量的指针。这么做的好处是，<code>p</code>说：“我是指针，我指向<code>a</code>，但你<strong>无法通过我</strong>修改<code>a</code>的值，<strong>你有没有其他手段修改<code>a</code>的值，与我无关。</strong>”</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a; <span class="comment">// 这是正确的，定义了指向常量的指针</span></span><br><span class="line">*p = <span class="number">100</span>;          <span class="comment">// 通过 p 无法修改 a</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *q = &amp;b; <span class="comment">// 指向常量的指针指向了普通变量</span></span><br><span class="line"><span class="type">int</span> *r = &amp;b;       <span class="comment">// 普通的指针指向了普通变量</span></span><br><span class="line">*q = <span class="number">100</span>;          <span class="comment">// 无法通过 q 修改 b 了，哪怕 b 是一个普通变量</span></span><br><span class="line">*r = <span class="number">100</span>;          <span class="comment">// 这么改当然可以</span></span><br></pre></td></tr></table></figure></div>

<p>于是我们会在大量字符串处理函数的原型中，看到参数都定义为<code>const char *p</code>类型，这就是说，字符串通过<code>p</code>传入函数，<strong>保证在函数内部，不会修改字符串的内容</strong>。这么做是严谨的。</p>
<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><h4 id="库函数功能介绍"><a href="#库函数功能介绍" class="headerlink" title="库函数功能介绍"></a>库函数功能介绍</h4><p><code>size_t</code> 为无符号整数类型，它是 <strong><code>sizeof</code></strong> 关键字的结果。</p>
<p>下列常用字符串处理函数均定义在头文件  <code>&lt;string.h&gt;</code> 中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 把 str1 和 str2 的前 n 个字节进行比较。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 从 src 复制 n 个字符到 dest。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复制字符 c （一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</span></span><br><span class="line"><span class="comment">	e.g.想要将一个 int 类型数组 a[50] 全部置为0:</span></span><br><span class="line"><span class="comment">		memset(a, 0, sizeof(a));</span></span><br><span class="line"><span class="comment">	等效于 for (i=0; i &lt; 50; i++) a[i] = 0;</span></span><br><span class="line"><span class="comment">	【特别注意】一般此函数仅用于全部归零，其他值不能随便设置！！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="comment">// 把 src 所指向的字符串（包括&#x27;\0&#x27;）追加到 dest 所指向的字符串的结尾（删除 dest 原来末尾的&#x27;\0&#x27;）。</span></span><br><span class="line"><span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 的字符串。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 把 src 所指向的字符串的前 n 个字符追加到 dest 所指向的字符串的结尾（删除 dest 原来末尾的&#x27;\0&#x27;）。</span></span><br><span class="line"><span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 的字符串。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="comment">	返回值为该字符串中第一次出现的字符的指针，若不包含该字符则返回 NULL 空指针。</span></span><br><span class="line"><span class="comment">	char *strrchr(const char *str, int c);</span></span><br><span class="line"><span class="comment">	在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	把 str1 所指向的字符串和 str2 所指向的字符串进行比较并返回整数。若两字符串相等，则返回零。</span></span><br><span class="line"><span class="comment">	若 str1 &lt; str2, 则返回负数; 若 str1 &gt; str2, 则返回正数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line">	<span class="comment">// 把含有&#x27;\0&#x27;结束符的字符串 src 复制到以 dest 开始的地址空间。</span></span><br><span class="line">	<span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 字符串。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line">	<span class="comment">// 把字符串 src 的前 n 个字符复制到以 dest 开始的地址空间。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">// 计算字符串 str 的长度，知道空结束字符但不包括空结束字符。返回值数据类型为无符号整型。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="comment">// 在字符串 dest 中查找第一次出现字符串 src（不包含空结束字符）的位置。</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>补充练习：字符串处理函数与指针的使用。<strong>此题将在下周上机详细讲评。</strong></p>
<p>输入 n 个字符串，将每个字符串中的<code>good</code>子串全部替换为<code>perfect</code>后输出。（不用担心数据范围，写代码实现此功能即可）。</p>
<p><strong>样例输入</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">abc123</span><br><span class="line">BUAA  goodddd 123 Good</span><br><span class="line">godgoodgodgoooood goo? gooD good!</span><br></pre></td></tr></table></figure></div>

<p><strong>样例输出</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc123</span><br><span class="line">BUAA perfectddd 123 Good</span><br><span class="line">godperfectgodgoooood goo? gooD perfect!</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="读取字符串"><a href="#读取字符串" class="headerlink" title="读取字符串"></a>读取字符串</h4><p>很多同学在使用 <code>gets()</code> 函数读取字符串时，可能在 judge 平台的编译器上收到这样的提示:</p>
<p><strong>Warning: the ‘gets’ function is dangerous and should not be used.</strong></p>
<p>原因在于：**<code>gets()</code>函数不做地址越界检查！**若输入的字符串大于既定数组的长度，程序运行会出现难以预期的错误。<a class="link"   href="https://blog.csdn.net/weixin_33748818/article/details/89776085" >有兴趣的同学可以从这篇文章中作详细了解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>在此，我们建议使用如下两种方式读取字符串:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"><span class="comment">// 该函数更多被用来读取单词，而非整行字符串。它从一个非空白字符开始，读到下一个空白字符为止。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[BUFSIZ] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">fgets(buf, BUFSIZ, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="comment">// 该函数的第二个参数代表规定从标准输入读取字符上限的数量，这也是它优于 gets() 函数的地方。</span></span><br><span class="line"><span class="comment">// 我们更推荐大家使用此种方法来读取整行字符串。</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>BUFSIZ</code>是宏定义在头文件里的常数，一般值为 512，对于大家完成上机作业已经够用了。</p>
</li>
<li><p><code>stdin</code>为标准输入，也就是键盘输入。在之后的文件输入输出时，可以修改此参数为文件指针。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong></p>
<p><code>fgets()</code> 函数会读取 <code>&#39;\n&#39;</code> 并写进数组中, 因此使用<code>strlen()</code> 函数求取数组长度时, 得到的长度比实际可见字符数多 1，其中包含了最后一个换行符。</p>
</blockquote>
<h3 id="char与int的转换"><a href="#char与int的转换" class="headerlink" title="char与int的转换"></a><code>char</code>与<code>int</code>的转换</h3><p>先来看第一次作业填空题第四题:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">invert</span><span class="params">(<span class="type">char</span> str[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>, j = <span class="built_in">strlen</span>(str)<span class="number">-1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">		k = str[i];</span><br><span class="line">		str[i] = str[j];</span><br><span class="line">		str[j] = k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不少同学都来提问: <code>k</code>不是<code>int</code>类型的变量吗，怎么能够和一个字符进行相应的运算关系？</p>
<p>需要指出的是：某个字符和它由 <strong>ASCII 码表</strong>所对应的整型值是等价的。即如果用整型值 48 赋值给某个字符，则其输出结果会是 ‘0’; 如果用字符常量 ‘0’ 赋值给某个整型变量，则其输出后为 48。</p>
<p><code>char</code>型实际上就是 0 到 127 的整型数经过 <strong>ASCII 码表</strong>映射的结果，其与<code>int</code>型的转换需要代入映射后得到对应值。</p>
<p>如果还有同学有疑问或者想要了解更多例子，不妨看下面一些代码:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) </span><br><span class="line">    <span class="comment">// do something</span></span><br></pre></td></tr></table></figure></div>

<p>上述代码为最简单的两个字符比较大小，其本质上是以相应的<strong>ASCII码表</strong>值的大小作为字符比较的标准。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">char</span> str[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line"> 			str[i] += <span class="number">32</span>; </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码可以实现把一段字符串中的大写字母全部转化为小写字母，其中倒数第三行就是字符与整型量的运算。</p>
<h2 id="第一次作业补充练习"><a href="#第一次作业补充练习" class="headerlink" title="第一次作业补充练习"></a>第一次作业补充练习</h2><p><a class="link"   href="https://www.luogu.com.cn/training/48079" >此链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>可以收藏起来，若有需求可以去做一些练习。</p>
<p>1、 <a class="link"   href="https://www.luogu.com.cn/problem/P5734" >处理字符串，主要考察大家对常用字符串处理库函数的运用。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>2、 <a class="link"   href="https://www.luogu.com.cn/problem/P1308" >单词统计，注意题干要求处理大小写字母。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>3、 <a class="link"   href="https://www.luogu.com.cn/problem/P1022" >改良计算器，为第一次上机第二道编程的拓展。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>4、 <a class="link"   href="https://www.luogu.com.cn/problem/P8652" >对于小数点后位数的处理。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>5、<a class="link"   href="https://www.luogu.com.cn/problem/P2293" >高精度开根，第一次上机第四道编程的拓展。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第二期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%BA%8C%E6%9C%9F/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets2/IMG_0716.jpg"
                      alt="IMG_0716" style="zoom:33%;" 
                >

<blockquote>
<p><strong>写在前面 —— 关于理论与实验</strong></p>
<p>我们可以很负责地告诉大家，几乎所有的计算机软件核心专业课（如计算机组成原理、操作系统、编译原理、计算机网络等），都由理论和实验两部分构成。前者，基本建立在抽象的层面上，一般以<strong>文字表述和数学公式</strong>给出；后者，基本需要个人在实践中完成。实验的内容一般由指导书、手册等给出，需要<strong>自行阅读了解</strong>；而其中涉及的工具和方法，如虚拟机、编程工具、编程语言等，完全<strong>通过自学解决</strong>。</p>
<p>幸运的是，作为一门承上启下的课程，数据结构课的重点知识并非仅纯数学符号。由于我们的学习进度尚有限，这门课在日常教学中也融入了大量 C 语言代码，并且几乎可以当作“板子”。所谓板子，就是<strong>可以直接拷贝黏贴</strong>的东西，<del>每到考试，也会出现打板子、拼接板子等现象</del>。</p>
<p>这给我们两点启发。其一，很多知识在课件里就能找到，当同学们遇到困难时（如文件操作、结构体），不必等老师讲授，自行看课件、搬运代码，很多问题就能迎刃而解。其二，我们必须强调自学的重要性，善于通过各类渠道解决问题。举个例子，仅通过搜索引擎，就可以查询到近来上机出现的诸多问题。</p>
<p>此外，由于实验的基本形式是选填和编程题，而非从零开始迭代着制造一个东西，所以就没有指导书的必要。<strong>我们的“猪脚说”则作为上机实验的补充指导，解答共性问题、提供知识总结，希望对大家有所帮助。</strong></p>
</blockquote>
<h2 id="常见问题汇总"><a href="#常见问题汇总" class="headerlink" title="常见问题汇总"></a>常见问题汇总</h2><blockquote>
<p><strong>为什么我本地测试正确，提交运行却出现了多余字符？</strong></p>
</blockquote>
<p>数组是一片连续的内存空间，<strong>数组之外的内容是不可控的</strong>。当我们越界访问时，有可能成功，有可能报错，有可能读取到随机内容。因此，这类问题的主要原因是数组开得不够大和未初始化。</p>
<p><strong>(1) 数组大小。</strong>题目不一定给出明确的数据范围，如果有数据范围，比如 80，则开到100 比较合适，甚至 200、500 等都不过分。如果没有数据范围，则根据经验考虑，如字符数组开 512 或 1024 大小，整型数组开 200、1000 等。一般不会在数据范围的问题上为难大家，但如果开得和题目说的一样大，确实更容易出错（如忘了字符串末尾的<code>&#39;\0&#39;</code>，下标从 1 开始等）。</p>
<p><strong>(2) 初始化。</strong>很多时候都需要把一个数组或变量初始化成 0。考虑这样一种情况，我们逐个字符地构造一个字符串，结果最后忘了添加<code>&#39;\0&#39;</code>，<strong>如果这个字符数组先前被初始化成全 0，则字符串的后面还是有<code>&#39;\0&#39;</code>的</strong>；如果未初始化，字符串后面的内容则是未知的，极有可能出错。下面给出一些常见的初始化方式。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码都处在 main 函数中</span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;          <span class="comment">// 初始化为全 0</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">10</span>] = &#123;<span class="number">1</span>&#125;;          <span class="comment">// 仅 arr2[0] 为 1，其他都是 0</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;          <span class="comment">// 全部初始化为 &#x27;\0&#x27;，等价于 char str[10] = &#123;&#x27;\0&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环也是初始化的常见方式，千万不要觉得麻烦！</span></span><br><span class="line"><span class="type">int</span> arr3[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr3[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> arr4[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">        arr4[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>(3) 全局变量。</strong>全局变量会执行<strong>默认初始化</strong>，一般自动初始化成 0；且在各个函数中都能直接访问，简化了参数列表。但正如同先前谈到的代码风格问题，频繁使用全局变量并不是一个好习惯。一般地，只有需要很大的数组，如<code>int [1000000]</code>，或常量，如<code>const int MAX_LENGTH = 1024;</code>的时候，才会使用全局变量。</p>
<blockquote>
<p><strong>为什么错误输出和期望输出一模一样还会 WA？</strong></p>
</blockquote>
<p>这种问题多数是由于通过<code>printf(&quot;%c&quot;, c);</code>的方式输出导致的。在打印过程中，可能不慎打印了空白字符。空白字符在网页上显示不出来，但在评测机进行比对的时候，就会认为错误。解决的方法是，在本地把代码改成<code>printf(&quot;%c0&quot;, c);</code>（我们假设正确的输出中不含 0，如果有冲突就换一个字符），这样如果输出了诸如<code>a0b0c00</code>的内容，就说明在最后一个 0 的前面还输出了不可见字符。打印了空白字符很可能是为字符变量赋值或初始化的逻辑有漏洞引起的，需要结合代码具体分析。</p>
<blockquote>
<p><strong>为什么这种不合法的情况也还是会输出啊？</strong></p>
</blockquote>
<p>没有按照题目要求输出内容，多数是代码逻辑的问题引起的。我们仅以第一次作业的“拓展字符”为例，看一种典型的错误。伪代码如下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">遍历字符串:</span><br><span class="line">    <span class="keyword">if</span> (当前字符为 <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;-&#x27;</span> 的前后同为 a-z 或 A-Z 或 <span class="number">0</span><span class="number">-9</span>) &#123;</span><br><span class="line">            <span class="type">int</span> d = 后字符 - 前字符;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= d; i++) &#123;</span><br><span class="line">                print 前字符 + i；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        原样输出字符;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>对于合法的可拓展字符，这段代码可以成功拓展。考虑 “g - a” 这类情况，程序会先连续进入两个<code>if</code>，但是<code>d</code>算出来为负数，所以<code>for</code>循环不执行，好像也符合要求。但是，一旦进了第一个<code>if</code>，则<code>else</code>分支原样输出将不被执行。这就是典型的逻辑漏洞。</p>
<p>另外，多数情况下的“运行超时”都是死循环导致的，这与代码逻辑也密不可分。</p>
<p>解决逻辑问题的常见手段是调试。如果你尚未掌握自己所用 IDE 的调试方法，不妨在程序的多个地方<strong>打印变量的值</strong>，观察程序的运行过程；如果需要判断是否进入某个分支、循环多少次等，也可以采用打印的方法。通过有效的<strong>工具手段和纸面演算</strong>解决程序逻辑问题，是每个人必备的基本功。当然，<strong>将代码提取成函数</strong>，也有助于缩小错误的范围。</p>
<h2 id="qsort函数详解"><a href="#qsort函数详解" class="headerlink" title="qsort函数详解"></a><code>qsort</code>函数详解</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>C 标准库 ```<stdlib.h>```中。函数原型如下：</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```C</span><br><span class="line">void qsort(void *base, </span><br><span class="line">           size_t num, </span><br><span class="line">           size_t width, </span><br><span class="line">           int(*cmp)(const void* e1, const void* e2));</span><br></pre></td></tr></table></figure></div>

<p><strong>该函数可实现的功能是：按照某种自定义的规则（ <code>cmp</code>函数），对数组<code>base</code>的 <code>num</code>个元素进行排序。</strong></p>
<p>想要理解<code>qsort</code>函数的具体实现方式，我们首先引入<strong>回调函数</strong>的概念：</p>
<blockquote>
<p>回调函数就是一个<strong>通过函数指针调用的函数</strong>。如果把函数的指针作为<strong>参数</strong>传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。</p>
</blockquote>
<p>显然<code>qsort</code>函数的四个参数中，**<code>cmp</code>参数就是回调函数，我们需要使用它来指导<code>qsort</code>函数的进行**。当<code>qsort</code>函数想要确定某两个元素的排列顺序时，会将这两个元素的指针 p1 和 p2 传入<code>cmp</code>函数进行元素值的比较：</p>
<ul>
<li><p>如果<code>cmp</code>函数返回值小于 0，则 p1 所指向元素会被排在 p2 所指向元素的前面；</p>
</li>
<li><p>如果<code>cmp</code>函数返回值等于 0，则 p1 所指向元素与 p2 所指向元素的顺序不确定（因为<strong>在某种意义上</strong>两个相同的元素谁在前谁在后都无伤大雅）；</p>
</li>
<li><p>如果<code>cmp</code>函数返回值大于 0，则 p1 所指向元素会被排在 p2 所指向元素的后面。</p>
</li>
</ul>
<p>可是，<strong>设计者在设计<code>qsort</code>函数时，不知道使用者会排序什么类型的元素，<code>qsort</code>函数自身也不清楚数组元素的类型是什么，但是它又必须实现元素两两之间的比较与交换。</strong>怎么办呢？最高效的方式就是从数据的存储入手，我们只需要<strong>将两个数据所占有的内存的内容交换【可以表述成：将属于 p1 的若干个抽屉的内容全部取出，将属于 p2 的若干个抽屉的内容全部取出，两者交换（详见猪脚说第一期😋）】</strong>便可实现任意类型元素的排序了。</p>
<p>需要交换的字节大小视具体情况而定，这时候参数<code>width</code>与<code>cmp</code>函数里的<code>void *</code>的作用就体现出来了。</p>
<p><strong><code>void *</code>称为通用指针</strong>，它就像一个垃圾桶，什么地址都可以往里扔，我们需要做的只是<strong>在自己写的<code>cmp</code>函数里对扔进来的地址做强制类型转换</strong>，再通过<code>width</code>参数规定所交换字节内容的大小，如<code>sizeof(int)</code>、<code>sizeof(char)</code>、  <code>sizeof(struct Node)</code>等，就可以使<code>qsort</code>函数按你所需地对目标数组元素进行排序。</p>
<p>现在我们以一段实操代码为例，感受<code>qsort</code>函数的使用方式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span>*)e1 &lt; *(<span class="type">int</span>*)e2) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 也可写成如下形式：</span></span><br><span class="line">    <span class="comment">// int *a = (int *)e1;</span></span><br><span class="line">    <span class="comment">// int *b = (int *)e2;</span></span><br><span class="line">    <span class="comment">// return (*a &lt; *b) ? -1 : 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    qsort(a, <span class="number">1000</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	特别要注意，部分教程在 cmp 中直接写</span></span><br><span class="line"><span class="comment">	`return *a - *b;`</span></span><br><span class="line"><span class="comment">	这是有巨大隐患的。具体原因请结合 int 能表示的范围有限思考。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p>通过我们自己写的<code>cmp</code>函数得知，当返回值小于 0（即 e1 所指向元素小于 e2 所指向元素时），e1 所指向元素会被排列在 e2 所指向元素的前面，且每次<strong>严格按照<code>int</code>类型所占有的字节宽度为限度</strong>进行交换，由此可实现数组 a 中所有元素由小到大排序。</p>
<p>当然，若想实现元素由大到小排序，只需将<code>cmp</code>中内容改写为<code>return (*(int*)e1 &gt; *(int*)e2) ? -1 : 1;</code></p>
<p>值得注意的是，若对于<code>double</code>类型数组进行由小到大的排序，我们需将<code>cmp</code>函数写为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span> <span class="comment">// 调用 fabs 需要包含此头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(*(<span class="type">double</span>*)e1 - *(<span class="type">double</span>*)e2) &gt; <span class="number">1e-7</span>)  <span class="comment">// 浮点数判断是否相等的方式：和极小量比较！</span></span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">double</span>*)e1 &gt; *(<span class="type">double</span>*)e2 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="学习结构体的意义在哪儿"><a href="#学习结构体的意义在哪儿" class="headerlink" title="学习结构体的意义在哪儿"></a>学习结构体的意义在哪儿</h2><blockquote>
<p>结构体的声明、定义和使用都相对简单，结合课件即可掌握。较新的内容是指向结构体的指针，<strong>建议忽略本质、注重语法和使用</strong>，随着一两周后链表的学习，很快即可上手。</p>
</blockquote>
<p>先来考虑这样一种需要处理的情形：一个班级里有若干学生，每个学生的学号、姓名、成绩三个信息需要被记录，现在我们需要对其中的某些学生的信息进行数据处理，声明结构体如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> number[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>显然，如果我们只需要记录一位学生，大可不必使用<code>struct student kid;</code>的定义形式，也不需要在后续访问变量时使用<code>kid.number</code>、<code>kid.name</code>、<code>kid.grade</code>如此繁杂的方式。我们只需要分别定义两个字符串数组、一个<code>int</code>类型变量即可，此时<strong>为了某种程度上的整洁而声明结构体类型、定义结构体变量反而显得多此一举</strong>。</p>
<p>可是，一个班级的整体数据肯定不能只由一位同学代表，往往我们需要处理多达上百个同学的数据，这时结构体的优势就开始显现。如果我们借助结构体变量的数组存储，那么只需要定义<code>struct student info[200];</code>后续每个学生的学号、姓名、成绩均可以作为成员储存在一个结构体变量中。</p>
<p>虽然我们仍可分别定义以下三个数组储存学生信息，每个学生的信息一一对应地储存于各数组中:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> stu_number[<span class="number">200</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> stu_name[<span class="number">200</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> stu_grade[<span class="number">200</span>];</span><br></pre></td></tr></table></figure></div>

<p>显然，若我们需要了解第 i+1 个学生的信息（假设数组下标从 0 开始），我们可以直接在<code>info[i]</code>这一结构体变量中全部寻得，也可以通过依次访问<code>stu_number[i]</code>、<code>stu_name[i]</code>、<code>stu_grade[i]</code>寻得。但前者不是更简洁方便、显得整体化吗？</p>
<p>因此，我们可以这样说：<strong>结构体存在的意义在有数组时才能体现。</strong></p>
<p>但是，如果只需完成类似于统计班级里有多少同学姓“王”、有多少同学成绩在 90 分以上这样的任务，大可以使用上述三个数组，用遍历的方法求得满足条件学生的总数，似乎数组完全可以代替结构体变量，并且不会导致任何工作量的增加。<strong>这是因为这样的任务并没有把学生的三个信息建立起联系，对某一个信息进行统计的时候可以完全不用顾虑其他信息与之对应。</strong></p>
<p>那么问题来了：当需要将学生的成绩按照<strong>由大到小</strong>的顺序输出，并同时输出每个同学对应的姓名与学号，使用哪种方式更好呢？</p>
<p>对于这个问题，刚刚学习了<code>qsort</code>函数的你想要进行实践。若你使用常规的数组存储，很快便遇到了困难。你并不知道<code>qsort</code>函数每次是对哪两个具体元素进行了比较，因此你单纯地将<code>stu_grade</code>数组排好了序，但其余两个数组与<code>stu_grade</code>数组的对应关系已经完全丧失，再无可能正确地输出每一个成绩所对应的姓名与学号。</p>
<p><strong>但如果用<code>qsort</code>函数对结构体进行排序呢？</strong></p>
<p>通过前文的讲解我们知道，我们的**<code>cmp</code>函数规则应该是对于每个结构体中的<code>grade</code>变量进行比较，但比较后的结果，是交换这个结构体变量所拥有的全部字节内容<strong>，而这个内容中既包含了<code>grade</code>、也包含了<code>number[]</code>和<code>name[]</code>，因此我们便做到了</strong>在保留原有成员变量一一对应关系的基础之上，对学生成绩进行了排序**。</p>
<p>综上所述，在排序这样一个实际例子中，结构体变量存在着至关重要的意义与价值。</p>
<p>当然，结构体还有许多的应用场景，比如大家后续所要学习的链表……这里我们就不再详述。</p>
<p>另值一提的是，请同学们看看如下代码是否正确：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> student*)e1-&gt;grade &lt; (<span class="keyword">struct</span> student*)e2-&gt;grade) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果<code>cmp</code>函数内容如上所示，则使用<code>qsort</code>函数排序会出现奇怪的错误。原因是因为**类型转换符<code>(type *)</code>的运算优先级低于箭头运算符<code>-&gt;</code>**。所以会先计算<code>e2-&gt;grade</code>，再去做类型转换。因此正确写法为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">struct</span> student*)e2)-&gt;grade &lt; ((<span class="keyword">struct</span> student*)e1)-&gt;grade) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="标准-C-库文件-I-O"><a href="#标准-C-库文件-I-O" class="headerlink" title="标准 C 库文件 I&#x2F;O"></a>标准 C 库文件 I&#x2F;O</h2><blockquote>
<p><strong>文件 I&#x2F;O，即文件的输入输出（Input &#x2F; Output）</strong>，几乎是每一个软件项目必备的模块。此外，我们称读取一个文件的内容为<strong>“读文件”</strong>，称编辑一个文件的内容为<strong>“写文件”</strong>。</p>
<p>以 macOS、Linux、Windows 为代表的多数操作系统，都引入了文件的概念。<strong>资源即文件。</strong>文件不仅包括屏幕上显示的一个个“文件”，还包括各类设备，如鼠标、键盘、打印机、屏幕（标准输出）、音响、U 盘等。一般来说，我们接触到的文件有两类 —— <strong>文本文件</strong>和<strong>二进制文件</strong>。前者，可以理解为<strong>字符构成的有序集合</strong>，如 filein.txt 文本文件、test.c 源代码文件；后者的典型代表是 a.exe 这类<strong>可执行文件</strong>。特别要注意，word 等工具编辑出的 .docx 文件属于二进制文件，是不能直接用我们接下来要讲到的文件操作函数处理的。</p>
<p>这门课程涉及的文件操作无非基本的读写，可以理解成<strong>程序中字符数组里的内容与文件间的交换</strong>。关于判断文件是否存在、文件的创建 &#x2F; 删除 &#x2F; 复制 &#x2F; 移动 &#x2F; 重命名等操作，感兴趣的同学可以自己了解。</p>
</blockquote>
<h3 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h3><p>操作系统中的文件构成一个<strong>树状结构</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets2/截屏2023-03-05 14.26.17.png"
                      alt="截屏2023-03-05 14.26.17" style="zoom:30%;" 
                >

<p>文件系统从一个根出发，<strong>每个文件夹就是树枝的分叉、每个文件就是树叶</strong>。这里的<strong>文件夹，就是目录</strong>。目录下可以包含若干文件，也可以为空。<strong>目录本身也是文件，是一种特殊的文件。目录中默认有两个隐藏的文件，文件名为<code>.</code>和<code>..</code>，分别表示自身和父目录。</strong></p>
<p>定位一个文件，就需要给出文件的路径。一种方法是从根开始，一路写到当前文件，如<code>D:\MyFiles\DSLearning\main.c</code>，这就表示打开 D 盘，进入 Myfiles 文件夹，进入 DSLearning 文件夹，就可以找到 main.c 文件。这种方式称为<strong>绝对路径</strong>。另一种方法是，以<strong>当前所在的目录为基准点，描述目标的相对位置</strong>。以上图为例，假设我们处在 gcctest 目录下，则 foo.c 文件可以直接写<code>foo.c</code>或<code>./foo.c</code>（因为<code>.</code>表示当前目录），libfoo.so 文件可以写成 <code>include/libfoo.so</code>，bank.c 文件可以写成<code>../IPCtest/bank.c</code>（因为<code>..</code>表示父目录）。</p>
<p>上文中提到“当前所在目录”，可以简单理解为<strong>程序运行的目录</strong>，即 .exe 文件所在的目录。一般来说，<strong>把文件和 .exe 文件放在一起，在函数调用时直接指定文件名即可</strong>。</p>
<h3 id="标准-C-库文件操作函数"><a href="#标准-C-库文件操作函数" class="headerlink" title="标准 C 库文件操作函数"></a>标准 C 库文件操作函数</h3><p>在学习 C 语言的第一天，我们就知道要<code>#include &lt;stdio.h&gt;</code>，std 即 standard，io 即上文所述。我们调用的<code>printf</code>等，正是 C 库提供的 I&#x2F;O 函数。调用以下函数，也应包含此头文件。</p>
<h4 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">FILE* <span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">	<span class="comment">// 打开文件，成功返回文件指针，出错返回 NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 关闭文件，成功返回 0，出错返回 -1</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>这里的“文件指针”<code>FILE*</code>，是在<code>&lt;stdio.h&gt;</code>中定义的一个<strong>结构体指针</strong>，该结构体包含了一个文件的各类信息。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此代码块内容仅供了解 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> cnt;			<span class="comment">// 剩余字节数</span></span><br><span class="line">    <span class="type">char</span> *ptr;			<span class="comment">// 下一个字符的位置</span></span><br><span class="line">    <span class="type">char</span> *base;			<span class="comment">// 缓冲区的位置</span></span><br><span class="line">    <span class="type">int</span> flag;			<span class="comment">// 文件访问模式</span></span><br><span class="line">    <span class="type">int</span> fd;				<span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="comment">// 还有很多</span></span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>获取了一个文件的文件指针，将其作为参数传递给其他函数，即可读写对应的文件。</strong>很多时候，文件打开会失败，则<code>fopen</code>返回<code>NULL</code>。因此，建议同学们以以下方式打开一个文件。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示范代码，这部分代码位于 main 中</span></span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen error&quot;</span>); <span class="comment">// 此函数在 &lt;stdio.h&gt; 中，能帮助输出错误信息</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);               <span class="comment">// 此函数在 &lt;stdlib.h&gt; 中，能强制结束程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>fopen</code>函数的第一个参数为<strong>文件路径</strong>，前文已经说明。第二个参数指定打开方式，常见的是<code>&quot;r&quot;</code>和<code>&quot;w&quot;</code>。前者表示读，后者表示写。<strong>读文件，要求文件已经存在</strong>，否则会打开失败；写文件，<strong>默认不存在则创建</strong>，如果存在且已经有内容，则<strong>清空</strong>后从头开始写。</p>
</li>
<li><p>程序运行时默认已经打开了三个文件 —— 标准输入<code>stdin</code>、标准输出<code>stdout</code>、标准错误<code>stderr</code>，这是三个文件指针，分别对应键盘、屏幕、屏幕。</p>
</li>
</ul>
<blockquote>
<p>使用<code>fopen</code>打开一个文件，则应当使用<code>fclose</code>关闭。当然做编程题的时候不写也没事。但是，这种规范操作仍应当强调，即便你可能并不会在意。当然，如果日后你因为忘记 close 或 free 而导致一个实际项目出现 bug，你一定会有所感悟的。</p>
</blockquote>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>通过<code>fopen</code>获得文件指针后，可以调用相关 I&#x2F;O 函数读写文件。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> size, FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 以行为单位读取文件指针 fp 对应的文件中的内容，存到字符数组 str 中，一次最多读取 size 个字符</span></span><br><span class="line">    <span class="comment">// 读取成功返回 str，读到文件末返回 NULL</span></span><br><span class="line">	<span class="comment">// 此函数会读取换行符，这与 gets 不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 1</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">fgets(str, <span class="number">1024</span>, <span class="built_in">stdin</span>);  <span class="comment">// 从键盘读取字符串，基本等价 gets，但会读进换行符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 2</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);              <span class="comment">// 如果打开失败则结束程序</span></span><br><span class="line"><span class="keyword">while</span> (fgets(buffer, <span class="number">1024</span>, fp) != <span class="literal">NULL</span>) &#123; <span class="comment">// 逐行读取文件内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line">	<span class="comment">// 功能同 scanf，只是多了参数指出输入来源于哪个文件</span></span><br><span class="line">	<span class="comment">// 读到文件末返回 EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 1</span></span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">fscanf</span>(<span class="built_in">stdin</span>, <span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c); <span class="comment">// 同 scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span></span><br><span class="line"><span class="comment">// 【特别提醒】读字符串的时候，不要加 &amp; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 2</span></span><br><span class="line"><span class="comment">// 从文件中读取空格分隔的若干学生的成绩（整数），求平均分并输出（一位小数）</span></span><br><span class="line"><span class="type">int</span> score, sum = <span class="number">0</span>, cnt = <span class="number">0</span>;                <span class="comment">// 很多同学都会忘记初始化</span></span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;scores.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;score) != EOF) &#123;</span><br><span class="line">    sum += score;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;average: %.1f\n&quot;</span>, sum * <span class="number">1.0</span> / cnt); <span class="comment">// 整数运算结果还是整数，你还记得这个细节吗</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 从 fp 所指的文件中读取一个字符，调用时可写 char c = fgetc(fp);</span></span><br><span class="line">	<span class="comment">// 读到文件末返回 EOF</span></span><br><span class="line">	<span class="comment">// 上一期猪脚说解释了为什么很多理应用 char 的地方写成了 int，这是合理且安全的</span></span><br><span class="line">	<span class="comment">// 我们自己在写程序时，也可以写 int c = fgetc(fp); printf(&quot;%c&quot;, c);</span></span><br></pre></td></tr></table></figure></div>

<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>这里仅提供函数原型，使用与非文件 I&#x2F;O 版本无异，只是多传入一个文件指针而已。<strong>写文件时，应指定<code>fopen</code>打开模式为<code>&quot;w&quot;</code>。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 将字符串 s 写入 fp 所指的文件中</span></span><br><span class="line">	<span class="comment">// 不同于 puts，此函数不会自动换行</span></span><br><span class="line">	<span class="comment">// fputs(s, stdout); 等价于 printf(&quot;%s&quot;, s);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line">	<span class="comment">// 类比 printf，当 fp 为 stdout 时等价于 printf</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 类比 putchar，当 fp 为 stdout 时等价于 putchar</span></span><br></pre></td></tr></table></figure></div>

<h3 id="文件偏移量"><a href="#文件偏移量" class="headerlink" title="文件偏移量"></a>文件偏移量</h3><p>我们在读写文件时，很自然地会认为我们是不断向文件尾部读取或添加内容。假如读完一个文件，还想再读一遍，一种做法是先 close 再 open。那我们能不能像实际编辑文件那样在读完一部分内容后，跳到前面再读一遍，或者是在文件中间插入内容呢。<strong>正如同使用 word 时的那个不断闪烁的光标，当我们操作文件的时候，FILE 结构体也在维护一个文件偏移量，它指的是距离文件头的字符数（准确是是字节数），文件的读写，都是从当前偏移量开始往后进行的。</strong></p>
<p><strong>使用<code>fopen</code>打开文件时，文件偏移量为 0，即光标位于文件头。</strong>当我们不断读取内容，光标不断后移，则文件偏移量不断增大。<strong>当文件偏移量等于文件字节数（一般等于文件字符数 &#x2F; 文件大小）的时候，就读到了文件末尾。</strong></p>
<p>一个很显然的想法是，<strong>不同的文件读取方式，每次文件偏移量的增量也不同。</strong>例如，刚打开一个文件（假设其中的内容足够多），连续调用两次**<code>fgetc</code>，则每次偏移量加一<strong>；调用</strong><code>fgets</code><strong>，则偏移量从第一行的第三个字符</strong>跳到行尾<strong>；再次</strong><code>fgets</code>，则偏移量跨过第二行跳到第二行行尾<strong>；进行<code>fscanf</code>，假设格式串为<code>&quot;(%d,%d)%c%lf&quot;</code>，且第三行的数据类型符合要求，则文件偏移量跳过 1 个字节</strong>吞掉**<code>(</code>、跳过 4 个字节<strong>读取</strong><code>int</code>、跳过 1 个字节<strong>吞掉</strong><code>,</code>、跳过 4 个字节<strong>读取</strong><code>int</code>、跳过 1 个字节<strong>吞掉</strong><code>)</code>、跳过 1 个字节<strong>读取</strong><code>char</code>、最后跳过 8 个字节<strong>读取</strong><code>double</code>。</p>
<p>介绍文件偏移量有助于我们理解文件的写入和读取顺序，如果想要<strong>手动设置文件偏移量</strong>，实现更加复杂的文件操作，请自行学习<code>fseek</code>等函数。</p>
<h2 id="第二次作业补充练习"><a href="#第二次作业补充练习" class="headerlink" title="第二次作业补充练习"></a>第二次作业补充练习</h2><p>1、<a class="link"   href="https://www.luogu.com.cn/problem/P1104" >按照结构体某一成员变量进行排序。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>2、<a class="link"   href="https://www.luogu.com.cn/problem/P1786" >稍微有一点难度的结构体排序。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第三期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%B8%89%E6%9C%9F/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets3/IMG_0781.jpg"
                      alt="IMG_0781" style="zoom:40%;" 
                >

<h2 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h2><blockquote>
<p><strong>注意</strong></p>
<p>在此课程中，使用结构体的时候请确保源代码文件是<code>.c</code>后缀而非<code>.cpp</code>。C++ 中的结构体和 C 完全不同，或者说，C++ 里的<code>struct</code>不是结构体，而是<strong>类（class）</strong>。C++ 和 C 语法相近，但很多细节存在差异，甚至可能导致截然不同的编译错误和运行结果 —— 水很深，请谨慎！</p>
</blockquote>
<h3 id="声明（declaration）"><a href="#声明（declaration）" class="headerlink" title="声明（declaration）"></a>声明（declaration）</h3><p>当我们写下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>    i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">char</span>   str[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>的时候，我们声明了一种<strong>自定义的结构体类型</strong>。其中，</p>
<ul>
<li><code>struct</code>是结构体<strong>关键字（key word）</strong>，<code>struct mystruct</code>是<strong>类型（type）</strong>。<ul>
<li><code>struct</code>不是任何类型，<strong>仅仅只是</strong>一个关键字；</li>
<li><code>struct mystruct</code>是类型，是和<code>int</code> <code>double</code> <code>char</code>等并列的<strong>数据类型</strong>，并且是<strong>复合数据类型</strong>。</li>
</ul>
</li>
</ul>
<p>但是，上文的写法单纯是<strong>类型的声明</strong>—— 它指明了这一新类型<strong>应该长什么样</strong> —— 含有一个<code>int</code>成员、一个<code>double</code>成员和一个<code>char</code>数组成员。于是我们有了一些新名词：成员变量（member variable）、字段（field）、域（field）、属性（attribute），从某种意义说上它们是等价的。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>上述声明的自定义复合数据类型为<code>struct mystruct</code>。这种类型写起来比较复杂，所以可以为之起一个别名</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span> <span class="title">Type</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>此后，<strong>任何用到<code>struct mystruct</code>类型的地方，都可以用别名<code>Type</code>指代</strong>。此外，我们也可以另外为指向该结构体的<strong>指针类型</strong>起一个别名</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span> * <span class="title">Type_ptr</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>当然，在<strong>声明结构体的同时</strong>就可以为新类型起别名</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125; m_type, * m_type_ptr;</span><br></pre></td></tr></table></figure></div>

<p>我们注意到，上述代码片段中<code>struct</code>关键字后并没有结构体原本的名字，这种<strong>无名</strong>的结构体，要么需要在声明的同时为之起别名，以便在后续程序中使用这一类型；要么必须在声明后立即定义相关变量（详见下文）。</p>
<blockquote>
<p><strong>补充</strong></p>
<p>我们用到的很多头文件中都进行了大量别名的声明。</p>
<ul>
<li><p><code>FILE</code>类型其实是一个结构体，为了使之更加<strong>贴近英文语义</strong>，所以为之起了别名</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// much more...</span></span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>size_t</code>是用于描述<strong>字节数</strong>或“大小”“长度”的类型，如<code>sizeof</code>的返回值、数组大小等</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">size_t</span>; <span class="comment">// 无符号长整型，用 %lu 输出</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>部分字符串处理函数中，会使用<code>ssize_t</code>类型表示<strong>字符串的长度</strong></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> <span class="type">ssize_t</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>操作系统中，为<strong>进程编号（Process ID）</strong>类型起了别名</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">pid_t</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><del>部分同学为了书写简便，为<code>long long</code>起了别名</del></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll; <span class="comment">// 好吧我承认这么写没毛病😋</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</blockquote>
<h3 id="定义（definition）"><a href="#定义（definition）" class="headerlink" title="定义（definition）"></a>定义（definition）</h3><p>当我们写下<code>int a = 10;</code>的时候，<strong>定义</strong>了一个整型<strong>变量</strong>。我们有了自己的类型<code>struct mytype</code>，为之声明了别名<code>Type</code>，为其指针声明了别名<code>Type_ptr</code>，我们也可以定义此类型的变量和数组。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytype</span>  <span class="title">t1</span>, <span class="title">t2</span>;</span> <span class="comment">// 两个结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytype</span>* <span class="title">t3</span>, <span class="title">t4</span>;</span> <span class="comment">// t3 是结构体的指针，t4 是结构体变量</span></span><br><span class="line"></span><br><span class="line">Type  t5, t6; <span class="comment">// 两个结构体变量</span></span><br><span class="line">Type* t7, t8; <span class="comment">// t7 是结构体的指针，t8 是结构体变量</span></span><br><span class="line"></span><br><span class="line">Type_ptr p1, p2, p3; <span class="comment">// 三个都是结构体的指针</span></span><br></pre></td></tr></table></figure></div>

<p>当然我们可以在<strong>声明结构体的同时</strong>定义变量和数组</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; a1, a2, arr[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></div>

<p><strong>如果声明的同时用<code>typedef</code>起了别名，则不能在其后直接定义变量。</strong></p>
<p>前面提到的无名结构体，如果没有在声明的同时为之起别名，则只能在声明的同时定义变量和数组</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">&#125; v1, v2, v3[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></div>

<p>很显然，我们在后续的程序中只能访问<code>v1</code> <code>v2</code> <code>v3</code>，而不能再定义此类型的变量或数组了 —— 因为这个类型没有名字。</p>
<blockquote>
<p><strong>注意：请严格区分声明与定义！</strong></p>
</blockquote>
<h3 id="前向声明"><a href="#前向声明" class="headerlink" title="前向声明"></a>前向声明</h3><p>我们知道<strong>声明结构体的时候不能嵌套</strong>，如<code>struct A &#123; struct A a; &#125;;</code>，因为这会造成无穷的嵌套，导致报错。那么假设<strong>两个结构体相互引用对方，并且均采用了类型别名的形式</strong>，会不会出现问题呢？</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    type_B *pb;</span><br><span class="line">&#125; type_A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    type_A *pa;</span><br><span class="line">&#125; type_B;</span><br></pre></td></tr></table></figure></div>

<p>当编译器读到结构体 A 的声明时，它发现需要有一个类型<code>type_B</code>的指针变量，然而<code>type_B</code>声明在后方，编译器暂时不知道其存在。假如把 A 和 B 的声明顺序对调，同样存在这一问题。</p>
<p>解决方法是使用<strong>前向声明（forward declaration）</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">type_B</span>;</span></span><br><span class="line">    <span class="comment">// 告诉编译器，我现在有一个 struct B 类型，它的别名是 type_B</span></span><br><span class="line">	<span class="comment">// struct B 具体长什么样，你自己到后面去找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    type_B *pb;    <span class="comment">// 编译器读到这里，它已经知道有 type_B 这个类型了，所以编译通过</span></span><br><span class="line">&#125; type_A;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    type_A *pa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="一定要记得初始化😭😭😭"><a href="#一定要记得初始化😭😭😭" class="headerlink" title="一定要记得初始化😭😭😭"></a>一定要记得初始化😭😭😭</h2><p>「为什么我会输出乱码啊」「为什么会多输出几个字符啊」「为什么字符串长度和追加出错了啊」……</p>
<p><strong>请再次检查，你是否对每一个变量、数组都初始化了。</strong></p>
<p>我们讨论初始化，并不是说什么时候需要初始化、什么时候可以不初始化，而是说<strong>任何情况</strong>、<strong>不论全局还是局部</strong>，都必须初始化！</p>
<ul>
<li><p>在任何地方都<strong>绝不允许</strong>写<code>int i;</code>而<strong>必须</strong>写<code>int i = 0;</code></p>
</li>
<li><p>在任何地方都<strong>绝不允许</strong>写<code>char str[100];</code>而<strong>必须</strong>写<code>char str[100] = &#123;0&#125;;</code></p>
</li>
<li><p>设我们有结构体</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>  在任何地方都<strong>绝不允许</strong>只写<code>struct A test[100];</code>而<strong>必须</strong>写</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">test</span>[100];</span></span><br><span class="line"><span class="comment">/*****************************</span></span><br><span class="line"><span class="comment">  以下初始化内容必须写！不许说麻烦。</span></span><br><span class="line"><span class="comment">*****************************/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;         <span class="comment">// 结构体数组必须初始化，且用循环初始化</span></span><br><span class="line">    test[i].i = <span class="number">0</span>;</span><br><span class="line">    test[i].d = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;      <span class="comment">// 一维数组必须初始化，用循环初始化或用 memset</span></span><br><span class="line">        test[i].s[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;      <span class="comment">// 二维数组必须初始化，且用循环初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++) &#123;</span><br><span class="line">            test[i].arr[j][k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>另外关于<code>memset</code>的使用，我们只需要知道</p>
<ul>
<li><p><strong>仅能将所有元素初始化为 0</strong></p>
</li>
<li><p>仅有如下的基本使用方法</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="type">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> l_array[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(l_array));</span><br><span class="line"></span><br><span class="line"><span class="comment">// memset 其他值是会出错的，可以试试如下代码</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">1</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p><strong>补充</strong></p>
<p>DevC++ 默认使用 C89 标准，此时局部变量仅能定义在函数开头。而我们很多时候见到的<code>for(int i = 0; ...)</code>这种在后续代码中定义变量的形式，是从 C99 标准开始才支持的。解决方法如下</p>
<ul>
<li><p>Step1：打开工具菜单</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets3/3-1.jpg"
                      alt="3-1" style="zoom:50%;" 
                >
</li>
<li><p>Step2：在下拉菜单中选择“编译选项”</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets3/3-2.PNG"
                      alt="3-2" style="zoom:20%;" 
                >
</li>
<li><p>Step3：勾选“编译时加入以下命令”，加入<code>-std=c99 -Wall</code>，点击“确定”。这两个选项，前者指定了使用 C99 标准，后者能帮我们输出更多警告信息。</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets3/3-3.PNG"
                      alt="3-3" style="zoom:25%;" 
                ></li>
</ul>
</blockquote>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a><code>sizeof</code></h2><p>上文提到，<code>sizeof</code>返回对象的字节数大小，类型为<code>size_t</code>，可用<code>%lu</code>输出，用<code>%d</code>一般没有问题但是会给警告。</p>
<ul>
<li><h3 id="sizeof-基本类型或其变量"><a href="#sizeof-基本类型或其变量" class="headerlink" title="sizeof 基本类型或其变量"></a><code>sizeof</code> 基本类型或其变量</h3>  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>);   <span class="comment">// int 的大小一般都是 4 个字节</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;    <span class="comment">// 如果想要使用与机器类型无关的整型变量，&lt;stdint.h&gt; 中有很多可供选择</span></span><br><span class="line"><span class="keyword">sizeof</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">char</span>*);    <span class="comment">// 32 位机器的指针大小为 4 字节，64 位机器则为 8 字节</span></span><br><span class="line"><span class="type">double</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(p);        <span class="comment">// 指针大小固定，与所指的类型无关</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><h3 id="sizeof-结构体类型或其变量"><a href="#sizeof-结构体类型或其变量" class="headerlink" title="sizeof 结构体类型或其变量"></a><code>sizeof</code> 结构体类型或其变量</h3>  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> test);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">t1</span>;</span></span><br><span class="line"><span class="keyword">sizeof</span>(t1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，struct 的 size 并不一定等于其各个成员的 size 之和</span></span><br><span class="line"><span class="comment">// 具体原因可以自行百度 “结构体字节对齐”，此处不要求掌握</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><h3 id="sizeof-数组名"><a href="#sizeof-数组名" class="headerlink" title="sizeof 数组名"></a><code>sizeof</code> 数组名</h3>  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 定义整型数组</span></span><br><span class="line"><span class="type">int</span> *p = arr;       <span class="comment">// 定义指针管理数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(arr);    <span class="comment">// sizeof(数组名)，返回数组总字节数，即 100 * sizeof(int)</span></span><br><span class="line"><span class="keyword">sizeof</span>(p);      <span class="comment">// sizeof(指向数组的指针)，返回指针本身大小，与机器位数有关</span></span><br><span class="line"><span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// sizeof(数组元素)，返回单个元素的大小，即 sizeof(int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *q    = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(str);          <span class="comment">// 返回 6</span></span><br><span class="line"><span class="keyword">sizeof</span>(q);            <span class="comment">// 返回 4(32位机器) 或 8(64位机器)</span></span><br><span class="line"><span class="built_in">strlen</span>(str);          <span class="comment">// 返回 5</span></span><br><span class="line"><span class="built_in">strlen</span>(q);            <span class="comment">// 返回 5</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><blockquote>
<p>在一些较复杂的项目中，除了声明必要的结构体之外，往往需要借助多维数组、并在函数原型中声明多维数组，特别是二维数组。使用二维数组时有很多易忽略的点，我们希望在接下来的内容中帮助大家更深地了解二维数组的本质，并尽量减少编程时 bug 的产生。</p>
</blockquote>
<h3 id="二维数组的存储"><a href="#二维数组的存储" class="headerlink" title="二维数组的存储"></a>二维数组的存储</h3><p><strong>二维数组，也可以看成一个一维数组，这个一维数组中的每个元素都是一个一维数组。</strong></p>
<p>因此，若将二维数组的每一行当做一个存储一维数组的元素，所有行汇集成一个一维数组，每个一维数组中各元素是连续存储的，那么就很容易理解：二维数组中的各元素在内存中是<strong>按照行优先的原则，进行连续存储。</strong></p>
<p>例如，我们定义数组<code>a[2][6]</code>，那么其在内存中从某一地址开始，存储情况如下图：</p>
<p>![截屏2023-03-10 13.31.04](&#x2F;images&#x2F;assets3&#x2F;截屏2023-03-10 13.31.04.png)</p>
<p>那么该数组中某个元素<code>a[i][j]</code>的地址<code>&amp;a[i][j]</code>可以通过如下方式求得：<code>首地址 + 单个元素长度 * (总列数 * i + j)</code>。</p>
<p>由此可知，若想知道该二维数组中某一元素的地址，就必须知道该数组的数据类型和列数，这样才能实现对二维数组中某一个元素的精确访问，<strong>这也是为什么我们在声明二维数组以及把一个二维数组当作形参传递时，必须指定列数，否则就会报错。</strong></p>
<p>我们来看如下几行代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a[][], <span class="type">int</span> b)</span>;    <span class="comment">// error：没有指定列数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a1[][], <span class="type">int</span> b)</span>;   <span class="comment">// error：没有指定列数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a2[<span class="number">2</span>][], <span class="type">int</span> b)</span>;  <span class="comment">// error：没有指定列数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a3[<span class="number">3</span>][<span class="number">4</span>], <span class="type">int</span> b)</span>; <span class="comment">// right</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a4[][<span class="number">5</span>], <span class="type">int</span> b)</span>;  <span class="comment">// right</span></span><br></pre></td></tr></table></figure></div>

<h3 id="二维数组的指针访问"><a href="#二维数组的指针访问" class="headerlink" title="二维数组的指针访问"></a>二维数组的指针访问</h3><blockquote>
<p>在此，我们推荐两种访问二维数组的方法，但不代表访问它的方法仅有如下两种。</p>
</blockquote>
<h4 id="指向元素的指针"><a href="#指向元素的指针" class="headerlink" title="指向元素的指针"></a>指向元素的指针</h4><p>这种方法最简单直接，现有如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">6</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure></div>

<p>在此种定义下，访问数组<code>a</code>中的每一个元素只需要将<code>p</code>指针依次往后推，利用 4.1 中求某元素地址的方式即可实现精确访问。在该例子中，我们便知道了<code>&amp;a[i][j] == p + sizeof(int) * (6 * i + j)</code>。</p>
<h4 id="列指针"><a href="#列指针" class="headerlink" title="列指针"></a>列指针</h4><p>这种方式通过定义指针指向二维数组的<strong>某一行的第一列</strong>，再在此基础上访问该行的某个元素，现有如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">6</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> *p[<span class="number">2</span>] = &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;; <span class="comment">// 当然，你也可以使用循环来为这个指针数组赋值</span></span><br></pre></td></tr></table></figure></div>

<p>由此，指针数组<code>p</code>中第一个元素为二维数组<code>a</code>中第一行第一个元素的地址（意即第一行的首地址），第二个元素为二维数组<code>a</code>中第二行第一个元素的地址（意即第二行的首地址）。</p>
<p>在该例子中，我们便知道了<code>&amp;a[0][j] == p[0] + sizeof(int) * j</code> 以及<code>&amp;a[1][j] == p[1] + sizeof(int) * j</code>。</p>
<h3 id="二维数组的形参传递"><a href="#二维数组的形参传递" class="headerlink" title="二维数组的形参传递"></a>二维数组的形参传递</h3><blockquote>
<p>我们在 4.1 中已经提到，当我们把一个二维数组作为形参传递进入另一个函数里（例如有些同学做第二次作业的五子棋危险判断）时，<strong>一定要指定列数</strong>。在此我们也推荐两种写法。</p>
</blockquote>
<h4 id="数组法"><a href="#数组法" class="headerlink" title="数组法"></a>数组法</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a[][<span class="number">6</span>], <span class="type">int</span> row)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    print_two_dim(a,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>请注意：以下传递方式无效，不能将二维数组的真实行数传入函数中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a[<span class="number">2</span>][<span class="number">6</span>])</span>;</span><br></pre></td></tr></table></figure></div>

<p>原因是：如同一维数组的形参传递一样，<strong>传入的数组被转化为指针，函数内部无法获取该数组大小。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下两种传递方式等效</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_one_dim1</span><span class="params">(<span class="type">int</span> num[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_one_dim2</span><span class="params">(<span class="type">int</span> num[<span class="number">20</span>])</span>; <span class="comment">// 20在这里是无效的</span></span><br></pre></td></tr></table></figure></div>

<h4 id="数组指针法"><a href="#数组指针法" class="headerlink" title="数组指针法"></a>数组指针法</h4><blockquote>
<p>数组指针指向二维数组，有些教材称这种指针为<strong>行指针</strong>，顾名思义就是操纵一行的指针。</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">6</span>], <span class="type">int</span> row)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数组名为 a，表示首元素的地址</span></span><br><span class="line">    <span class="comment">// 二维数组的首元素是二维数组的第一行</span></span><br><span class="line">    <span class="comment">// 所以传递进函数的 a ，相当于第一行的地址，是一维数组的地址</span></span><br><span class="line">    print_two_dim(a,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述代码中，我们用数组指针来接收，也必须指定有 6 列，<strong>这是为了告诉内存，第二行从哪儿开始存放。</strong></p>
<p>因此，形参中的<code>(*a)[6]</code>中，**<code>a</code>指向二维数组第一行的地址。**<code>*a</code>就是二维数组第一个元素的地址，<code>**a</code>才能找到第一个元素的具体值，为 1。</p>
<h3 id="char型二维数组"><a href="#char型二维数组" class="headerlink" title="char型二维数组"></a><code>char</code>型二维数组</h3><p>我们在 4.1 中提到，二维数组的存储方式为按行优先，连续存储。另一层意思就是说，二维数组里每一行所代表的一维数组是连续的，并非毫无关联。如果你并没有领略到这一层意思，那么请看如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> test[<span class="number">2</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        test[<span class="number">0</span>][i] = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        test[<span class="number">1</span>][i] = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">    test[<span class="number">1</span>][i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, test[<span class="number">0</span>]);</span><br><span class="line">    test[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, test[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>代码的运行结果：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">abcdefghijklmnopqrstuvwxyzabcdefg</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure></div>

<p>诶！按照惯性思维，你会发现：我第一次打印时明明只想让他打印出二维数组第一行的值，<strong>为啥它把第二行的值一起打印出来了呢？</strong></p>
<p>相信大家一定知道，<code>printf(&quot;%s&quot;,a)</code>这样一段代码，其本质上是从字符串数组<code>a</code>的首地址开始打印，知道遇到字符串终止字符（也就是<code>&#39;\0&#39;</code>）停止。</p>
<p>那么再回到上述代码，由于二维数组的顺序存储特性，<code>test[1][0]</code>元素是紧跟在<code>test[0][25]</code>元素之后的，也就是说当输出<code>test[0][25]</code>元素时，系统发现该元素之后并不是<code>&#39;\0&#39;</code>，而是一个有着具体值的字符，于是就会接着输出，直到遇到<code>&#39;\0&#39;</code>为止。于是，我们通过让<code>test[1][0]=&#39;\0&#39;</code>，成功地让输出停留在<code>test[0][25]</code>的位置上，实现了只输出第一行的目的。</p>
<p>这也告诉我们，当我们使用<code>char</code>类型二维数组时，首先需要初始化，<strong>且尽量不要让该数组的列数小到恰好等于我们想让它存储的数据个数</strong>，否则就会像上述例子一样，每一行末尾没有<code>&#39;\0&#39;</code>，在进行后续的按行操作时出现 bug。</p>
<p><em>Author: diandian, Riccardo(Version Grey)</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第五期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%BA%94%E6%9C%9F/</url>
    <content><![CDATA[<blockquote>
<p>在这一部分中，我们会针对同学们问的比较多的题目（或者易错点较多的题目），给出若干的代码。大家可以参考题解中的代码，<strong>学习一下代码规范【好好看看哪里要空格哪里要空行！！！】</strong>，对比一下自己的代码与我们给出的参考代码，孰优孰劣,亦或者代码中的某些段落可以打包成一个固定模版，在后续作业、考试中使用。</p>
</blockquote>
<p><strong>如果针对这些题，同学们有更好更简洁的方法，欢迎来找助教讨论分享，助教请喝奶茶。</strong></p>
<h2 id="表达式计算（支持空格，连乘，连除）"><a href="#表达式计算（支持空格，连乘，连除）" class="headerlink" title="表达式计算（支持空格，连乘，连除）"></a>表达式计算（支持空格，连乘，连除）</h2><p>法一：先计算乘除，再加减（先计算表达式中所有的乘除，再从左到右进行加减）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, b[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, op[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len, i,j = <span class="number">0</span>, k = <span class="number">0</span>, cnt;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans, num[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">    	<span class="comment">// 虽然数字都是int型，但int型的数字相加和相乘可能超int范围</span></span><br><span class="line">    </span><br><span class="line">    gets(a);</span><br><span class="line">    len = <span class="built_in">strlen</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            b[k++] = a[i];</span><br><span class="line">    &#125; <span class="comment">// 将清除空格后的字符串保存在数组b中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; b[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; b[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            num[j] = <span class="number">10</span> * num[j] + b[i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 非常好用的从一串字符中读取整数数字的方法</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            op[j] = b[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 将数字与运算符分别存进两个数组，一个数字对应一个运算符，下标一一对应</span></span><br><span class="line">    </span><br><span class="line">    cnt = j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            num[i] = num[i] * num[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                op[j] = op[j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                num[j] = num[j + <span class="number">1</span>];</span><br><span class="line">            i--;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若遇到*，则计算当前两个数的乘积，保存到*前的数，后面的数与运算符往前移。</span></span><br><span class="line">        <span class="comment">// 由于前移了，则下次进入循环时仍然该从当前位开始，为了抵消i++的影响，执行</span></span><br><span class="line">        <span class="comment">// 一次i--，同时总数cnt--</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            num[i] = num[i] / num[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                op[j] = op[j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                num[j] = num[j + <span class="number">1</span>];</span><br><span class="line">            i--;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ans = num[<span class="number">0</span>]; <span class="comment">// 此时表达式中的乘除已全部处理完毕，接下来从左到右执行加减运算即可。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            ans += num[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            ans -= num[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>法二：后悔法（读入什么就运算什么，读到乘除往前反悔）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, x[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, t[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, a[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, j = <span class="number">0</span>, k = <span class="number">0</span>, k1 = <span class="number">1</span>, len, len1, ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    gets(s);</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            x[k++] = s[i];</span><br><span class="line">    &#125; <span class="comment">// 将清除空格后的字符串保存在数组x中</span></span><br><span class="line">    </span><br><span class="line">    len1 = <span class="built_in">strlen</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len1 - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; x[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            a[j] = <span class="number">10</span> * a[j] + x[i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 非常好用的从一串字符中读取整数数字的方法</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            t[j] = x[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="comment">// 将数字与运算符分别存进两个数组，一个数字对应一个运算符，下标一一对应</span></span><br><span class="line">    &#125;     <span class="comment">// 不需要考虑末尾的“=”，因此循环结束条件为i&lt;len1-1</span></span><br><span class="line">    </span><br><span class="line">    ans += a[<span class="number">0</span>]; <span class="comment">// 记录第一个数字为当前运算结果</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = ans - a[i] + a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                a[i + <span class="number">1</span>] = a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="comment">// 特判，第一个符号为乘号</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                    ans = ans - a[i] + a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 1+2*3，先算1+2得到3，读到*后，往前反悔，</span></span><br><span class="line">                    <span class="comment">// 于是当前预算结果为3-2+2*3，后续思路相同</span></span><br><span class="line">                    a[i + <span class="number">1</span>] = a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                    <span class="comment">// 对于连乘，1+2*3*4，运算到1+2*3为7时，再读到乘号，需要用变量k1记录</span></span><br><span class="line">                    <span class="comment">// 连续乘or除多少次，反悔时才能找到相应位置，于是现在运算结果为7-6+6*4，</span></span><br><span class="line">                    <span class="comment">// 后续思路相同</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    ans = ans + a[i] - a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                    a[i + <span class="number">1</span>] = a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    ans *= a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    ans *= a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = ans - a[i] + a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                a[i + <span class="number">1</span>] = a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i-k1] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                    ans = ans - a[i] + a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                    a[i + <span class="number">1</span>] = a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    ans = ans + a[i] - a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                    a[i + <span class="number">1</span>] = a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    ans /= a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    ans /= a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            ans += a[i + <span class="number">1</span>];</span><br><span class="line">            k1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            ans -= a[i + <span class="number">1</span>];</span><br><span class="line">            k1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>法三：使用<code>scanf</code>函数可以自动消除空格，同时每次将一个数字和一个运算符成对读入，直接进行运算。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">0</span>, num2, num3;</span><br><span class="line">    <span class="type">char</span> op1 = <span class="string">&#x27;+&#x27;</span>, op2, op3; <span class="comment">// 这样初始化是为了输入第一个数num2时，可以实现0+num2的效果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>,&amp;num2, &amp;op2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (op2 == <span class="string">&#x27;*&#x27;</span> || op2 == <span class="string">&#x27;/&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">// 当输出乘除时，继续往后输入，直到退出连乘/除为止</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>, &amp;num3, &amp;op3);</span><br><span class="line">            <span class="keyword">if</span> (op2 == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                num2 = num2 * num3;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2 = num2 / num3;</span><br><span class="line">            op2 = op3; <span class="comment">// 更新op2为当前输入的符号</span></span><br><span class="line">        &#125; <span class="comment">// 此时已经退出连乘/除模式，往后直接执行加减操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (op1 == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            num1 = num1 + num2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op1 == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            num1 = num1 - num2;</span><br><span class="line">        </span><br><span class="line">        op1 = op2; <span class="comment">// 更新op1为当前当前输入的符号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (op1 == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num1);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="超长正整数的减法"><a href="#超长正整数的减法" class="headerlink" title="超长正整数的减法"></a>超长正整数的减法</h2><p>这道题的易错点在于：</p>
<p>1、连续借位相减（例如执行 10000 - 1 的运算）；</p>
<p>2、有些同学使用长度和字典序关系判断两数大小，这是正确且高效的方法，但请注意<code>strcmp()</code>函数的返回值；</p>
<p>3、注意<code>0</code>和<code>&#39;0&#39;</code>的区别，对其他数字也是同理。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str_a[M] = &#123;<span class="number">0</span>&#125;, str_b[M] =&#123; <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num_a[M] = &#123;<span class="number">0</span>&#125;, num_b[M] = &#123;<span class="number">0</span>&#125;, num_c[M] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len_a, len_b;</span><br><span class="line">    <span class="type">int</span> i, j, k, n, f = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    gets(str_a);</span><br><span class="line">    gets(str_b);</span><br><span class="line">    len_a = <span class="built_in">strlen</span>(str_a);</span><br><span class="line">    len_b = <span class="built_in">strlen</span>(str_b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (len_a &lt; len_b)</span><br><span class="line">        k = len_b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        k = len_a; <span class="comment">// 让k为两数组的最大长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (len_a &gt; len_b)</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len_a == len_b)</span><br><span class="line">        n = <span class="built_in">strcmp</span>(str_a, str_b) &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n = <span class="number">-1</span>; <span class="comment">//给n赋值，在之后判断需不需要打印负号</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = len_a - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--, j++)</span><br><span class="line">        num_a[j] = str_a[i] - <span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">    <span class="comment">// 很经典的将字符&#x27;0&#x27;转换成数字0的方法，且同时实现数组反序存储</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = len_b - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--, j++)</span><br><span class="line">        num_b[j] = str_b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123; <span class="comment">// 判断n是为了让程序永远执行大数减小数</span></span><br><span class="line">            <span class="keyword">if</span> (num_a[i] - num_b[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                num_c[i] = num_a[i] - num_b[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                num_c[i] = num_a[i] + <span class="number">10</span> - num_b[i];</span><br><span class="line">                num_a[i+<span class="number">1</span>]--;</span><br><span class="line">            &#125; <span class="comment">// 借位的判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (num_b[i] - num_a[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                num_c[i] = num_b[i] - num_a[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                num_c[i] = num_b[i] + <span class="number">10</span> - num_a[i];</span><br><span class="line">                num_b[i + <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num_c[i])</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 只要num_c数组中不是0，则把f赋值为1，目的只是为了消除</span></span><br><span class="line">            <span class="comment">// 打印出的数组中的前导0，所以不用重新赋值，不用考虑“新的开始”</span></span><br><span class="line">        <span class="keyword">if</span> (f || i == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num_c[i]); </span><br><span class="line">        <span class="comment">// 如果结果本身就是0，需要输出一个0，所以再加一个i==0的条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="全排列数的生成"><a href="#全排列数的生成" class="headerlink" title="全排列数的生成"></a>全排列数的生成</h2><p>这道题可以用递归或非递归实现，具体方法我们在上机的时候已经统一讲过了，这里不作赘述，直接上码！</p>
<p>法一：递归与回溯法</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tape</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *str1, <span class="type">int</span> *str2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = l; i &lt;= r; i++)</span><br><span class="line">        str1[i] = str2[i];</span><br><span class="line">&#125; <span class="comment">// 注意回溯时，一定不是简单的交换两个位置的数字，而是把这两个位置中的整段数组都进行回溯</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125; <span class="comment">// 自定义交换函数怎么写，还记得吗？</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">comb</span><span class="params">(<span class="type">int</span> *str, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            swap(&amp;(str[l]), &amp;(str[i]));</span><br><span class="line">            tape(l, r, a, str);</span><br><span class="line">            comb(str, l+<span class="number">1</span>, r);</span><br><span class="line">            tape(l, r, str, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, x, a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    comb(a, <span class="number">0</span>, x<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>法二：非递归法，从右往左找到第一对递增数，以该对数的第一个数为交换对象，再从右往左找第一个比该对象大的数，相交换，再把该位置后的数组反序。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">11</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_rev</span><span class="params">(<span class="type">int</span> s[], <span class="type">int</span> hi, <span class="type">int</span> low)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> ( ; hi &gt; low; low++, hi--) &#123;</span><br><span class="line">    temp = s[low];</span><br><span class="line">    s[low] = s[hi];</span><br><span class="line">    s[hi] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//该自定义函数可实现把数组反序，可以直接作为模版使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, temp, flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 从右往左找一对递增的数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果没找到，说明所有全排列的结果已经输出完毕</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (j = n; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[i]) &#123;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        str_rev(a, n, i + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="字符串替换（新）"><a href="#字符串替换（新）" class="headerlink" title="字符串替换（新）"></a>字符串替换（新）</h2><p>这道题的注意事项有：</p>
<p>1、关于文件的输入输出，文件名写对，<code>fgets()</code>函数的参数顺序写对；</p>
<p>2、不可以把输入文件里的所有字母都变成小写后再判断，因为不符合替换条件的字母需要原样输出；</p>
<p>3、如果要使用<code>strcat()</code>和<code>strcpy()</code>等函数完成此题，一定要判断好起始位置。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">502</span>] = &#123;<span class="number">0</span>&#125;, b[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, str[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, flag, len;</span><br><span class="line">    </span><br><span class="line">    FILE *in = fopen(<span class="string">&quot;filein.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE *out = fopen(<span class="string">&quot;fileout.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(in)) != EOF)</span><br><span class="line">        str[i++] = c;<span class="comment">// 将文件中所有字符统一存进数组</span></span><br><span class="line">    str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    len = (<span class="type">int</span>)<span class="built_in">strlen</span>(str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        flag = <span class="number">1</span>; <span class="comment">// “新的开始”，每次都让flag置为1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">tolower</span>(str[i]) != <span class="built_in">tolower</span>(a[<span class="number">0</span>])) </span><br><span class="line">            <span class="comment">// 判断大小写是否契合，直接借用此函数即可，若参数为大写字母，则其返回值为小写字母</span></span><br><span class="line">            fputc(str[i], out);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; a[j] != <span class="string">&#x27;\0&#x27;</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">tolower</span>(str[i+j]) != <span class="built_in">tolower</span>(a[j])) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="comment">// 一旦出现不匹配的位置，立即让flag为0并退出上一层循环（即for循环）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(b, out);</span><br><span class="line">                i = i + (<span class="type">int</span>)<span class="built_in">strlen</span>(a) - <span class="number">1</span>; <span class="comment">// 减1是为了抵消下一次进循环的i++</span></span><br><span class="line">            &#125; <span class="comment">// 如果与in数组匹配，则直接把out数组输出到文件里</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fputc(str[i], out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="加密文件"><a href="#加密文件" class="headerlink" title="加密文件"></a>加密文件</h2><p>此题注意事项包括但不限于：</p>
<p>1、很多同学在判断字符是否出现过时，喜欢使用循环遍历的方法，这样做固然没问题，但在数据规模较大时比较耗费时间，特别是在大作业的时候，大家感触会更深。所以可以使用<code>used</code>数组（类似于哈希表思想）进行判断，在大作业的时候大家也可以感受到不同算法所带来的效率差别；</p>
<p>2、使用数组下标的时候要统一，不要一会儿是 97-122，一会儿是 0-25，一会儿是 ‘A’-‘Z’，这样会显得很混乱，容易出错；</p>
<p>3、大家有时喜欢卡着真实的元素个数去定义数组的大小，其实完全没必要，建议开大一些（至少开大个一倍左右吧），这样能有效避免数组越界。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, key[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;, str[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, pst = <span class="number">0</span>, ch, used[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    FILE *in, *out;</span><br><span class="line">    </span><br><span class="line">    in = fopen(<span class="string">&quot;encrypt.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    out = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[str[i] - <span class="string">&#x27;a&#x27;</span>]) &#123; <span class="comment">// 如果出现过，则不写入key数组中</span></span><br><span class="line">            key[pst++] = str[i];</span><br><span class="line">            used[str[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>; <span class="comment">// 如果该字母以出现过，则对应used数组位置赋为1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="string">&#x27;z&#x27;</span>; i &gt;= <span class="string">&#x27;a&#x27;</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[i - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            key[pst++] = i;</span><br><span class="line">    &#125; <span class="comment">// 倒序加入未出现过的字母形成最终密钥</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(in)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(ch))</span><br><span class="line">            ch = key[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        fputc(ch, out);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="小型图书管理系统"><a href="#小型图书管理系统" class="headerlink" title="小型图书管理系统"></a>小型图书管理系统</h2><p>本题一种简单暴力的做法是，每进行一次操作，都将所有图书重新排序。另有以下注意事项：</p>
<p>1、在维护图书信息时，利用变量<code>cnt</code>保存图书总数，并且只针对下标小于<code>cnt</code>的元素进行操作；</p>
<p>2、一些同学使用记事本查看输出结果时，发现输出的信息不能对齐，这是由于记事本中默认字体中的字符宽度是不相等的，可以切换记事本字体，例如<code>Consolas</code>；</p>
<p>3、有些同学在执行清除操作时，喜欢直接<code>memset</code>，但全是<code>&#39;\0&#39;</code>的字符串也会进入<code>qsort</code>排序中，且<code>&#39;\0&#39;</code>的字典序是最小的，因此永远会被排在前面，如果在输出时不加以判断，则会在文件最开始输出很多空内容。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">books</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">51</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">21</span>];</span><br><span class="line">    <span class="type">char</span> press[<span class="number">31</span>];</span><br><span class="line">    <span class="type">char</span> date[<span class="number">11</span>];</span><br><span class="line">&#125;book[<span class="number">501</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p, <span class="type">const</span> <span class="type">void</span> *q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(((<span class="keyword">struct</span> books*)p)-&gt;name, ((<span class="keyword">struct</span> books*)q)-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, i  =<span class="number">0</span>, op;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    FILE *in = fopen(<span class="string">&quot;books.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE *out = fopen(<span class="string">&quot;ordered.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(in, <span class="string">&quot;%s %s %s %s&quot;</span>, book[cnt].name, book[cnt].author, </span><br><span class="line">                 book[cnt].press, book[cnt].date) != EOF) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    qsort(book, cnt, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> books), cmp); <span class="comment">// 输入完就立即进行排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s %s %s %s&quot;</span>, book[cnt].name, book[cnt].author, </span><br><span class="line">                      book[cnt].press, book[cnt].date);</span><br><span class="line">                cnt++;</span><br><span class="line">                qsort(book, cnt, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> books), cmp);</span><br><span class="line">            <span class="comment">// 插入后进行排序，如果没有此步骤，则后续查找时，可能导致输出的图书顺序有误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, temp);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strstr</span>(book[i].name, temp) != <span class="literal">NULL</span>) <span class="comment">// 使用strstr函数直接进行查找</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%-50s%-20s%-30s%-10s\n&quot;</span>, book[i].name, </span><br><span class="line">                           book[i].author, book[i].press, book[i].date);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, temp);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strstr</span>(book[i].name, temp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                        book[j] = book[j + <span class="number">1</span>]; <span class="comment">// 将后续图书全部前移，即可实现删除功能</span></span><br><span class="line">                    i--; <span class="comment">// 因为前移，需抵消下次进循环的i++影响</span></span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    qsort(book, cnt, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> books), cmp); <span class="comment">// 最后再排一次序，以防万一</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(out, <span class="string">&quot;%-50s%-20s%-30s%-10s\n&quot;</span>, book[i].name, </span><br><span class="line">                book[i].author, book[i].press, book[i].date); <span class="comment">// 对齐方式应该如此写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="面向对象的数据结构-——-数组篇"><a href="#面向对象的数据结构-——-数组篇" class="headerlink" title="面向对象的数据结构 —— 数组篇"></a>面向对象的数据结构 —— 数组篇</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><blockquote>
<p>同学们在解决实际问题时，往往会在<strong>问题理解</strong>和<strong>编程实现</strong>两方面遇到困难。我们以第三次作业第二题“空闲空间分配”为例。</p>
<p><strong>题意理解的问题形如</strong></p>
<ul>
<li>查找目标的规则是什么，我要如何判断</li>
<li>如果没找到，我要怎么标记</li>
<li>如果空间一点不剩，我需不需要特判</li>
</ul>
<p><strong>编程实现的问题形如</strong></p>
<ul>
<li>新的节点如何申请</li>
<li>删除节点怎么写，哪些指针要修改</li>
<li>什么是循环链表，怎么遍历</li>
</ul>
<p>事实上，这两大问题对应我们程序中的两大部分</p>
<ul>
<li>主函数<code>main</code>的结构，如各种循环和分支的嵌套，这是我们解决问题的逻辑</li>
<li>每个循环或分支内的具体语句，如一次赋值、一次拷贝、一次遍历等</li>
</ul>
<p>这两大部分，也就对应两类常见 bug</p>
<ul>
<li>漏了一种<code>if</code>的情况，忘记把<code>flag</code>重新置为 0 等<strong>逻辑问题</strong></li>
<li>访问了空指针，下标数错，忘加 ‘\0’ 等<strong>基本操作问题</strong></li>
</ul>
<p>事实上，如果把所有代码都写在<code>main</code>里，我们很难分清也很难定位具体的 bug。一种做法是<strong>封装一些函数</strong>，这种做法简化了代码，增强了代码的<strong>可复用性</strong>，但不妙之处在于，我们每做一道题，就要把这些内容重新写一遍，因为每道题用到的数据类型是不同的 —— <strong>这道题的<code>struct</code>里的数据项只有一个<code>int</code>，而下一道题变成了一个<code>double</code>和一个<code>char[20]</code>，我们就需要把所有的函数都修改一遍</strong>。</p>
<p>所以，单纯地封装<code>insert_node</code> <code>delete_node</code>等函数，仍然不是最理想的做法。</p>
</blockquote>
<h3 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h3><p>今天我们仅讨论线性表中的数组，为了便于说明，我们仅以<code>int</code>型的数组为例。事实上，只要稍加改进，我们就可以写出适配任何数据类型（包括结构体）的数组。</p>
<p>可是，数组有什么好写的呢？我们写下<code>int arr[10] = &#123;0&#125;;</code>，不就定义了一个数组吗？我们可以通过下标访问、也可以通过指针访问，我们可以读取内容、也可以赋值。然而，正是因为我们频繁地在代码中写下<code>printf(&quot;%d\n&quot;, arr[index]);</code>等<strong>直接操作数组</strong>的代码，我们才会犯下下标越界等导致程序崩溃的错误。<strong>如果我们在程序中加入很多条件判断，保证每一次操作的合法性，又会徒增代码量，和我们程序的运行逻辑相混淆。</strong></p>
<p>事实上，直接定义的数组只是一个存放数据的“变量”。<strong>如果将存放数据的数据结构，其相关属性，以及在数据结构上的操作封装，我们就得到了一个对象。</strong>以今天介绍的数组为例，一个<strong>“数组对象”</strong>应当包括如下三个方面</p>
<ul>
<li><strong>存储数据的数据结构</strong>，即数组本身（为了实现<strong>可变长数组</strong>，我们用一个指针管理数组并用<code>malloc</code>分配空间，而非直接写一个定长数组）</li>
<li><strong>属性</strong>，如当前数组的最大容量、当前数组的元素个数</li>
<li><strong>一系列函数</strong>，提供初始化、插入、销毁的功能</li>
</ul>
<p>为了实现上述目标，我们首先定义自己的<strong>数组类型</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_SIZE 10</span></span><br><span class="line">	<span class="comment">// 这里定义了一个宏，设置数组的初始容量。</span></span><br><span class="line">	<span class="comment">// 后续初始化数组时，如果没有指定容量，则先开辟 10 个 int 的大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">array</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *head;		<span class="comment">// 数组首地址</span></span><br><span class="line">    <span class="type">size_t</span> size;	<span class="comment">// 数组的最大容量</span></span><br><span class="line">    <span class="type">size_t</span> cur;		<span class="comment">// current，当前数组的元素个数</span></span><br><span class="line">&#125; <span class="type">array_t</span>;			</span><br><span class="line">    <span class="comment">// ‘_t’结尾是 C 的经典代码风格，表示这是 typedef 的一种新类型，即我们的“数组类型”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以后当我们写下</span></span><br><span class="line"><span class="type">array_t</span> arr1, arr2;</span><br><span class="line"><span class="comment">// 等代码时，就可以说，我们现在拥有了两个数组对象，分别叫 arr1 和 arr2</span></span><br></pre></td></tr></table></figure></div>

<p>现在，我们有了自己的数组类型，也可以定义自己的<strong>数组对象</strong>。当然，<code>arr1[1]</code>等原有的操作将不被允许了，所有的操作都将通过函数进行。在每一个函数中，我们只需要将数组对象 —— 实际上是这个对象的地址 —— 传入函数，就可以对某一个具体的数组对象进行操作。</p>
<h3 id="初始化与销毁"><a href="#初始化与销毁" class="headerlink" title="初始化与销毁"></a>初始化与销毁</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">array_t</span> arr;            <span class="comment">// 定义了一个数组对象</span></span><br><span class="line">    array_init(&amp;arr, <span class="number">100</span>);  <span class="comment">// 初始化数组对象，开辟 100 个 int 的容量</span></span><br><span class="line">    array_destroy(&amp;arr);    <span class="comment">// 销毁数组对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了实现这样简洁的代码，我们需要自己设计一系列函数</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_init</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化数组</span></span><br><span class="line"><span class="comment">    	参数</span></span><br><span class="line"><span class="comment">       		`arr`  array_t 的指针，即 struct array 的指针，代表数组对象</span></span><br><span class="line"><span class="comment">       		`size` 数组的起始容量，如果小于等于 0，则默认开辟 INIT_SIZE 个</span></span><br><span class="line"><span class="comment">       	返回值</span></span><br><span class="line"><span class="comment">       		如果初始化成功返回 0，否则返回 -1</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果没有传入数组对象，则失败</span></span><br><span class="line">    <span class="type">int</span> real_size = (size &gt; <span class="number">0</span>) ? size : INIT_SIZE; </span><br><span class="line">                                 <span class="comment">// 如果参数 size 非正，则使用预先定义的 size</span></span><br><span class="line">    <span class="keyword">if</span> ((arr-&gt;head = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * real_size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果 malloc 失败，则函数直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr-&gt;size = real_size; <span class="comment">// 更新数组的最大容量</span></span><br><span class="line">        arr-&gt;cur = <span class="number">0</span>;          <span class="comment">// 设置当前元素个数为 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 成功则返回 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_destroy</span><span class="params">(<span class="type">array_t</span> *arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 销毁数组</span></span><br><span class="line"><span class="comment">       参数</span></span><br><span class="line"><span class="comment">       		`arr`  array_t 的指针，代表要销毁的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(arr-&gt;head);  <span class="comment">// 释放数组的数据区</span></span><br><span class="line">    arr-&gt;head = <span class="literal">NULL</span>; <span class="comment">// 将数组头指针改为空值</span></span><br><span class="line">    arr-&gt;size = <span class="number">0</span>;    <span class="comment">// 将数组最大容量改为 0</span></span><br><span class="line">    arr-&gt;cur = <span class="number">-1</span>;    <span class="comment">// 将数组元素个数改为无效值 -1</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="数组的生长"><a href="#数组的生长" class="headerlink" title="数组的生长"></a>数组的生长</h3><p><strong>传统的数组大小是固定的</strong>，如果访问越界（有可能是下标过大，<strong>也有可能是下标为负数</strong>）将产生得到随机值、程序崩溃等问题。这里，我们的数组并非直接定义，而是通过<code>malloc</code>动态申请，这就为其生长提供了可能。我们规定，<strong>每当数组生长的时候，容量增加原来的一倍</strong>。当然，<strong>我们不应在程序中直接调用此函数，而是让“插入元素”等函数自动调用</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_grow</span><span class="params">(<span class="type">array_t</span> *arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 将数组容量扩大一倍</span></span><br><span class="line"><span class="comment">       参数</span></span><br><span class="line"><span class="comment">       		`arr`  array_t 的指针，代表要扩大的数组</span></span><br><span class="line"><span class="comment">       返回值</span></span><br><span class="line"><span class="comment">       		成功返回 0，失败返回 -1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> old_size = arr-&gt;size;     <span class="comment">// 生长前的容量</span></span><br><span class="line">    <span class="type">int</span> new_size = old_size * <span class="number">2</span>;  <span class="comment">// 生长后的容量</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;                <span class="comment">// 管理新分配的空间的指针</span></span><br><span class="line">    <span class="keyword">if</span> ((p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * new_size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 申请更大的空间，如果失败则直接返回</span></span><br><span class="line">                   <span class="comment">// 当然哪怕这种情况发生，原有数组中的内容仍然保存</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; old_size; i++) &#123; <span class="comment">// 循环复制原数组内容</span></span><br><span class="line">            p[i] = arr-&gt;head[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(arr-&gt;head);       <span class="comment">// 释放原数组的数据区</span></span><br><span class="line">        arr-&gt;head = p;         <span class="comment">// 更新数组首地址</span></span><br><span class="line">        arr-&gt;size = new_size;  <span class="comment">// 更新数组最大容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="元素的插入"><a href="#元素的插入" class="headerlink" title="元素的插入"></a>元素的插入</h3><p>数组的插入可以分成两类 —— <strong>尾部插入</strong>和<strong>中间插入</strong>。前者只需要传入新的元素，后者还需要获取插入的下标。这里我们仅实现前者。插入新元素，则有可能会出现越界的情况，所以<strong>这个函数需要自行判断会不会越界</strong>，如果会，则需要<strong>主动调用数组生长函数扩大空间</strong>。我们通过一张图更直观地了解数组的容量<code>size</code>和元素数量<code>cur</code>的关系。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/截屏2023-03-21 15.29.44.png"
                      alt="截屏2023-03-21 15.29.44" style="zoom:30%;" 
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_push</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 在数组 `arr` 尾部插入元素 `val` </span></span><br><span class="line"><span class="comment">       成功返回 0，出错返回 -1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr-&gt;cur == arr-&gt;size) &#123;      <span class="comment">// 这种情况表示数组已满，需要 grow</span></span><br><span class="line">        <span class="keyword">if</span> (array_grow(arr) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果 grow 失败则直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr-&gt;head[arr-&gt;cur] = val; <span class="comment">// 在尾部插入元素</span></span><br><span class="line">    arr-&gt;cur++;                <span class="comment">// 更新元素个数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>上述若干函数为我们实现了一些针对数组对象的基本操作，当然这还远远不够。你可能需要自己书写其他函数，例如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_isempty</span><span class="params">(<span class="type">array_t</span> *arr)</span>;</span><br><span class="line">    <span class="comment">// 判断数组 `arr` 是否为空。空返回 1，非空返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_get</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> index)</span>;</span><br><span class="line">    <span class="comment">// 获取数组 `arr` 中下标为 `index` 的元素值并返回</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_index_of</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="comment">// 获取数组 `arr` 中值为 `val` 的元素下标并返回，如果未查找到返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_insert</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> index, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="comment">// 在数组 `arr` 下标为 `index` 的位置插入元素 `val`。成功返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_set</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> index, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="comment">// 将数组 `arr` 中下标为 `index` 的元素设置成 `val`。成功返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_remove_index</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> index)</span>;</span><br><span class="line">    <span class="comment">// 将数组 `arr` 中下标为 `index` 的元素删除。成功返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_remove_val</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="comment">// 将数组 `arr` 中值为 `val` 的元素删除。成功返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">array_size</span><span class="params">(<span class="type">array_t</span> *arr)</span>;</span><br><span class="line">    <span class="comment">// 获取数组 `arr` 的元素个数并返回，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">array_sizeof</span><span class="params">(<span class="type">array_t</span> *arr)</span>;</span><br><span class="line">    <span class="comment">// 获取数组 `arr` 中数据部分的总字节数，功能类似传统的 sizeof(数组名)。出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">array_to_array</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> *ret)</span>;</span><br><span class="line">    <span class="comment">// 将数组对象 `arr` 转换成基本数组，存于 `ret` 中并返回。出错返回 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">array_subarray</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> *ret)</span>;</span><br><span class="line">    <span class="comment">// 将数组对象 `arr` 中下标为 [from, to) 的子序列转换成基本数组，</span></span><br><span class="line">    <span class="comment">// 存于 `ret` 中并返回。出错返回 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_sort</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> mode)</span>;</span><br><span class="line">    <span class="comment">// 将数组 `arr` 排序，规则由 `mode` 指定(如 0 为升序，1 为降序)。成功返回 0，出错返回 -1</span></span><br></pre></td></tr></table></figure></div>

<p>这些函数看起来较为麻烦，但是一经实现，你就有了独属于自己的一套模板。未来，你可以将它们扩充为适配任何类型的数组，甚至把它们<strong>做成一个头文件</strong>，每次使用时，只需要<code>#include &lt;myarray.h&gt;</code>，<strong>多是一件美事啊</strong>。实现了这些函数之后，<strong>你的代码里将不再出现大量的中括号、赋值和下标</strong>，取而代之的是 set、get、remove 等函数的调用，<strong>每一次完成一个操作，呈现在代码中的都不再是晦涩的运算符，而是具有自然语言含义的函数名</strong>，那你的代码的可读性也就增加了。</p>
<p><strong>如果同学们实现了这 12 个函数中的 8 个及以上，可以来找助教兑换小奖品。</strong></p>
<p>另外，这次封装的数组对象，也启发我们思考两个问题</p>
<ul>
<li><strong>如何封装一个链表</strong></li>
<li><strong>如何实现从<code>int</code>到任意数据类型的扩充</strong></li>
</ul>
<p>我们会在后续猪脚说中迭代地更新这部分内容。</p>
<h2 id="为什么数组比链表快"><a href="#为什么数组比链表快" class="headerlink" title="为什么数组比链表快"></a>为什么数组比链表快</h2><blockquote>
<p>已经了解过第三次作业第五题“词频统计”的同学，可以尝试用数组和链表分别实现一下。假设我们用数组实现时不用二分查找，而仍使用较低效的顺序查找，我们仍可从 judge 平台上反馈的运行时间看出，数组比链表快。这是为什么呢？</p>
<p>理论上，数组的查找时间复杂度为 $O(n)$，插入的时间复杂度也为 $O(n)$；链表的查找的时间复杂度为 $O(n)$，插入的时间复杂度为 $O(1)$。为什么数组在实践中更加高效呢？这还要从一个故事说起……</p>
</blockquote>
<h3 id="小z决战高考的故事"><a href="#小z决战高考的故事" class="headerlink" title="小z决战高考的故事"></a>小z决战高考的故事</h3><p>高中生小z打算奋战百天，决胜高考，誓死考上 BUAA。这天我们来到他的教室，看到如下场景</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/IMG_0936.JPG"
                      alt="IMG_0936" style="zoom:8%;" 
                >

<p>如图，小z的课桌上摆放了一个<strong>书立</strong>，他的课桌有一个<strong>抽屉</strong>，他的座位旁边放了一个<strong>书箱</strong>，在教室的后面还有一个<strong>储物柜</strong>。我们不难想象他会在这些地方各自存放什么东西，比如</p>
<ul>
<li>书立里放着刚考完的月考卷和今晚要做的作业；</li>
<li>抽屉里放着各科的复习书和辅导材料；</li>
<li>书箱里存放各科的课本，以备必要时参考；</li>
<li>储物柜里放着几个月前做过的卷子<del>和《故事会》</del>。</li>
</ul>
<p>按照上面的顺序，我们发现以下规律：<strong>储物量 —— 从小到大</strong>、<strong>存取物品的速度 —— 从快到慢</strong>（比如书立中的材料只需要直接抽出来、插回去，而储物柜中材料的存取还需要起身走动）、<strong>存放的内容 —— 从重要到不重要、访问频率递减</strong>。</p>
<p>很显然，这种安排符合逻辑：<strong>很快就会用到的东西就就放在手边，相对无关紧要的东西存放在别的地方</strong>。这给了我们什么启示呢？</p>
<h3 id="计算机的存储层次"><a href="#计算机的存储层次" class="headerlink" title="计算机的存储层次"></a>计算机的存储层次</h3><p><strong>计算机的存储系统从高到低大致可以分为四层：寄存器，高速缓存，内存和外存。</strong></p>
<ul>
<li><strong>外存就是硬盘等设备</strong>，如同学们常听到的“512G 的硬盘”“256G 的 iPhone”等，这些指的就是硬盘容量，U 盘等设备属于可移动的硬盘。</li>
<li>文件（包括程序）一般都存放在外存中，当它们要开始运行时，就要先<strong>加载到内存</strong>；另外，我们已经知道，<strong>程序中定义的变量、数组等也都存放在内存中</strong>。</li>
<li>寄存器位于 CPU（中央处理器） 中，<strong>存放在内存中的数据要进行运算，必须先放进寄存器</strong>。例如，我们写<code>int a = 1, b = 2; int c = 0; c = a + b;</code>，则内存中会先有<code>a</code> <code>b</code> <code>c</code>三个变量，进行第三步的运算时，先把<code>a</code>和<code>b</code>放进两个寄存器中，在 CPU 完成计算后，结果 3 被放进另一个寄存器，最后将其中的内容存放回内存中c的位置。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/截屏2023-03-23 14.48.45.png"
                      alt="截屏2023-03-23 14.48.45" style="zoom:20%;" 
                >

<p>当然，<strong>不同层级的存储设备其容量、速度和成本都是不同的</strong>。寄存器速度最快，但是容量很小（只能存放一个数）且成本高昂；内存容量比较大，但是读取和写入的速度都很慢。<strong>为了缓解 CPU 的高速和内存的低速的矛盾，人们发明了高速缓存技术。</strong></p>
<blockquote>
<p><strong>局部性原理</strong></p>
<p>局部性原理可以分为<strong>时间局部性原理</strong>和<strong>空间局部性原理</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) arr[i] = i;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>时间局部性原理：刚访问过的存储单元，不久后很可能会再次访问。</strong>例如上例中的循环变量<code>i</code>，在每一次循环中都会被访问若干次。</li>
<li><strong>空间局部性原理：刚访问过的存储单元附近的单元，不久后更可能被访问。</strong>例如上例中，我们访问了<code>arr[0]</code>，不久后就会访问其附近的<code>arr[1]</code> <code>arr[2]</code>等存储单元。</li>
</ul>
</blockquote>
<p><strong>高速缓存是一类存储设备，它们的存取速度远高于内存，但是容量比较小。</strong>根据局部性原理，把内存切割成很多<strong>块</strong>，把<strong>最近用到的</strong>一些块放进高速缓存中，每次需要访问内存时，<strong>优先到高速缓存中查找</strong>，如果找到，就可以不用访问内存，而是直接对高速缓存中的数据进行操作。如此一来，我们就可以<strong>减少直接访问内存的次数</strong>，从而<strong>提高了程序运行的效率</strong>。</p>
<p>正如同小z的例子，他会把更常用到的材料放在离手边更近的地方，从而提高寻找的效率。<strong>当然，手边的空间是有限的，他不能保证所有用到的材料都在手边；当他在手边没有找到想要的材料时，他还是得费点力气去储物柜里寻找。</strong></p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>正如前文所述，<strong>内存中的一些块会被拷贝进高速缓存中，以加快访问数据的速度</strong>。</p>
<p><strong>数组在内存中是连续存放的</strong>，因此，它们<strong>更有可能</strong>被连续地放进高速缓存中，从而在访问数据时，能够直接在高速缓存中找到，避免了查找低速的内存。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/截屏2023-03-23 15.24.35.png"
                      alt="截屏2023-03-23 15.24.35" style="zoom:35%;" 
                >

<p>链表的每一个节点都是<code>malloc</code>来的，这类动态申请的空间，<strong>离散地分布在内存中</strong>。在遍历链表的过程中，哪s怕某个节点在高速缓存中，也不能保证后续节点在高速缓存中，因此<strong>访问内存的次数大大增加</strong>，程序运行的时间增加。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/截屏2023-03-23 15.29.10.png"
                      alt="截屏2023-03-23 15.29.10" style="zoom:35%;" 
                >

<blockquote>
<p><strong>了解计算机存储相关原理并非多余或超纲。</strong>一方面，几乎所有信息类专业都要求掌握计算机组成原理 &#x2F; 计算机硬件基础 &#x2F; 计算机体系结构等科目；另一方面，多年来数据结构的大作业都是基于<strong>词频统计</strong>的，并且会根据程序运行时间进行排名，提前了解连续存储和链式存储的特点，对同学们选择解题方法有很大帮助。</p>
</blockquote>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第四期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%9B%9B%E6%9C%9F/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/IMG_0892.jpg"
                      alt="IMG_0892" style="zoom:40%;" 
                >

<h2 id="容易忽视的-bug"><a href="#容易忽视的-bug" class="headerlink" title="容易忽视的 bug"></a>容易忽视的 bug</h2><h3 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span>* wordlist[LEN];</span><br><span class="line">  <span class="type">char</span> temp[MAXSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, temp)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(temp, wordlist[i])) &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, flag ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上代码想要实现这样的功能：每当输入一个单词时，在现有单词表<code>wordlist</code>里查找其是否已存在。若查找成功，则输出<code>YES</code>，否则输出<code>No</code>。</p>
<p>细心的同学很快能发现问题：这段代码只是让<code>flag</code>初始值为 0，只要有一次查找成功之后，<code>flag</code>的值会一直 1，不会改变。因此在此之后，无论输入什么样的单词，都会输出<code>YES</code>！</p>
<p>一种正确改法是，<strong>让<code>flag</code>获得“新的开始”。即每次进入<code>while</code>循环后，进入<code>for</code>循环之前，都执行一步<code>flag = 0;</code>，</strong>让其在每一次查找的初值都为 0，便成功 de 出了 bug。</p>
<h3 id="scanf函数返回值"><a href="#scanf函数返回值" class="headerlink" title="scanf函数返回值"></a><code>scanf</code>函数返回值</h3><p>在与同学们的交流中，我们发现同学们对于<code>scanf</code>函数的返回值不太清楚，下面举一个例子</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input: %d\n&quot;</span>, <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb=%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们直接给出程序的输入和输出结果：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">  3 4</span><br><span class="line"><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">output</span>&gt;</span></span><br><span class="line">  input: 2</span><br><span class="line">  a = 3</span><br><span class="line">  b = 4</span><br><span class="line"><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>我们再多给出一些输入输出样例：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">  3 hello</span><br><span class="line"><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">output</span>&gt;</span></span><br><span class="line">  input: 1</span><br><span class="line">  a = 3</span><br><span class="line">  b = 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>通过上述例子我们发现：</p>
<ul>
<li><p><code>scanf</code>函数的返回值<strong>并不是输入的数据，而是其具体输入的有效数据的个数</strong>（这个太容易忽略了！）；</p>
</li>
<li><p>若<code>scanf</code>函数中输入了非法的值（如第二个样例），则不会改变那一个数据的原始值，且返回值（输入的有效数据个数）不会算上此次非法输入。</p>
</li>
</ul>
<p>因此，当遇到第二次作业第五道编程题（小型图书管理系统）时，不能采取如下做法：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op)) != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为，无论你输入的是操作 1、2、3还是0，<code>scanf</code>函数的返回值都为 1。所以我们推荐如下写法：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op) != EOF) &#123;</span><br><span class="line">  <span class="keyword">if</span> (op == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="一些字符判断函数的返回值"><a href="#一些字符判断函数的返回值" class="headerlink" title="一些字符判断函数的返回值"></a>一些字符判断函数的返回值</h3><p>很多同学喜欢使用<strong>声明</strong>（啥是声明啥是定义？还记得吗？）在<code>&lt;ctype.h&gt;</code>中的库函数，例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isupper</span><span class="params">(<span class="type">char</span> c)</span>;  <span class="comment">// 判断一个字符c是否为大写字母</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isdigit</span><span class="params">(<span class="type">char</span> c)</span>;  <span class="comment">// 判断一个字符c是否为十进制数字字符0～9</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isalpha</span><span class="params">(<span class="type">char</span> c)</span>;  <span class="comment">// 判断一个字符c是否为字母</span></span><br><span class="line"><span class="comment">//类似的函数还有很多……</span></span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，在大多数编译环境中，这些函数的返回值类似于<code>strcmp</code>函数，只有<strong>零和非零值</strong>（不确定）两种情况，所以形如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(a,b) == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样的写法是有巨大隐患的。</p>
<p>事实上，**<code>if</code>语句条件不成立当且仅当括号中的表达式值为<code>0</code>或<code>&#39;\0&#39;</code>或<code>NULL</code>，所以，任何其他非零值都会进入<code>if</code>分支。<strong>以<code>&lt;ctype.h&gt;</code>库函数为代表的 C 库调用，</strong>标准写法**是</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述代码会在我们脑海中直观地翻译为<strong>“如果是数字，怎么怎么样；否则怎么怎么样”</strong>，这种写法不是<strong>更贴近自然语言的语义</strong>吗？这一个小小的细节，足以充分体现<strong>【函数命名规范】和【代码书写规范】的重要性</strong>。</p>
<h2 id="数据结构引入"><a href="#数据结构引入" class="headerlink" title="数据结构引入"></a>数据结构引入</h2><p>过去几周我们复习了诸多知识点，也学习了若干新内容，这是为后续课程做铺垫。<strong>再次简要列举必会知识点，请自行查缺补漏，后续如果出现下列基本知识的迷惑，我们的回复将包括但不限于「自己百度一下」「自己 <a href="csdn.net">csdn</a>一下」「看猪脚说」「看程设课件」等。</strong></p>
<ul>
<li>基本的递归函数的使用<ul>
<li>全排列等题目确实较难，但求解斐波那契数列你得会</li>
</ul>
</li>
<li>一维数组<ul>
<li><strong>初始化</strong></li>
<li>数组名的含义</li>
<li>数组作为函数参数</li>
</ul>
</li>
<li>字符串<ul>
<li>字符数组和字符串常量的区别</li>
<li>字符串读取，<code>scanf</code>和<code>gets</code>和<code>fgets</code>等的区别<strong>（以后再出现逐个字符构造字符串忘加<code>&#39;\0&#39;</code>的问题统一回复自己 de）</strong></li>
<li>字符数组初始化</li>
<li>字符串处理函数<code>strstr</code> <code>strcmp</code> <code>strcpy</code> <code>strncpy</code> <code>strcat</code> <code>strncat</code> <code>strlen</code> <code>strchr</code>等的功能、参数类型与顺序、返回值类型与含义</li>
<li><code>char</code>与<code>int</code>的联系和区别</li>
</ul>
</li>
<li>文件操作<ul>
<li>打开文件</li>
<li>关闭文件</li>
<li>读文件：单个字符 &#x2F; 一行 &#x2F; 按指定数据类型</li>
<li>写文件：单个字符 &#x2F; 一行 &#x2F; 按指定数据类型</li>
</ul>
</li>
<li><code>&lt;ctype.h&gt;</code><ul>
<li>判断是否为字母</li>
<li>判断是否为大写</li>
<li>判断是否为小写</li>
<li>判断是否为数字</li>
<li>判断是否为数字或字母（<code>isalnum</code>）</li>
<li>判断是否为空白字符（<code>iswhite</code>）</li>
<li>判断是否为标点符号（<code>ispunct</code>）</li>
<li>转成大写</li>
<li>转成小写</li>
</ul>
</li>
<li>二维数组<ul>
<li>定义与初始化</li>
<li><strong>作为函数参数</strong></li>
<li>遍历方式</li>
<li>指向行的指针（数组指针）</li>
<li>指向列的指针（基本类型指针）</li>
</ul>
</li>
<li><strong>指针</strong><ul>
<li>指针的定义与初始化，什么是<code>NULL</code></li>
<li>不同类型的指针的区别和联系</li>
<li>取地址（什么是地址），解引用</li>
<li>字符指针和字符数组的区别和联系</li>
<li>什么是<code>void*</code></li>
<li>指针的<code>++</code> <code>--</code>和加减运算</li>
<li>给指针赋值的含义</li>
<li>数组名和指针的区别与联系</li>
<li>函数参数的值传递</li>
<li>指针数组，管理字符串常量的指针数组</li>
<li>数组指针和函数指针（不要求熟练掌握）</li>
<li><code>main</code>函数的命令行参数</li>
</ul>
</li>
<li><strong>结构体</strong><ul>
<li>结构体的声明</li>
<li>结构体变量或数组的定义与初始化</li>
<li>结构体成员的访问</li>
<li>结构体的赋值</li>
<li>指向结构体的指针及通过指针访问成员</li>
<li>类型别名的声明及其与<code>#define</code>的区别和优劣</li>
<li>自引用结构的概念（后续继续深入学习）</li>
</ul>
</li>
<li><code>qsort</code>函数<strong>（以后不要用冒泡了！）</strong><ul>
<li>包含在哪个头文件？</li>
<li>有几个参数？顺序？含义？</li>
<li><code>cmp</code>函数怎么编写？<ul>
<li>基本类型数组的升序 &#x2F; 降序（<code>double</code>类型的比较要注意什么？）</li>
<li>二维字符数组字典序</li>
<li>二维基本类型数组多关键字</li>
<li>结构体数组单关键字 &#x2F; 多关键字</li>
</ul>
</li>
</ul>
</li>
<li><code>sizeof</code>的使用，当参数为<ul>
<li>类型名的时候</li>
<li>变量名的时候</li>
<li>指针变量名的时候</li>
<li>数组名的时候</li>
</ul>
</li>
</ul>
<blockquote>
<p>接下来我们将要学习的是数据结构正文部分，作为数据结构，理应与工具的使用（C 语言语法、IDE 的配置等）脱钩，而专注于理论知识和编程实现本身。所以希望同学们尽早排除干扰项，这样，课程本身的学习也会更加轻松。</p>
</blockquote>
<h3 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h3><p>我们不谈文邹邹的东西，<del>虽然选择题可能会考</del>。如果诸位手上有《离散数学（第三版）》，不妨翻到后面“图”和“树”的章节，看看书中是怎么定义的，<del>虽然这些内容离散 1 不教</del>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 17.42.41.png"
                      alt="截屏2023-03-17 17.42.41" style="zoom:33%;" 
                >

<hr>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 17.43.04.png"
                      alt="截屏2023-03-17 17.43.04" style="zoom:33%;" 
                >

<hr>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 17.43.32.png"
                      alt="截屏2023-03-17 17.43.32" style="zoom:33%;" 
                >

<hr>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 17.43.44.png"
                      alt="截屏2023-03-17 17.43.44" style="zoom:33%;" 
                >

<hr>
<p>我们注意到，未来我们将学习的一系列数据结构，都是通过<strong>自然语言和数学符号</strong>定义的，这和 C 语言有什么关系呢？首先，想必大家已经大致了解了“链表长啥样”“树长啥样”“图长啥样”，在此基础上，我们可以说，各个类型的数据结构，只是一种<strong>逻辑上的定义</strong>，是人们<strong>在纸面上画出来的东西</strong>、是通过数学方式总结的东西。这里，我们用“东西”当作宾语，似乎显得有点抽象了。且听我们逐细言来。</p>
<h3 id="硬件与物理"><a href="#硬件与物理" class="headerlink" title="硬件与物理"></a>硬件与物理</h3><p><strong>计算机不是魔法，是由硬件组成的</strong>，比如电线、二极管、塑料等。所以大家应该意识到，你的每一次操作（点击鼠标、摁下键盘、开启网页、执行int a &#x3D; 0;），归根结底，是某些电流的流动、某些开关的开闭、高低电压的转换，甚至可以细化到电子在你看不到的地方跃迁……</p>
<p>不管怎么说，作为一个纯物理的系统，计算机需要极其复杂的设计。这种设计给我们两点启发：其一，有赖于高性能的硬件，计算机可以用于快速处理海量的数据，效率远高于人；其二，给定一台计算机，其体系结构已经定死，其能够支持的功能必然有限。<strong>事实上，这个问题的妙处就在于：我们手里只有有限的资源，但我们利用想象力，可以解决一切问题。</strong></p>
<p><strong>计算机为我们提供了内存、硬盘（磁盘）等物理设备存放数据。</strong>当程序中定义了一个接一个的变量，它们大概率<strong>会被放在一起</strong>；当程序中定义了一个数组，<strong>内存提供一片连续的空间存放</strong>；另外，我们有<strong>指针</strong>这种工具，可以<strong>间接地引用某一片内存空间</strong>。前两者对应<strong>连续存储方式</strong>，这不难理解；而后者为我们提供了一种新的思路</p>
<ul>
<li>对于每一项数据，我们为其增加一个成员 —— <strong>用于记录地址的成员</strong> —— 将其打包成一个<strong>数据包</strong>。</li>
<li>每次新增了数据需要存放，我们<strong>在内存中申请一片空间</strong>用于存储。</li>
<li>新增的数据包的地址，会被<strong>先前已经存在</strong>的数据包中的那个记录地址的成员记录下来，以便<strong>通过已经存在的数据包，访问到新的数据包</strong>。</li>
</ul>
<p>当然对应到 C 语言中，新增的那个成员就是指针，打包过程即声明<code>struct</code>，申请空间通过<code>malloc</code>，后续操作涉及指针的赋值等。于是，不同于连续存储，一种<strong>链式存储</strong>的方式诞生了。我们只需要记录下某一些节点的位置，<strong>通过其中的指针成员不断向后访问</strong>，即可以找遍所有节点。由于指针想指谁就可以指谁，因此这些节点之间的结构可能有以下几种</p>
<ul>
<li>第一个节点指向第二个，第二个节点指向第三个，……。这种链式结构，即为<strong>链表</strong>。</li>
<li>从一个根出发，不断向后分叉。这种分叉结构，即为<strong>树</strong>。</li>
<li>乱指来指去。这种乱七八糟结构，即为<strong>图</strong>。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 21.21.16.png"
                      alt="截屏2023-03-17 21.21.16" style="zoom:40%;" 
                >

<h3 id="So-What？"><a href="#So-What？" class="headerlink" title="So What？"></a>So What？</h3><p>上一小节我们从物理硬件的支持和编程语言提供的手段，描述了一种新的存储方式。我们可以进行如下思考</p>
<ul>
<li>比起刚才提及的链式存储，<strong>数组这种连续存储方式似乎更加浅显易懂</strong>；而<strong>链式存储似乎更加灵活</strong>，因为我们可以自由地排放数据的先后顺序（前提是指针不出错）。</li>
<li>某些情况下，这<strong>两种存储方式可以相互转换</strong>。例如，链表的一个接一个的存储方式，和数组也很像 —— 反之同理 —— 区别在于<strong>数组的每一个元素在内存中真的连续存放，而链表的元素离散地存放，我们只能通过指针一个接一个地访问。</strong>再比如，图的这种一个节点可以随意和其他节点连在一起的模式，似乎用数组也能做到 —— <strong>给每个点编号，然后把相邻的节点的编号都存入一个数组里</strong>。</li>
<li><strong>这些不同的结构，可以用于实际问题中的仿真。</strong>数组 &#x2F; 链表的结构像是在<strong>排队</strong>，能不能用来模拟生活中进进出出的排队问题（如航班的离港序列、银行排队与服务）呢？图能够仿真生活中管道的铺设、道路的布局等，能不能用来<strong>求最短的路径、最少的工程用料</strong>？我们发现，<strong>不同的结构都具备了描述现实世界的强大潜能</strong>。</li>
<li>上述的各种结构与计算机的运行原理密不可分。试想，同为<strong>线性结构</strong>的数组和链表，想在中间插入一个新数据，前者需要把该位置之后的所有元素，<strong>都往后挪一个位置</strong>，然后把新元素插进去；而对于后者，需要为新数据申请一片空间，然后修改一些指针的值，<strong>使得一些指向关系发生变化，从而在逻辑意义上实现了“插入”</strong>。<ul>
<li>数组插入写起来比较容易，但是需要计算机搬运很多个元素，<strong>看起来有点浪费时间</strong>。</li>
<li>链表插入有点抽象，但是实际上只需要修个几个指针的值，快速便捷；但是如果要查找一个数据，我们必须从链表的头开始，<strong>一个接一个地往后通过指针访问每个节点</strong>，这种操作好像也很麻烦。另外，<strong>对于链表，我们也就不能用<code>qsort</code>等进行排序了。</strong></li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前两节我们说了两件事：其一，计算机作为工具，<strong>为我们提供了</strong>存放数据的不同方式、不同结构、不同逻辑；其二，这些不同的方式似乎<strong>各有特点，各有优劣</strong>。以上所讨论的，都是数据结构相关的内容，所以我们在最早的时候，将数据结构描述为一样“东西”，确有其道理。所以，数据结构可以理解成以下几部分内容</p>
<ul>
<li>海量的、相互之间有关联的数据，在计算机中应<strong>如何组织</strong>（线性的排排队还是分叉结构还是其他）</li>
<li>确立了组织方式，<strong>基本的数据操作</strong>（插入、删除、查找、排序）应该如何编程，有无更加高效的写法</li>
<li>作为描述现实世界的工具，能否利用数据结构<strong>模拟实际问题</strong>（管道铺设、最短路径）</li>
<li>数据结构本身也是数学研究的对象，能否基于数学原理、利用编程工具，<strong>解决一些数学问题</strong>（利用树实现表达式的计算？有点玄乎。。。）</li>
</ul>
<p>由于本周没有太多新知识，因此写了这样一篇文字作为接下来学习的 introduction。<strong>如果你能看到这里，那么也祝愿你在数据结构的学习中取得收获与进步～</strong></p>
<h2 id="第三次作业补充练习"><a href="#第三次作业补充练习" class="headerlink" title="第三次作业补充练习"></a>第三次作业补充练习</h2><p>1、<a class="link"   href="http://akoj.online/problem/103" >干员整理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这是适合现阶段练习结构体用法的一道非常综合的题目，由北航 AK 宝典制作小组提供，初次登录网站需要注册，建议账号为自己的学号。</p>
<p>2、<a class="link"   href="http://akoj.online/problem/16" >字符串之海 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这道题可以作为第三次作业第五题（词频统计）的补充练习，很适合大家熟悉链表的使用。</p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
