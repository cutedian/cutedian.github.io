<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在前面</title>
    <url>/2023/07/13/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="此文章为何存在"><a href="#此文章为何存在" class="headerlink" title="此文章为何存在"></a>此文章为何存在</h2><p>搭建个人博客不是一件容易的事，也不是仅凭着一腔孤勇就能完成的任务。值得一提的是，该博客搭建全程基于<code>macOS</code>系统。<del>整个过程中，Diandian有不下20次想砸电脑的冲动😭</del></p>
<p>当然，此文章存在的意义不是为了抱怨搭建过程，而是希望面向访问蜜罐的朋友们回答一些问题。</p>
<h3 id="搭建个人博客的初衷"><a href="#搭建个人博客的初衷" class="headerlink" title="搭建个人博客的初衷"></a>搭建个人博客的初衷</h3><p>相信很多朋友们都知道，Diandian是一个乐于分享的人。</p>
<p>从大一开始，Diandian便持续搜集各科目资料<strong>（包括但不限于往年考题、实验报告、课程讲义）</strong>，其不仅是为了日后自我复习，还是为了分享给往后许多届的同学们。</p>
<p>毕竟，大学里要学会互帮互助，才能走得长远。因此，该博客内包括但不限于以下内容并将持续更新：</p>
<div class="note-large blue"><div class="notel-title"><p>2系：电路分析</p>
</div><div class="notel-content"><p>往年题12套</p>
<p>自写答案</p>
<p>学习方法</p>
</div></div>

<div class="note-large red"><div class="notel-title"><p>2系：基础物理学（2）</p>
</div><div class="notel-content"><p>练习题+往年题25套（题过于简单，因此无需给出答案。需要者请在首页邮箱联系或在评论区dd我）</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large purple"><div class="notel-title"><p>2系：复变函数与积分变换</p>
</div><div class="notel-content"><p>往年题16套</p>
<p>自写答案（仅给出部分，需要者请dd我）</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large cyan"><div class="notel-title"><p>2系：电子电路（1）</p>
</div><div class="notel-content"><p>期中与期末题库（几乎涵盖所有考题，详见专栏）</p>
<p>自写答案</p>
<p>全套课程讲义</p>
<p>仿真实验报告与硬件实验报告</p>
</div></div>

<div class="note-large orange"><div class="notel-title"><p>2系：电磁场理论</p>
</div><div class="notel-content"><p>6套期中+8套期末</p>
<p>自写答案</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large yellow"><div class="notel-title"><p>2系：信号与系统</p>
</div><div class="notel-content"><p>8套期末+1套题库</p>
<p>全套课程讲义</p>
<p>仿真实验报告</p>
</div></div>

<div class="note-large green"><div class="notel-title"><p>2系：FPGA基础</p>
</div><div class="notel-content"><p>（由于该门课程为21级新开设，上机实验是否祖传尚不清楚😭）</p>
<p>仿真实验报告+代码打包</p>
</div></div>

<div class="note-large blue"><div class="notel-title"><p>助教资料</p>
</div><div class="notel-content"><p>数据结构与程序设计</p>
<p>复变函数与积分变换</p>
<p>信号与系统（待定）</p>
</div></div>

<div class="note-large orange"><div class="notel-title"><p>视频剪辑</p>
</div><div class="notel-content"><p>剪辑工具如何搭配</p>
<p>剪辑思路</p>
<p>Premiere（简称pr）900个转场预设（自创，无版权要求）</p>
<p>Adobe 全家桶（2022Win&#x2F;Mac版）（无需收费与解压密码）</p>
</div></div>

<h3 id="评论模块"><a href="#评论模块" class="headerlink" title="评论模块"></a>评论模块</h3><p>此博客的评论模块采取<code>Giscus</code>评论系统，该系统基于<code>GitHub Discussions</code>实现，让各位蜜罐访客们能够借助<code>GitHub</code>在文章末尾留下评论。因此，评论员需要一个<code>GitHub</code>账号，如果没有的话赶快注册一个哦～</p>
<a class="button  center large" href='https://github.com/' title='GitHub账号注册'><i class='fa-brands fa-github'></i> GitHub账号注册</a>

<p>当然，此步骤可能需要你会科学上网。在此提供一种macOS上自测有效（Windows也可）的方法</p>
<a class="button  center large" href='https://doc.miyun.app/clashx/' title='免费开启ClashX代理'><i class='fa-solid fa-face-awesome'></i> 免费开启ClashX代理</a>

<p>当然，如果各位不想通过评论区的方式与我交流联系，也可直接访问首页大字<code>Dian·Stay Curious</code>下三个图标中的<code>邮箱</code>，此按钮会引导你编辑内容发送到<code>zhongyd2004@163.com</code>。</p>
<blockquote>
<p>注意：</p>
<p><code>Giscus</code>仍处于活跃开发中，<code>GitHub</code>也还在活跃地开发<code>Discussions</code>及其<code>API</code>，因此一些<code>Giscus</code>的特性可能随时间损坏或变更。当然，Diandian将密切关注此情况。</p>
</blockquote>
<h3 id="文章编写：Typora"><a href="#文章编写：Typora" class="headerlink" title="文章编写：Typora"></a>文章编写：Typora</h3><p>该博客中所有文章均为<code>.md</code>格式（全称<code>markdown</code>），采用<code>Typora</code>软件进行编写。</p>
<p>如果你想更方便地自创与编辑<code>.md</code>格式文件，不妨用一下<code>Typora</code>软件，虽然要收费（不打折时，终身使用仅需89元），但是非常好用😋</p>
<a class="button  center large" href='https://typoraio.cn/' title='Typora软件下载'><i class='fa-solid fa-t'></i> Typora软件下载</a>

<p>当然，<code>markdown</code>语法请自己搜索学习。</p>
<h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>内容分发网络（CDN）是一种分布式系统，<strong>它将内容存储在离用户最近的服务器上</strong>，从而提高用户访问网站的速度和性能。<code>CDN</code>会将用户的请求转发到最近的服务器上，而不是将请求转发到网站的源服务器上。这样可以减少源服务器的负载，同时也可以提高用户访问网站的速度。</p>
<p>本博客基于<code>EvanNotFound</code>大佬的阿里云<code>OSS</code>采取CDN加速，以期望带给各位更顺畅的体验。</p>
<h3 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h3><p>该博客已开通友链模块，想要申请加入的请私信Diandian哦～</p>
<p>（悄悄说一声，如果能提供首页缩略图和头像图就更好啦）</p>
<h2 id="开源相关"><a href="#开源相关" class="headerlink" title="开源相关"></a>开源相关</h2><p><a class="link"   href="https://github.com/XPoet/hexo-theme-keep" >https://github.com/XPoet/hexo-theme-keep <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/volantis-x/hexo-theme-volantis" >https://github.com/volantis-x/hexo-theme-volantis <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/theme-next/hexo-theme-next" >https://github.com/theme-next/hexo-theme-next <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/jerryc127/hexo-theme-butterfly" >https://github.com/jerryc127/hexo-theme-butterfly <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://m3.material.io/" >https://m3.material.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://developer.apple.com/design/human-interface-guidelines/" >https://developer.apple.com/design/human-interface-guidelines/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://fluent2.microsoft.design/" >https://fluent2.microsoft.design/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.sketch.com/" >https://www.sketch.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://hexo.io/zh-cn/" >https://hexo.io/zh-cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://highlightjs.org/" >https://highlightjs.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/next-theme/hexo-filter-mathjax" >https://github.com/next-theme/hexo-filter-mathjax <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" >https://github.com/webappdevelp/hexo-filter-mermaid-diagrams <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/theme-next/hexo-generator-searchdb" >https://github.com/theme-next/hexo-generator-searchdb <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/hexojs/hexo-generator-feed" >https://github.com/hexojs/hexo-generator-feed <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/yanyiwu/nodejieba" >https://github.com/yanyiwu/nodejieba <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://aplayer.js.org/#/" >https://aplayer.js.org/#/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://fontawesome.com/" >https://fontawesome.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.zhheo.com/p/557c9e72.html" >https://blog.zhheo.com/p/557c9e72.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/mattboldt/typed.js/" >https://github.com/mattboldt/typed.js/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="Stay-Curious-Stay-Interesting"><a href="#Stay-Curious-Stay-Interesting" class="headerlink" title="Stay Curious, Stay Interesting"></a>Stay Curious, Stay Interesting</h2><p>在此篇博客的主页会出现<code>Dian·Stay curious</code>，侧边公告栏中出现<code>Stay curious, stay interesting.</code></p>
<p>此句是Diandian最喜欢的英语句子，源于Diandian的高中英语老师<code>Chelsea</code>。我们每次英语课前的老师问好环节，<code>Chelsea</code>会喊出前一句，我们则说出后一句😋。</p>
<p><strong>因此，让我们也在文章末尾大声地说出：“Stay curious, stay interesting!”</strong></p>
]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第一期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%B8%80%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="什么是猪脚说"><a href="#什么是猪脚说" class="headerlink" title="什么是猪脚说"></a>什么是猪脚说</h2><p>为了改善同学们的上机体验，减轻同学们的压力，集中回答编程中常见问题，继承上一辈助教的优良传统，我们<strong>为大家精心准备了猪脚说</strong>。</p>
<p>猪脚说，就是<del>猪脚</del>助教们想对大家说的话。每次上机后，我们会及时总结大家<strong>提问相对较多</strong>或<strong>比较重要</strong>的问题，在猪脚说中以详细的篇幅加以阐述，希望同学们或多或少得到一些启发。</p>
<p>猪脚说包括但不限于<strong>共性问题</strong>, <strong>coding 小技巧</strong>, <strong>课外习题</strong>。</p>
<h2 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h2><h3 id="指针详详详解"><a href="#指针详详详解" class="headerlink" title="指针详详详解"></a>指针详详详解</h3><h4 id="指针与地址"><a href="#指针与地址" class="headerlink" title="指针与地址"></a>指针与地址</h4><p>考虑如下代码，发生了什么？</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure></div>

<p>要回答这个问题，我们要从最开始的地方说起。</p>
<h5 id="你好，世界！"><a href="#你好，世界！" class="headerlink" title="你好，世界！"></a>你好，世界！</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>我们知道，数据总是存储在计算机里的。我们要打印的字符串，应该存在哪里呢？为了便于说明这个问题，我们把计算机内部存储数据的地方<strong>想象成一个大柜子，柜子有一个一个的抽屉</strong>；每个抽屉的容量是有限的，只能放得下一个字符，也就是一个<code>char</code>的内容。这里为了避免引入“字节”的概念，给出如下的大小关系：<code>4个char的大小 = 1个int的大小</code>，<code>8个char的大小 = 2个int的大小 = 1个double的大小 = 1个long long</code>的大小。</p>
<p>上述语句中的字符串，用<strong>双引号</strong>括起来，称为<strong>“字符串字面值常量”</strong>。作为字符串，它由若干字符拼接而成，后来的故事我们都知道了，在它的最后还有一个看不见的<code>&#39;\0&#39;</code>作为结束的标志；作为常量，这类字符串的内容不能被修改。</p>
<p>这样的字符串常量，储存在大柜子里的一块特定区域，称为<strong>常量区</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 15.50.21.png"
                      alt="截屏2023-02-24 15.50.21" style="zoom:40%;" 
                >

<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="type">int</span>  i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>

<p>后来我们学了变量，它们当然也装在这个大柜子里。如果这只是个有很多抽屉的柜子，那么数据的存取将变得异常困难，一个很显然的做法是，<strong>为每个抽屉编号</strong>。但另一个问题又来了，计算机自然可以通过编号访问数据；但作为编程者，我们并不知道每个变量存在哪个编号的抽屉里。于是另一个很显然的做法是，我们可以为存有变量的抽屉<strong>贴上标签</strong>，这就是<strong>标识符</strong>，例如<code>c</code>和<code>i</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.12.35.png"
                      alt="截屏2023-02-24 16.12.35" style="zoom:40%;" 
                >

<p><strong>特别要注意的是，<code>int</code>变量<code>i</code>占用了 4 个抽屉。</strong>有了这个模型，我们就能知道<code>int i = 10;</code>中，<code>i</code>表示的是存放了数字 10 的那 4 个抽屉的标签；它的编号是 21；从编号 21 开始之所以放了 4 个抽屉，是类型<code>int</code>决定的。</p>
<p><strong>后来我们知道了，这个编号，就是指针。指针，就是地址。</strong></p>
<h5 id="回答一下前面的问题"><a href="#回答一下前面的问题" class="headerlink" title="回答一下前面的问题"></a>回答一下前面的问题</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.22.14.png"
                      alt="截屏2023-02-24 16.22.14" style="zoom:40%;" 
                >

<ul>
<li>首先定义一个普通变量<code>a</code>，被装在 4 个抽屉里，抽屉的起始编号是 21，抽屉的内容是 10。</li>
<li>然后定义了一个指针变量<code>p</code>，<code>p</code>也需要 4 个抽屉存放<strong>（因为<code>p</code>的本质也是一个整数！！！）</strong>，<code>p</code>也有自己的编号 44，<code>p</code>的内容是存放<code>a</code>的抽屉的起始编号，即 21。</li>
<li><code>p</code>只存放了<code>a</code>的起始地址，<code>p</code>怎么知道<code>a</code>从 21 开始占了多少个抽屉呢？这由定义<code>p</code>的<code>int *</code>中的<code>int</code>决定。<strong>换言之，</strong><ul>
<li><code>char *p</code>表示<code>p</code>中存放一个整数，这个整数是一个地址，从那个地址开始的 1 个抽屉的内容是一个<code>char</code>变量，因为<code>char</code>只需要 1 个抽屉。</li>
<li><code>int *p</code>表示<code>p</code>中存放一个整数，这个整数是一个地址，从那个地址开始的 4 个抽屉的内容是一个<code>int</code>变量，因为<code>int</code>需要 4 个抽屉。</li>
<li><code>double *p</code>表示<code>p</code>中存放了一个整数，这个整数是一个地址，从那个地址开始的 8 个抽屉的内容是一个<code>double</code>变量，因为<code>double</code>需要 8 个抽屉。</li>
<li>……</li>
</ul>
</li>
</ul>
<h5 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h5><p>有了指针，在我们的程序里，要访问一个变量就有两种方法了。一方面，可以通过<strong>抽屉的标签</strong>，也就是<strong>变量名</strong>访问；另一方面，可以通过<strong>抽屉的编号 —— 指针</strong>，间接地访问。后者自然要加上**指针运算符（解引用）<code>*</code>**。</p>
<p>显然，在多数情况下，偏要用指针间接访问一个变量是毫无意义的。但在某些情况下，我们只能通过指针访问。考察下面的程序</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pass_by_value</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pass_by_pointer</span><span class="params">(<span class="type">int</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    pass_by_value(x);</span><br><span class="line">    pass_by_pointer(&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>稍有经验的同学不难看出，<code>x</code>的值不会被修改，<code>y</code>的值会被修改。为什么呢？</p>
<p><strong>C 程序的函数参数都是值传递的。</strong>这句话的意思是，一个函数的运行，自然会涉及一些变量，其中的一部分是函数参数，另一部分是函数内部定义的变量；<strong>在函数运行期间，函数需要借用一些抽屉来存放这些变量的值</strong>。对于<code>pass_by_value(x);</code>中的<code>x</code>，函数只会把**<code>x</code>的值<strong>放在自己借用的抽屉里，而不会意识到<code>x</code>是某处的一个标签；对于<code>pass_by_pointer(&amp;y);</code>中的<code>&amp;y</code>，函数只会把</strong><code>&amp;y</code>的值** —— <strong>这个值是一个普通整数，并且是一个地址</strong> —— 放在自己借用的抽屉里。两者的不同之处在于，前者真的只是传了一个普通整数；而<strong>后者传入的整数同时也是地址</strong>，我们在函数内部确实访问了这个地址的内容，从而真的修改了<code>y</code>的值。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.56.33.png"
                      alt="截屏2023-02-24 16.56.33" style="zoom:35%;" 
                >

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><blockquote>
<p>为了绘图简便，我们考察<code>short</code>型的数组。一个<code>short</code>变量占两个抽屉。此处我们仅考虑数组和指针的关系，数组的定义、初始化、元素访问等不再赘述。</p>
</blockquote>
<p>我们会说，<strong>数组名就是指针</strong>，这句话的意思是</p>
<ul>
<li><strong>只要知道了数组的首地址，就可以访问数组的每个元素。</strong>假设<code>p</code>存放着数组的首地址，下标从 0 开始，我们要访问下标为<code>index</code>的元素，一种写法是<code>p[index]</code> —— 相当于从数组首元素<strong>往后数</strong><code>index</code>个元素，然后访问那个元素 —— 等价于<code>*(p + index)</code>，即将<code>p</code><strong>偏移</strong>，从而使之指向欲访问的元素，然后解引用。</li>
<li>系统手里有一张表，叫做<strong>符号表</strong>。数组名是符号表中的一项，它是一个<strong>不可修改的常量</strong>，指代数组的首地址。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 17.30.56.png"
                      alt="截屏2023-02-24 17.30.56" style="zoom:40%;" 
                >

<p>当数组作为函数参数传递的时候，<strong>统一当成指针处理</strong>，所以以下三种函数声明等价：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *arr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arr[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arr[<span class="number">999</span>])</span>; <span class="comment">// 并不关心数组多大</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>后面两种声明会被翻译成第一种声明，也就是指针的形式。<ul>
<li>数组可以通过首地址访问，所以传入首地址是可行的。</li>
<li>通过指针，在<code>main</code>函数里定义的数组，可以在<code>func</code>中被修改，这与普通变量的值传递不同。</li>
</ul>
</li>
<li>前面说到，函数参数需要借一些抽屉临时存放。而函数能借到的抽屉是<strong>有限的</strong>，如果真的把一个长度为 999 的数组传入，则需要 999 × 4 个抽屉，这不太现实。只传入指针，则只需要 4 个抽屉即可 —— 通过指针间接访问数组。</li>
<li>此外，上一点也提醒我们，<strong>函数内部并不知道数组有多大，它只知道数组的首地址</strong>。所以对数组操作的函数，一般需要再加上一个<code>size</code>参数，保证函数中不会出现<strong>数组越界</strong>的情况。</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>在最开始的地方谈到，用双引号扩起来的字符串常量，被存放在大柜子的一块特定区域，即常量区。事实上，不仅是我们想要输出的文本信息，<strong>C 程序中任何地方</strong>出现的字符串常量，都会被存在那里。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="type">char</span> *s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br></pre></td></tr></table></figure></div>

<p>这里的<code>&quot;%d %d&quot;</code> <code>&quot;hello world&quot;</code> <code>&quot;%s\n&quot;</code>都是字符串常量，都会被预先存在常量区。另一方面，这种字符串常量的最后都默认有一个看不见的<code>&#39;\0&#39;</code>作为结束的标志，这是系统自动加上的。</p>
<p>我们想象这样的画面，每个抽屉只能装一个字符，<strong>只要我们知道了字符串的第一个字符装在哪个抽屉，然后依次往后拉开抽屉，直到拉开了存放<code>&#39;\0&#39;</code>的那个抽屉为止，我们就获得了字符串的所有内容</strong>。于是，<strong>字符串的首地址就成为了确定一个字符串唯一所需要的信息。</strong><code>char *s = &quot;hello world&quot;;</code>的那个指针<code>s</code>，做的就是这件事。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 11.57.03.png"
                      alt="截屏2023-02-25 11.57.03" style="zoom:40%;" 
                >

<p><strong>另一方面，字符串也可以存在我们自定义的数组里，但是其初始化值得考察。</strong>假设我们要存入的是<code>&quot;abc&quot;</code>。</p>
<ul>
<li><p>数组大小应该开够，因为需要有<code>&#39;\0&#39;</code>作为结束标志</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 开得足够大，并且别忘了 \0</span></span><br><span class="line"><span class="type">char</span> s[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;   <span class="comment">// 不写大小，由系统自动判断，此处 s 大小即为 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">4</span>]; s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>; s[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>; s[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span> = s[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 更加麻烦的逐一赋值，但 OK</span></span><br></pre></td></tr></table></figure></div>

  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 12.02.53.png"
                      alt="截屏2023-02-25 12.02.53" style="zoom:40%;" 
                >
</li>
<li><p>有一种<strong>便捷手段</strong>，在初始化的时候，<strong>用字符串字面值常量为字符数组赋初值</strong></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 开大点总是保险</span></span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>;   <span class="comment">// 这么做默认 s 大小为 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严禁这么做！</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>]; <span class="comment">// 定义了一个数组，数组名是符号表中的常量</span></span><br><span class="line">s = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 给一个符号常量赋值，是绝对不行的</span></span><br></pre></td></tr></table></figure></div>

  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 12.08.20.png"
                      alt="截屏2023-02-25 12.08.20" style="zoom:40%;" 
                ></li>
</ul>
<h4 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h4><p><strong>指针是工具，是用来使用的。</strong></p>
<p>对指针的本质进行解析，为的是让大家理解其使用方式。使用指针，需要的是在脑海中形成意识“我们就是这么做的”“这么做是合理的”。对于指针的基本理解包括但不限于以下几点</p>
<ul>
<li>指针是个<strong>变量</strong>，指针是个<strong>整数</strong>。</li>
<li>取变量的地址赋值给指针，我们就说指针指向了那个变量。</li>
<li>指针“指向”，只是说指针中存了一个整数地址；<strong>要访问变量，需要一次解引用</strong>。</li>
<li><strong>数组名是一个符号</strong>，等价于数组首地址。</li>
<li>双引号扩起来的字符串是常量，只读不写。</li>
</ul>
<p>我们需要培养一些基本的意识，要知道“我可以写什么，不可以写什么”。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr; <span class="comment">// arr符号代表首地址，赋值给指针，当然可以</span></span><br><span class="line">p[<span class="number">1</span>] = <span class="number">5</span>;     <span class="comment">// 指针也可以像数组一样访问</span></span><br><span class="line">*(p + <span class="number">2</span>) = <span class="number">2</span>; <span class="comment">// 指针自己也具备了“偏移 + 解引用”操作</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *s  = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 这是指针指向字符串常量</span></span><br><span class="line"><span class="type">char</span> t[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 这是一个普通数组，并使用了便捷方式初始化</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span>;       <span class="comment">// 字符串常量不能修改！</span></span><br><span class="line">t[<span class="number">1</span>] = <span class="string">&#x27;y&#x27;</span>;       <span class="comment">// 数组当然可以修改</span></span><br></pre></td></tr></table></figure></div>

<p>最后补充的是<code>NULL</code>和<code>const</code>指针。</p>
<h5 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a><code>NULL</code></h5><p>指针是一个<strong>整型变量</strong>，它的取值无非有这么几种</p>
<ul>
<li>只定义但未初始化，是一个随机值。</li>
<li>进行初始化或赋值，“指向了其他的变量”。</li>
<li>初始化为 0。（编号为 0 的那个抽屉存了啥？）</li>
</ul>
<p><code>NULL</code>是一个宏，代表整数 0，用于指针的初始化：<code>int *p = NULL;</code> 当然也可以写 <code>int *p = 0;</code>。</p>
<p>当一个指针未初始化时，它可能指向任何地方，但是那里究竟能不能访问是未知的，这就是<strong>野指针</strong>。在有些情况下，访问了不该访问的地方，可能导致系统崩溃。人们规定，<strong>编号为 0 的那个抽屉是一个无效的抽屉，一旦访问，程序运行就强制结束了</strong>（总比系统崩溃好）。所以在将指针指向某个变量之前，初始化为 0 或<code>NULL</code>，是有必要的。</p>
<h5 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a><code>const</code>指针</h5><p>我们知道字符串常量存在常量区，但其他常量，如<code>const int</code>，还是和普通变量放在一起的。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></div>

<p>当编译器看到这两行代码，它会说：“<code>a</code>被定义为常量，你却要为<code>a</code>赋其他值，不可以！”于是报错。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line">*p = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></div>

<p>当编译器看到这两行代码，它会说：“<code>a</code>是常量，存在内存里了。<code>p</code>想要指向它，当然可以。对指针<code>p</code>解引用进行赋值，当然可以。”于是真的，一个<code>const int</code>的值通过指针被修改了。</p>
<p>所以我们有必要避免这种情况，手段就是<strong>“指向常量的指针”</strong>。前文说到，<strong>指针是统一的一种类型，就是整型</strong>。定义指针时前面的类型，只是告诉系统，“连续打开几个抽屉”。打开抽屉后，无非有两种操作：看一下里面是什么（<strong>读</strong>操作）和修改一下内容（<strong>写</strong>操作）。对于后者，如果抽屉里装的是常量，则应该避免。</p>
<p>在定义指针的最前面加上<code>const</code>修饰，如<code>const int *p = &amp;a;</code>，就定义了指向常量的指针。这么做的好处是，<code>p</code>说：“我是指针，我指向<code>a</code>，但你<strong>无法通过我</strong>修改<code>a</code>的值，<strong>你有没有其他手段修改<code>a</code>的值，与我无关。</strong>”</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a; <span class="comment">// 这是正确的，定义了指向常量的指针</span></span><br><span class="line">*p = <span class="number">100</span>;          <span class="comment">// 通过 p 无法修改 a</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *q = &amp;b; <span class="comment">// 指向常量的指针指向了普通变量</span></span><br><span class="line"><span class="type">int</span> *r = &amp;b;       <span class="comment">// 普通的指针指向了普通变量</span></span><br><span class="line">*q = <span class="number">100</span>;          <span class="comment">// 无法通过 q 修改 b 了，哪怕 b 是一个普通变量</span></span><br><span class="line">*r = <span class="number">100</span>;          <span class="comment">// 这么改当然可以</span></span><br></pre></td></tr></table></figure></div>

<p>于是我们会在大量字符串处理函数的原型中，看到参数都定义为<code>const char *p</code>类型，这就是说，字符串通过<code>p</code>传入函数，<strong>保证在函数内部，不会修改字符串的内容</strong>。这么做是严谨的。</p>
<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><h4 id="库函数功能介绍"><a href="#库函数功能介绍" class="headerlink" title="库函数功能介绍"></a>库函数功能介绍</h4><p><code>size_t</code> 为无符号整数类型，它是 <strong><code>sizeof</code></strong> 关键字的结果。</p>
<p>下列常用字符串处理函数均定义在头文件  <code>&lt;string.h&gt;</code> 中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 把 str1 和 str2 的前 n 个字节进行比较。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 从 src 复制 n 个字符到 dest。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复制字符 c （一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</span></span><br><span class="line"><span class="comment">	e.g.想要将一个 int 类型数组 a[50] 全部置为0:</span></span><br><span class="line"><span class="comment">		memset(a, 0, sizeof(a));</span></span><br><span class="line"><span class="comment">	等效于 for (i=0; i &lt; 50; i++) a[i] = 0;</span></span><br><span class="line"><span class="comment">	【特别注意】一般此函数仅用于全部归零，其他值不能随便设置！！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="comment">// 把 src 所指向的字符串（包括&#x27;\0&#x27;）追加到 dest 所指向的字符串的结尾（删除 dest 原来末尾的&#x27;\0&#x27;）。</span></span><br><span class="line"><span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 的字符串。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 把 src 所指向的字符串的前 n 个字符追加到 dest 所指向的字符串的结尾（删除 dest 原来末尾的&#x27;\0&#x27;）。</span></span><br><span class="line"><span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 的字符串。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="comment">	返回值为该字符串中第一次出现的字符的指针，若不包含该字符则返回 NULL 空指针。</span></span><br><span class="line"><span class="comment">	char *strrchr(const char *str, int c);</span></span><br><span class="line"><span class="comment">	在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	把 str1 所指向的字符串和 str2 所指向的字符串进行比较并返回整数。若两字符串相等，则返回零。</span></span><br><span class="line"><span class="comment">	若 str1 &lt; str2, 则返回负数; 若 str1 &gt; str2, 则返回正数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line">	<span class="comment">// 把含有&#x27;\0&#x27;结束符的字符串 src 复制到以 dest 开始的地址空间。</span></span><br><span class="line">	<span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 字符串。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line">	<span class="comment">// 把字符串 src 的前 n 个字符复制到以 dest 开始的地址空间。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">// 计算字符串 str 的长度，知道空结束字符但不包括空结束字符。返回值数据类型为无符号整型。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="comment">// 在字符串 dest 中查找第一次出现字符串 src（不包含空结束字符）的位置。</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>补充练习：字符串处理函数与指针的使用。<strong>此题将在下周上机详细讲评。</strong></p>
<p>输入 n 个字符串，将每个字符串中的<code>good</code>子串全部替换为<code>perfect</code>后输出。（不用担心数据范围，写代码实现此功能即可）。</p>
<p><strong>样例输入</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">abc123</span><br><span class="line">BUAA  goodddd 123 Good</span><br><span class="line">godgoodgodgoooood goo? gooD good!</span><br></pre></td></tr></table></figure></div>

<p><strong>样例输出</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc123</span><br><span class="line">BUAA perfectddd 123 Good</span><br><span class="line">godperfectgodgoooood goo? gooD perfect!</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="读取字符串"><a href="#读取字符串" class="headerlink" title="读取字符串"></a>读取字符串</h4><p>很多同学在使用 <code>gets()</code> 函数读取字符串时，可能在 judge 平台的编译器上收到这样的提示:</p>
<p><strong>Warning: the ‘gets’ function is dangerous and should not be used.</strong></p>
<p>原因在于：**<code>gets()</code>函数不做地址越界检查！**若输入的字符串大于既定数组的长度，程序运行会出现难以预期的错误。<a class="link"   href="https://blog.csdn.net/weixin_33748818/article/details/89776085" >有兴趣的同学可以从这篇文章中作详细了解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>在此，我们建议使用如下两种方式读取字符串:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"><span class="comment">// 该函数更多被用来读取单词，而非整行字符串。它从一个非空白字符开始，读到下一个空白字符为止。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[BUFSIZ] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">fgets(buf, BUFSIZ, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="comment">// 该函数的第二个参数代表规定从标准输入读取字符上限的数量，这也是它优于 gets() 函数的地方。</span></span><br><span class="line"><span class="comment">// 我们更推荐大家使用此种方法来读取整行字符串。</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>BUFSIZ</code>是宏定义在头文件里的常数，一般值为 512，对于大家完成上机作业已经够用了。</p>
</li>
<li><p><code>stdin</code>为标准输入，也就是键盘输入。在之后的文件输入输出时，可以修改此参数为文件指针。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong></p>
<p><code>fgets()</code> 函数会读取 <code>&#39;\n&#39;</code> 并写进数组中, 因此使用<code>strlen()</code> 函数求取数组长度时, 得到的长度比实际可见字符数多 1，其中包含了最后一个换行符。</p>
</blockquote>
<h3 id="char与int的转换"><a href="#char与int的转换" class="headerlink" title="char与int的转换"></a><code>char</code>与<code>int</code>的转换</h3><p>先来看第一次作业填空题第四题:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">invert</span><span class="params">(<span class="type">char</span> str[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>, j = <span class="built_in">strlen</span>(str)<span class="number">-1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">		k = str[i];</span><br><span class="line">		str[i] = str[j];</span><br><span class="line">		str[j] = k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不少同学都来提问: <code>k</code>不是<code>int</code>类型的变量吗，怎么能够和一个字符进行相应的运算关系？</p>
<p>需要指出的是：某个字符和它由 <strong>ASCII 码表</strong>所对应的整型值是等价的。即如果用整型值 48 赋值给某个字符，则其输出结果会是 ‘0’; 如果用字符常量 ‘0’ 赋值给某个整型变量，则其输出后为 48。</p>
<p><code>char</code>型实际上就是 0 到 127 的整型数经过 <strong>ASCII 码表</strong>映射的结果，其与<code>int</code>型的转换需要代入映射后得到对应值。</p>
<p>如果还有同学有疑问或者想要了解更多例子，不妨看下面一些代码:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) </span><br><span class="line">    <span class="comment">// do something</span></span><br></pre></td></tr></table></figure></div>

<p>上述代码为最简单的两个字符比较大小，其本质上是以相应的<strong>ASCII码表</strong>值的大小作为字符比较的标准。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">char</span> str[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line"> 			str[i] += <span class="number">32</span>; </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码可以实现把一段字符串中的大写字母全部转化为小写字母，其中倒数第三行就是字符与整型量的运算。</p>
<h2 id="第一次作业补充练习"><a href="#第一次作业补充练习" class="headerlink" title="第一次作业补充练习"></a>第一次作业补充练习</h2><p><a class="link"   href="https://www.luogu.com.cn/training/48079" >此链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>可以收藏起来，若有需求可以去做一些练习。</p>
<p>1、 <a class="link"   href="https://www.luogu.com.cn/problem/P5734" >处理字符串，主要考察大家对常用字符串处理库函数的运用。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>2、 <a class="link"   href="https://www.luogu.com.cn/problem/P1308" >单词统计，注意题干要求处理大小写字母。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>3、 <a class="link"   href="https://www.luogu.com.cn/problem/P1022" >改良计算器，为第一次上机第二道编程的拓展。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>4、 <a class="link"   href="https://www.luogu.com.cn/problem/P8652" >对于小数点后位数的处理。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>5、<a class="link"   href="https://www.luogu.com.cn/problem/P2293" >高精度开根，第一次上机第四道编程的拓展。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第二期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%BA%8C%E6%9C%9F/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets2/IMG_0716.jpg"
                      alt="IMG_0716" style="zoom:33%;" 
                >

<blockquote>
<p><strong>写在前面 —— 关于理论与实验</strong></p>
<p>我们可以很负责地告诉大家，几乎所有的计算机软件核心专业课（如计算机组成原理、操作系统、编译原理、计算机网络等），都由理论和实验两部分构成。前者，基本建立在抽象的层面上，一般以<strong>文字表述和数学公式</strong>给出；后者，基本需要个人在实践中完成。实验的内容一般由指导书、手册等给出，需要<strong>自行阅读了解</strong>；而其中涉及的工具和方法，如虚拟机、编程工具、编程语言等，完全<strong>通过自学解决</strong>。</p>
<p>幸运的是，作为一门承上启下的课程，数据结构课的重点知识并非仅纯数学符号。由于我们的学习进度尚有限，这门课在日常教学中也融入了大量 C 语言代码，并且几乎可以当作“板子”。所谓板子，就是<strong>可以直接拷贝黏贴</strong>的东西，<del>每到考试，也会出现打板子、拼接板子等现象</del>。</p>
<p>这给我们两点启发。其一，很多知识在课件里就能找到，当同学们遇到困难时（如文件操作、结构体），不必等老师讲授，自行看课件、搬运代码，很多问题就能迎刃而解。其二，我们必须强调自学的重要性，善于通过各类渠道解决问题。举个例子，仅通过搜索引擎，就可以查询到近来上机出现的诸多问题。</p>
<p>此外，由于实验的基本形式是选填和编程题，而非从零开始迭代着制造一个东西，所以就没有指导书的必要。<strong>我们的“猪脚说”则作为上机实验的补充指导，解答共性问题、提供知识总结，希望对大家有所帮助。</strong></p>
</blockquote>
<h2 id="常见问题汇总"><a href="#常见问题汇总" class="headerlink" title="常见问题汇总"></a>常见问题汇总</h2><blockquote>
<p><strong>为什么我本地测试正确，提交运行却出现了多余字符？</strong></p>
</blockquote>
<p>数组是一片连续的内存空间，<strong>数组之外的内容是不可控的</strong>。当我们越界访问时，有可能成功，有可能报错，有可能读取到随机内容。因此，这类问题的主要原因是数组开得不够大和未初始化。</p>
<p><strong>(1) 数组大小。</strong>题目不一定给出明确的数据范围，如果有数据范围，比如 80，则开到100 比较合适，甚至 200、500 等都不过分。如果没有数据范围，则根据经验考虑，如字符数组开 512 或 1024 大小，整型数组开 200、1000 等。一般不会在数据范围的问题上为难大家，但如果开得和题目说的一样大，确实更容易出错（如忘了字符串末尾的<code>&#39;\0&#39;</code>，下标从 1 开始等）。</p>
<p><strong>(2) 初始化。</strong>很多时候都需要把一个数组或变量初始化成 0。考虑这样一种情况，我们逐个字符地构造一个字符串，结果最后忘了添加<code>&#39;\0&#39;</code>，<strong>如果这个字符数组先前被初始化成全 0，则字符串的后面还是有<code>&#39;\0&#39;</code>的</strong>；如果未初始化，字符串后面的内容则是未知的，极有可能出错。下面给出一些常见的初始化方式。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码都处在 main 函数中</span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;          <span class="comment">// 初始化为全 0</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">10</span>] = &#123;<span class="number">1</span>&#125;;          <span class="comment">// 仅 arr2[0] 为 1，其他都是 0</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;          <span class="comment">// 全部初始化为 &#x27;\0&#x27;，等价于 char str[10] = &#123;&#x27;\0&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环也是初始化的常见方式，千万不要觉得麻烦！</span></span><br><span class="line"><span class="type">int</span> arr3[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr3[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> arr4[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">        arr4[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>(3) 全局变量。</strong>全局变量会执行<strong>默认初始化</strong>，一般自动初始化成 0；且在各个函数中都能直接访问，简化了参数列表。但正如同先前谈到的代码风格问题，频繁使用全局变量并不是一个好习惯。一般地，只有需要很大的数组，如<code>int [1000000]</code>，或常量，如<code>const int MAX_LENGTH = 1024;</code>的时候，才会使用全局变量。</p>
<blockquote>
<p><strong>为什么错误输出和期望输出一模一样还会 WA？</strong></p>
</blockquote>
<p>这种问题多数是由于通过<code>printf(&quot;%c&quot;, c);</code>的方式输出导致的。在打印过程中，可能不慎打印了空白字符。空白字符在网页上显示不出来，但在评测机进行比对的时候，就会认为错误。解决的方法是，在本地把代码改成<code>printf(&quot;%c0&quot;, c);</code>（我们假设正确的输出中不含 0，如果有冲突就换一个字符），这样如果输出了诸如<code>a0b0c00</code>的内容，就说明在最后一个 0 的前面还输出了不可见字符。打印了空白字符很可能是为字符变量赋值或初始化的逻辑有漏洞引起的，需要结合代码具体分析。</p>
<blockquote>
<p><strong>为什么这种不合法的情况也还是会输出啊？</strong></p>
</blockquote>
<p>没有按照题目要求输出内容，多数是代码逻辑的问题引起的。我们仅以第一次作业的“拓展字符”为例，看一种典型的错误。伪代码如下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">遍历字符串:</span><br><span class="line">    <span class="keyword">if</span> (当前字符为 <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;-&#x27;</span> 的前后同为 a-z 或 A-Z 或 <span class="number">0</span><span class="number">-9</span>) &#123;</span><br><span class="line">            <span class="type">int</span> d = 后字符 - 前字符;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= d; i++) &#123;</span><br><span class="line">                print 前字符 + i；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        原样输出字符;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>对于合法的可拓展字符，这段代码可以成功拓展。考虑 “g - a” 这类情况，程序会先连续进入两个<code>if</code>，但是<code>d</code>算出来为负数，所以<code>for</code>循环不执行，好像也符合要求。但是，一旦进了第一个<code>if</code>，则<code>else</code>分支原样输出将不被执行。这就是典型的逻辑漏洞。</p>
<p>另外，多数情况下的“运行超时”都是死循环导致的，这与代码逻辑也密不可分。</p>
<p>解决逻辑问题的常见手段是调试。如果你尚未掌握自己所用 IDE 的调试方法，不妨在程序的多个地方<strong>打印变量的值</strong>，观察程序的运行过程；如果需要判断是否进入某个分支、循环多少次等，也可以采用打印的方法。通过有效的<strong>工具手段和纸面演算</strong>解决程序逻辑问题，是每个人必备的基本功。当然，<strong>将代码提取成函数</strong>，也有助于缩小错误的范围。</p>
<h2 id="qsort函数详解"><a href="#qsort函数详解" class="headerlink" title="qsort函数详解"></a><code>qsort</code>函数详解</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>C 标准库 ```<stdlib.h>```中。函数原型如下：</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```C</span><br><span class="line">void qsort(void *base, </span><br><span class="line">           size_t num, </span><br><span class="line">           size_t width, </span><br><span class="line">           int(*cmp)(const void* e1, const void* e2));</span><br></pre></td></tr></table></figure></div>

<p><strong>该函数可实现的功能是：按照某种自定义的规则（ <code>cmp</code>函数），对数组<code>base</code>的 <code>num</code>个元素进行排序。</strong></p>
<p>想要理解<code>qsort</code>函数的具体实现方式，我们首先引入<strong>回调函数</strong>的概念：</p>
<blockquote>
<p>回调函数就是一个<strong>通过函数指针调用的函数</strong>。如果把函数的指针作为<strong>参数</strong>传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。</p>
</blockquote>
<p>显然<code>qsort</code>函数的四个参数中，**<code>cmp</code>参数就是回调函数，我们需要使用它来指导<code>qsort</code>函数的进行**。当<code>qsort</code>函数想要确定某两个元素的排列顺序时，会将这两个元素的指针 p1 和 p2 传入<code>cmp</code>函数进行元素值的比较：</p>
<ul>
<li><p>如果<code>cmp</code>函数返回值小于 0，则 p1 所指向元素会被排在 p2 所指向元素的前面；</p>
</li>
<li><p>如果<code>cmp</code>函数返回值等于 0，则 p1 所指向元素与 p2 所指向元素的顺序不确定（因为<strong>在某种意义上</strong>两个相同的元素谁在前谁在后都无伤大雅）；</p>
</li>
<li><p>如果<code>cmp</code>函数返回值大于 0，则 p1 所指向元素会被排在 p2 所指向元素的后面。</p>
</li>
</ul>
<p>可是，<strong>设计者在设计<code>qsort</code>函数时，不知道使用者会排序什么类型的元素，<code>qsort</code>函数自身也不清楚数组元素的类型是什么，但是它又必须实现元素两两之间的比较与交换。</strong>怎么办呢？最高效的方式就是从数据的存储入手，我们只需要<strong>将两个数据所占有的内存的内容交换【可以表述成：将属于 p1 的若干个抽屉的内容全部取出，将属于 p2 的若干个抽屉的内容全部取出，两者交换（详见猪脚说第一期😋）】</strong>便可实现任意类型元素的排序了。</p>
<p>需要交换的字节大小视具体情况而定，这时候参数<code>width</code>与<code>cmp</code>函数里的<code>void *</code>的作用就体现出来了。</p>
<p><strong><code>void *</code>称为通用指针</strong>，它就像一个垃圾桶，什么地址都可以往里扔，我们需要做的只是<strong>在自己写的<code>cmp</code>函数里对扔进来的地址做强制类型转换</strong>，再通过<code>width</code>参数规定所交换字节内容的大小，如<code>sizeof(int)</code>、<code>sizeof(char)</code>、  <code>sizeof(struct Node)</code>等，就可以使<code>qsort</code>函数按你所需地对目标数组元素进行排序。</p>
<p>现在我们以一段实操代码为例，感受<code>qsort</code>函数的使用方式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span>*)e1 &lt; *(<span class="type">int</span>*)e2) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 也可写成如下形式：</span></span><br><span class="line">    <span class="comment">// int *a = (int *)e1;</span></span><br><span class="line">    <span class="comment">// int *b = (int *)e2;</span></span><br><span class="line">    <span class="comment">// return (*a &lt; *b) ? -1 : 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    qsort(a, <span class="number">1000</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	特别要注意，部分教程在 cmp 中直接写</span></span><br><span class="line"><span class="comment">	`return *a - *b;`</span></span><br><span class="line"><span class="comment">	这是有巨大隐患的。具体原因请结合 int 能表示的范围有限思考。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p>通过我们自己写的<code>cmp</code>函数得知，当返回值小于 0（即 e1 所指向元素小于 e2 所指向元素时），e1 所指向元素会被排列在 e2 所指向元素的前面，且每次<strong>严格按照<code>int</code>类型所占有的字节宽度为限度</strong>进行交换，由此可实现数组 a 中所有元素由小到大排序。</p>
<p>当然，若想实现元素由大到小排序，只需将<code>cmp</code>中内容改写为<code>return (*(int*)e1 &gt; *(int*)e2) ? -1 : 1;</code></p>
<p>值得注意的是，若对于<code>double</code>类型数组进行由小到大的排序，我们需将<code>cmp</code>函数写为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span> <span class="comment">// 调用 fabs 需要包含此头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(*(<span class="type">double</span>*)e1 - *(<span class="type">double</span>*)e2) &gt; <span class="number">1e-7</span>)  <span class="comment">// 浮点数判断是否相等的方式：和极小量比较！</span></span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">double</span>*)e1 &gt; *(<span class="type">double</span>*)e2 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="学习结构体的意义在哪儿"><a href="#学习结构体的意义在哪儿" class="headerlink" title="学习结构体的意义在哪儿"></a>学习结构体的意义在哪儿</h2><blockquote>
<p>结构体的声明、定义和使用都相对简单，结合课件即可掌握。较新的内容是指向结构体的指针，<strong>建议忽略本质、注重语法和使用</strong>，随着一两周后链表的学习，很快即可上手。</p>
</blockquote>
<p>先来考虑这样一种需要处理的情形：一个班级里有若干学生，每个学生的学号、姓名、成绩三个信息需要被记录，现在我们需要对其中的某些学生的信息进行数据处理，声明结构体如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> number[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>显然，如果我们只需要记录一位学生，大可不必使用<code>struct student kid;</code>的定义形式，也不需要在后续访问变量时使用<code>kid.number</code>、<code>kid.name</code>、<code>kid.grade</code>如此繁杂的方式。我们只需要分别定义两个字符串数组、一个<code>int</code>类型变量即可，此时<strong>为了某种程度上的整洁而声明结构体类型、定义结构体变量反而显得多此一举</strong>。</p>
<p>可是，一个班级的整体数据肯定不能只由一位同学代表，往往我们需要处理多达上百个同学的数据，这时结构体的优势就开始显现。如果我们借助结构体变量的数组存储，那么只需要定义<code>struct student info[200];</code>后续每个学生的学号、姓名、成绩均可以作为成员储存在一个结构体变量中。</p>
<p>虽然我们仍可分别定义以下三个数组储存学生信息，每个学生的信息一一对应地储存于各数组中:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> stu_number[<span class="number">200</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> stu_name[<span class="number">200</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> stu_grade[<span class="number">200</span>];</span><br></pre></td></tr></table></figure></div>

<p>显然，若我们需要了解第 i+1 个学生的信息（假设数组下标从 0 开始），我们可以直接在<code>info[i]</code>这一结构体变量中全部寻得，也可以通过依次访问<code>stu_number[i]</code>、<code>stu_name[i]</code>、<code>stu_grade[i]</code>寻得。但前者不是更简洁方便、显得整体化吗？</p>
<p>因此，我们可以这样说：<strong>结构体存在的意义在有数组时才能体现。</strong></p>
<p>但是，如果只需完成类似于统计班级里有多少同学姓“王”、有多少同学成绩在 90 分以上这样的任务，大可以使用上述三个数组，用遍历的方法求得满足条件学生的总数，似乎数组完全可以代替结构体变量，并且不会导致任何工作量的增加。<strong>这是因为这样的任务并没有把学生的三个信息建立起联系，对某一个信息进行统计的时候可以完全不用顾虑其他信息与之对应。</strong></p>
<p>那么问题来了：当需要将学生的成绩按照<strong>由大到小</strong>的顺序输出，并同时输出每个同学对应的姓名与学号，使用哪种方式更好呢？</p>
<p>对于这个问题，刚刚学习了<code>qsort</code>函数的你想要进行实践。若你使用常规的数组存储，很快便遇到了困难。你并不知道<code>qsort</code>函数每次是对哪两个具体元素进行了比较，因此你单纯地将<code>stu_grade</code>数组排好了序，但其余两个数组与<code>stu_grade</code>数组的对应关系已经完全丧失，再无可能正确地输出每一个成绩所对应的姓名与学号。</p>
<p><strong>但如果用<code>qsort</code>函数对结构体进行排序呢？</strong></p>
<p>通过前文的讲解我们知道，我们的**<code>cmp</code>函数规则应该是对于每个结构体中的<code>grade</code>变量进行比较，但比较后的结果，是交换这个结构体变量所拥有的全部字节内容<strong>，而这个内容中既包含了<code>grade</code>、也包含了<code>number[]</code>和<code>name[]</code>，因此我们便做到了</strong>在保留原有成员变量一一对应关系的基础之上，对学生成绩进行了排序**。</p>
<p>综上所述，在排序这样一个实际例子中，结构体变量存在着至关重要的意义与价值。</p>
<p>当然，结构体还有许多的应用场景，比如大家后续所要学习的链表……这里我们就不再详述。</p>
<p>另值一提的是，请同学们看看如下代码是否正确：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> student*)e1-&gt;grade &lt; (<span class="keyword">struct</span> student*)e2-&gt;grade) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果<code>cmp</code>函数内容如上所示，则使用<code>qsort</code>函数排序会出现奇怪的错误。原因是因为**类型转换符<code>(type *)</code>的运算优先级低于箭头运算符<code>-&gt;</code>**。所以会先计算<code>e2-&gt;grade</code>，再去做类型转换。因此正确写法为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">struct</span> student*)e2)-&gt;grade &lt; ((<span class="keyword">struct</span> student*)e1)-&gt;grade) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="标准-C-库文件-I-O"><a href="#标准-C-库文件-I-O" class="headerlink" title="标准 C 库文件 I&#x2F;O"></a>标准 C 库文件 I&#x2F;O</h2><blockquote>
<p><strong>文件 I&#x2F;O，即文件的输入输出（Input &#x2F; Output）</strong>，几乎是每一个软件项目必备的模块。此外，我们称读取一个文件的内容为<strong>“读文件”</strong>，称编辑一个文件的内容为<strong>“写文件”</strong>。</p>
<p>以 macOS、Linux、Windows 为代表的多数操作系统，都引入了文件的概念。<strong>资源即文件。</strong>文件不仅包括屏幕上显示的一个个“文件”，还包括各类设备，如鼠标、键盘、打印机、屏幕（标准输出）、音响、U 盘等。一般来说，我们接触到的文件有两类 —— <strong>文本文件</strong>和<strong>二进制文件</strong>。前者，可以理解为<strong>字符构成的有序集合</strong>，如 filein.txt 文本文件、test.c 源代码文件；后者的典型代表是 a.exe 这类<strong>可执行文件</strong>。特别要注意，word 等工具编辑出的 .docx 文件属于二进制文件，是不能直接用我们接下来要讲到的文件操作函数处理的。</p>
<p>这门课程涉及的文件操作无非基本的读写，可以理解成<strong>程序中字符数组里的内容与文件间的交换</strong>。关于判断文件是否存在、文件的创建 &#x2F; 删除 &#x2F; 复制 &#x2F; 移动 &#x2F; 重命名等操作，感兴趣的同学可以自己了解。</p>
</blockquote>
<h3 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h3><p>操作系统中的文件构成一个<strong>树状结构</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets2/截屏2023-03-05 14.26.17.png"
                      alt="截屏2023-03-05 14.26.17" style="zoom:30%;" 
                >

<p>文件系统从一个根出发，<strong>每个文件夹就是树枝的分叉、每个文件就是树叶</strong>。这里的<strong>文件夹，就是目录</strong>。目录下可以包含若干文件，也可以为空。<strong>目录本身也是文件，是一种特殊的文件。目录中默认有两个隐藏的文件，文件名为<code>.</code>和<code>..</code>，分别表示自身和父目录。</strong></p>
<p>定位一个文件，就需要给出文件的路径。一种方法是从根开始，一路写到当前文件，如<code>D:\MyFiles\DSLearning\main.c</code>，这就表示打开 D 盘，进入 Myfiles 文件夹，进入 DSLearning 文件夹，就可以找到 main.c 文件。这种方式称为<strong>绝对路径</strong>。另一种方法是，以<strong>当前所在的目录为基准点，描述目标的相对位置</strong>。以上图为例，假设我们处在 gcctest 目录下，则 foo.c 文件可以直接写<code>foo.c</code>或<code>./foo.c</code>（因为<code>.</code>表示当前目录），libfoo.so 文件可以写成 <code>include/libfoo.so</code>，bank.c 文件可以写成<code>../IPCtest/bank.c</code>（因为<code>..</code>表示父目录）。</p>
<p>上文中提到“当前所在目录”，可以简单理解为<strong>程序运行的目录</strong>，即 .exe 文件所在的目录。一般来说，<strong>把文件和 .exe 文件放在一起，在函数调用时直接指定文件名即可</strong>。</p>
<h3 id="标准-C-库文件操作函数"><a href="#标准-C-库文件操作函数" class="headerlink" title="标准 C 库文件操作函数"></a>标准 C 库文件操作函数</h3><p>在学习 C 语言的第一天，我们就知道要<code>#include &lt;stdio.h&gt;</code>，std 即 standard，io 即上文所述。我们调用的<code>printf</code>等，正是 C 库提供的 I&#x2F;O 函数。调用以下函数，也应包含此头文件。</p>
<h4 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">FILE* <span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">	<span class="comment">// 打开文件，成功返回文件指针，出错返回 NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 关闭文件，成功返回 0，出错返回 -1</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>这里的“文件指针”<code>FILE*</code>，是在<code>&lt;stdio.h&gt;</code>中定义的一个<strong>结构体指针</strong>，该结构体包含了一个文件的各类信息。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此代码块内容仅供了解 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> cnt;			<span class="comment">// 剩余字节数</span></span><br><span class="line">    <span class="type">char</span> *ptr;			<span class="comment">// 下一个字符的位置</span></span><br><span class="line">    <span class="type">char</span> *base;			<span class="comment">// 缓冲区的位置</span></span><br><span class="line">    <span class="type">int</span> flag;			<span class="comment">// 文件访问模式</span></span><br><span class="line">    <span class="type">int</span> fd;				<span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="comment">// 还有很多</span></span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>获取了一个文件的文件指针，将其作为参数传递给其他函数，即可读写对应的文件。</strong>很多时候，文件打开会失败，则<code>fopen</code>返回<code>NULL</code>。因此，建议同学们以以下方式打开一个文件。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示范代码，这部分代码位于 main 中</span></span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen error&quot;</span>); <span class="comment">// 此函数在 &lt;stdio.h&gt; 中，能帮助输出错误信息</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);               <span class="comment">// 此函数在 &lt;stdlib.h&gt; 中，能强制结束程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>fopen</code>函数的第一个参数为<strong>文件路径</strong>，前文已经说明。第二个参数指定打开方式，常见的是<code>&quot;r&quot;</code>和<code>&quot;w&quot;</code>。前者表示读，后者表示写。<strong>读文件，要求文件已经存在</strong>，否则会打开失败；写文件，<strong>默认不存在则创建</strong>，如果存在且已经有内容，则<strong>清空</strong>后从头开始写。</p>
</li>
<li><p>程序运行时默认已经打开了三个文件 —— 标准输入<code>stdin</code>、标准输出<code>stdout</code>、标准错误<code>stderr</code>，这是三个文件指针，分别对应键盘、屏幕、屏幕。</p>
</li>
</ul>
<blockquote>
<p>使用<code>fopen</code>打开一个文件，则应当使用<code>fclose</code>关闭。当然做编程题的时候不写也没事。但是，这种规范操作仍应当强调，即便你可能并不会在意。当然，如果日后你因为忘记 close 或 free 而导致一个实际项目出现 bug，你一定会有所感悟的。</p>
</blockquote>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>通过<code>fopen</code>获得文件指针后，可以调用相关 I&#x2F;O 函数读写文件。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> size, FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 以行为单位读取文件指针 fp 对应的文件中的内容，存到字符数组 str 中，一次最多读取 size 个字符</span></span><br><span class="line">    <span class="comment">// 读取成功返回 str，读到文件末返回 NULL</span></span><br><span class="line">	<span class="comment">// 此函数会读取换行符，这与 gets 不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 1</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">fgets(str, <span class="number">1024</span>, <span class="built_in">stdin</span>);  <span class="comment">// 从键盘读取字符串，基本等价 gets，但会读进换行符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 2</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);              <span class="comment">// 如果打开失败则结束程序</span></span><br><span class="line"><span class="keyword">while</span> (fgets(buffer, <span class="number">1024</span>, fp) != <span class="literal">NULL</span>) &#123; <span class="comment">// 逐行读取文件内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line">	<span class="comment">// 功能同 scanf，只是多了参数指出输入来源于哪个文件</span></span><br><span class="line">	<span class="comment">// 读到文件末返回 EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 1</span></span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">fscanf</span>(<span class="built_in">stdin</span>, <span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c); <span class="comment">// 同 scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span></span><br><span class="line"><span class="comment">// 【特别提醒】读字符串的时候，不要加 &amp; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 2</span></span><br><span class="line"><span class="comment">// 从文件中读取空格分隔的若干学生的成绩（整数），求平均分并输出（一位小数）</span></span><br><span class="line"><span class="type">int</span> score, sum = <span class="number">0</span>, cnt = <span class="number">0</span>;                <span class="comment">// 很多同学都会忘记初始化</span></span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;scores.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;score) != EOF) &#123;</span><br><span class="line">    sum += score;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;average: %.1f\n&quot;</span>, sum * <span class="number">1.0</span> / cnt); <span class="comment">// 整数运算结果还是整数，你还记得这个细节吗</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 从 fp 所指的文件中读取一个字符，调用时可写 char c = fgetc(fp);</span></span><br><span class="line">	<span class="comment">// 读到文件末返回 EOF</span></span><br><span class="line">	<span class="comment">// 上一期猪脚说解释了为什么很多理应用 char 的地方写成了 int，这是合理且安全的</span></span><br><span class="line">	<span class="comment">// 我们自己在写程序时，也可以写 int c = fgetc(fp); printf(&quot;%c&quot;, c);</span></span><br></pre></td></tr></table></figure></div>

<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>这里仅提供函数原型，使用与非文件 I&#x2F;O 版本无异，只是多传入一个文件指针而已。<strong>写文件时，应指定<code>fopen</code>打开模式为<code>&quot;w&quot;</code>。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 将字符串 s 写入 fp 所指的文件中</span></span><br><span class="line">	<span class="comment">// 不同于 puts，此函数不会自动换行</span></span><br><span class="line">	<span class="comment">// fputs(s, stdout); 等价于 printf(&quot;%s&quot;, s);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line">	<span class="comment">// 类比 printf，当 fp 为 stdout 时等价于 printf</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 类比 putchar，当 fp 为 stdout 时等价于 putchar</span></span><br></pre></td></tr></table></figure></div>

<h3 id="文件偏移量"><a href="#文件偏移量" class="headerlink" title="文件偏移量"></a>文件偏移量</h3><p>我们在读写文件时，很自然地会认为我们是不断向文件尾部读取或添加内容。假如读完一个文件，还想再读一遍，一种做法是先 close 再 open。那我们能不能像实际编辑文件那样在读完一部分内容后，跳到前面再读一遍，或者是在文件中间插入内容呢。<strong>正如同使用 word 时的那个不断闪烁的光标，当我们操作文件的时候，FILE 结构体也在维护一个文件偏移量，它指的是距离文件头的字符数（准确是是字节数），文件的读写，都是从当前偏移量开始往后进行的。</strong></p>
<p><strong>使用<code>fopen</code>打开文件时，文件偏移量为 0，即光标位于文件头。</strong>当我们不断读取内容，光标不断后移，则文件偏移量不断增大。<strong>当文件偏移量等于文件字节数（一般等于文件字符数 &#x2F; 文件大小）的时候，就读到了文件末尾。</strong></p>
<p>一个很显然的想法是，<strong>不同的文件读取方式，每次文件偏移量的增量也不同。</strong>例如，刚打开一个文件（假设其中的内容足够多），连续调用两次**<code>fgetc</code>，则每次偏移量加一<strong>；调用</strong><code>fgets</code><strong>，则偏移量从第一行的第三个字符</strong>跳到行尾<strong>；再次</strong><code>fgets</code>，则偏移量跨过第二行跳到第二行行尾<strong>；进行<code>fscanf</code>，假设格式串为<code>&quot;(%d,%d)%c%lf&quot;</code>，且第三行的数据类型符合要求，则文件偏移量跳过 1 个字节</strong>吞掉**<code>(</code>、跳过 4 个字节<strong>读取</strong><code>int</code>、跳过 1 个字节<strong>吞掉</strong><code>,</code>、跳过 4 个字节<strong>读取</strong><code>int</code>、跳过 1 个字节<strong>吞掉</strong><code>)</code>、跳过 1 个字节<strong>读取</strong><code>char</code>、最后跳过 8 个字节<strong>读取</strong><code>double</code>。</p>
<p>介绍文件偏移量有助于我们理解文件的写入和读取顺序，如果想要<strong>手动设置文件偏移量</strong>，实现更加复杂的文件操作，请自行学习<code>fseek</code>等函数。</p>
<h2 id="第二次作业补充练习"><a href="#第二次作业补充练习" class="headerlink" title="第二次作业补充练习"></a>第二次作业补充练习</h2><p>1、<a class="link"   href="https://www.luogu.com.cn/problem/P1104" >按照结构体某一成员变量进行排序。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>2、<a class="link"   href="https://www.luogu.com.cn/problem/P1786" >稍微有一点难度的结构体排序。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第三期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%B8%89%E6%9C%9F/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets3/IMG_0781.jpg"
                      alt="IMG_0781" style="zoom:40%;" 
                >

<h2 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h2><blockquote>
<p><strong>注意</strong></p>
<p>在此课程中，使用结构体的时候请确保源代码文件是<code>.c</code>后缀而非<code>.cpp</code>。C++ 中的结构体和 C 完全不同，或者说，C++ 里的<code>struct</code>不是结构体，而是<strong>类（class）</strong>。C++ 和 C 语法相近，但很多细节存在差异，甚至可能导致截然不同的编译错误和运行结果 —— 水很深，请谨慎！</p>
</blockquote>
<h3 id="声明（declaration）"><a href="#声明（declaration）" class="headerlink" title="声明（declaration）"></a>声明（declaration）</h3><p>当我们写下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>    i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">char</span>   str[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>的时候，我们声明了一种<strong>自定义的结构体类型</strong>。其中，</p>
<ul>
<li><code>struct</code>是结构体<strong>关键字（key word）</strong>，<code>struct mystruct</code>是<strong>类型（type）</strong>。<ul>
<li><code>struct</code>不是任何类型，<strong>仅仅只是</strong>一个关键字；</li>
<li><code>struct mystruct</code>是类型，是和<code>int</code> <code>double</code> <code>char</code>等并列的<strong>数据类型</strong>，并且是<strong>复合数据类型</strong>。</li>
</ul>
</li>
</ul>
<p>但是，上文的写法单纯是<strong>类型的声明</strong>—— 它指明了这一新类型<strong>应该长什么样</strong> —— 含有一个<code>int</code>成员、一个<code>double</code>成员和一个<code>char</code>数组成员。于是我们有了一些新名词：成员变量（member variable）、字段（field）、域（field）、属性（attribute），从某种意义说上它们是等价的。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>上述声明的自定义复合数据类型为<code>struct mystruct</code>。这种类型写起来比较复杂，所以可以为之起一个别名</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span> <span class="title">Type</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>此后，<strong>任何用到<code>struct mystruct</code>类型的地方，都可以用别名<code>Type</code>指代</strong>。此外，我们也可以另外为指向该结构体的<strong>指针类型</strong>起一个别名</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span> * <span class="title">Type_ptr</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>当然，在<strong>声明结构体的同时</strong>就可以为新类型起别名</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125; m_type, * m_type_ptr;</span><br></pre></td></tr></table></figure></div>

<p>我们注意到，上述代码片段中<code>struct</code>关键字后并没有结构体原本的名字，这种<strong>无名</strong>的结构体，要么需要在声明的同时为之起别名，以便在后续程序中使用这一类型；要么必须在声明后立即定义相关变量（详见下文）。</p>
<blockquote>
<p><strong>补充</strong></p>
<p>我们用到的很多头文件中都进行了大量别名的声明。</p>
<ul>
<li><p><code>FILE</code>类型其实是一个结构体，为了使之更加<strong>贴近英文语义</strong>，所以为之起了别名</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// much more...</span></span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>size_t</code>是用于描述<strong>字节数</strong>或“大小”“长度”的类型，如<code>sizeof</code>的返回值、数组大小等</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">size_t</span>; <span class="comment">// 无符号长整型，用 %lu 输出</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>部分字符串处理函数中，会使用<code>ssize_t</code>类型表示<strong>字符串的长度</strong></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> <span class="type">ssize_t</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>操作系统中，为<strong>进程编号（Process ID）</strong>类型起了别名</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">pid_t</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><del>部分同学为了书写简便，为<code>long long</code>起了别名</del></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll; <span class="comment">// 好吧我承认这么写没毛病😋</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</blockquote>
<h3 id="定义（definition）"><a href="#定义（definition）" class="headerlink" title="定义（definition）"></a>定义（definition）</h3><p>当我们写下<code>int a = 10;</code>的时候，<strong>定义</strong>了一个整型<strong>变量</strong>。我们有了自己的类型<code>struct mytype</code>，为之声明了别名<code>Type</code>，为其指针声明了别名<code>Type_ptr</code>，我们也可以定义此类型的变量和数组。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytype</span>  <span class="title">t1</span>, <span class="title">t2</span>;</span> <span class="comment">// 两个结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytype</span>* <span class="title">t3</span>, <span class="title">t4</span>;</span> <span class="comment">// t3 是结构体的指针，t4 是结构体变量</span></span><br><span class="line"></span><br><span class="line">Type  t5, t6; <span class="comment">// 两个结构体变量</span></span><br><span class="line">Type* t7, t8; <span class="comment">// t7 是结构体的指针，t8 是结构体变量</span></span><br><span class="line"></span><br><span class="line">Type_ptr p1, p2, p3; <span class="comment">// 三个都是结构体的指针</span></span><br></pre></td></tr></table></figure></div>

<p>当然我们可以在<strong>声明结构体的同时</strong>定义变量和数组</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; a1, a2, arr[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></div>

<p><strong>如果声明的同时用<code>typedef</code>起了别名，则不能在其后直接定义变量。</strong></p>
<p>前面提到的无名结构体，如果没有在声明的同时为之起别名，则只能在声明的同时定义变量和数组</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">&#125; v1, v2, v3[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></div>

<p>很显然，我们在后续的程序中只能访问<code>v1</code> <code>v2</code> <code>v3</code>，而不能再定义此类型的变量或数组了 —— 因为这个类型没有名字。</p>
<blockquote>
<p><strong>注意：请严格区分声明与定义！</strong></p>
</blockquote>
<h3 id="前向声明"><a href="#前向声明" class="headerlink" title="前向声明"></a>前向声明</h3><p>我们知道<strong>声明结构体的时候不能嵌套</strong>，如<code>struct A &#123; struct A a; &#125;;</code>，因为这会造成无穷的嵌套，导致报错。那么假设<strong>两个结构体相互引用对方，并且均采用了类型别名的形式</strong>，会不会出现问题呢？</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    type_B *pb;</span><br><span class="line">&#125; type_A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    type_A *pa;</span><br><span class="line">&#125; type_B;</span><br></pre></td></tr></table></figure></div>

<p>当编译器读到结构体 A 的声明时，它发现需要有一个类型<code>type_B</code>的指针变量，然而<code>type_B</code>声明在后方，编译器暂时不知道其存在。假如把 A 和 B 的声明顺序对调，同样存在这一问题。</p>
<p>解决方法是使用<strong>前向声明（forward declaration）</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">type_B</span>;</span></span><br><span class="line">    <span class="comment">// 告诉编译器，我现在有一个 struct B 类型，它的别名是 type_B</span></span><br><span class="line">	<span class="comment">// struct B 具体长什么样，你自己到后面去找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    type_B *pb;    <span class="comment">// 编译器读到这里，它已经知道有 type_B 这个类型了，所以编译通过</span></span><br><span class="line">&#125; type_A;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    type_A *pa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="一定要记得初始化😭😭😭"><a href="#一定要记得初始化😭😭😭" class="headerlink" title="一定要记得初始化😭😭😭"></a>一定要记得初始化😭😭😭</h2><p>「为什么我会输出乱码啊」「为什么会多输出几个字符啊」「为什么字符串长度和追加出错了啊」……</p>
<p><strong>请再次检查，你是否对每一个变量、数组都初始化了。</strong></p>
<p>我们讨论初始化，并不是说什么时候需要初始化、什么时候可以不初始化，而是说<strong>任何情况</strong>、<strong>不论全局还是局部</strong>，都必须初始化！</p>
<ul>
<li><p>在任何地方都<strong>绝不允许</strong>写<code>int i;</code>而<strong>必须</strong>写<code>int i = 0;</code></p>
</li>
<li><p>在任何地方都<strong>绝不允许</strong>写<code>char str[100];</code>而<strong>必须</strong>写<code>char str[100] = &#123;0&#125;;</code></p>
</li>
<li><p>设我们有结构体</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>  在任何地方都<strong>绝不允许</strong>只写<code>struct A test[100];</code>而<strong>必须</strong>写</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">test</span>[100];</span></span><br><span class="line"><span class="comment">/*****************************</span></span><br><span class="line"><span class="comment">  以下初始化内容必须写！不许说麻烦。</span></span><br><span class="line"><span class="comment">*****************************/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;         <span class="comment">// 结构体数组必须初始化，且用循环初始化</span></span><br><span class="line">    test[i].i = <span class="number">0</span>;</span><br><span class="line">    test[i].d = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;      <span class="comment">// 一维数组必须初始化，用循环初始化或用 memset</span></span><br><span class="line">        test[i].s[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;      <span class="comment">// 二维数组必须初始化，且用循环初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++) &#123;</span><br><span class="line">            test[i].arr[j][k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>另外关于<code>memset</code>的使用，我们只需要知道</p>
<ul>
<li><p><strong>仅能将所有元素初始化为 0</strong></p>
</li>
<li><p>仅有如下的基本使用方法</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="type">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> l_array[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(l_array));</span><br><span class="line"></span><br><span class="line"><span class="comment">// memset 其他值是会出错的，可以试试如下代码</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">1</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p><strong>补充</strong></p>
<p>DevC++ 默认使用 C89 标准，此时局部变量仅能定义在函数开头。而我们很多时候见到的<code>for(int i = 0; ...)</code>这种在后续代码中定义变量的形式，是从 C99 标准开始才支持的。解决方法如下</p>
<ul>
<li><p>Step1：打开工具菜单</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets3/3-1.jpg"
                      alt="3-1" style="zoom:50%;" 
                >
</li>
<li><p>Step2：在下拉菜单中选择“编译选项”</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets3/3-2.PNG"
                      alt="3-2" style="zoom:20%;" 
                >
</li>
<li><p>Step3：勾选“编译时加入以下命令”，加入<code>-std=c99 -Wall</code>，点击“确定”。这两个选项，前者指定了使用 C99 标准，后者能帮我们输出更多警告信息。</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets3/3-3.PNG"
                      alt="3-3" style="zoom:25%;" 
                ></li>
</ul>
</blockquote>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a><code>sizeof</code></h2><p>上文提到，<code>sizeof</code>返回对象的字节数大小，类型为<code>size_t</code>，可用<code>%lu</code>输出，用<code>%d</code>一般没有问题但是会给警告。</p>
<ul>
<li><h3 id="sizeof-基本类型或其变量"><a href="#sizeof-基本类型或其变量" class="headerlink" title="sizeof 基本类型或其变量"></a><code>sizeof</code> 基本类型或其变量</h3>  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>);   <span class="comment">// int 的大小一般都是 4 个字节</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;    <span class="comment">// 如果想要使用与机器类型无关的整型变量，&lt;stdint.h&gt; 中有很多可供选择</span></span><br><span class="line"><span class="keyword">sizeof</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">char</span>*);    <span class="comment">// 32 位机器的指针大小为 4 字节，64 位机器则为 8 字节</span></span><br><span class="line"><span class="type">double</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(p);        <span class="comment">// 指针大小固定，与所指的类型无关</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><h3 id="sizeof-结构体类型或其变量"><a href="#sizeof-结构体类型或其变量" class="headerlink" title="sizeof 结构体类型或其变量"></a><code>sizeof</code> 结构体类型或其变量</h3>  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> test);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">t1</span>;</span></span><br><span class="line"><span class="keyword">sizeof</span>(t1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，struct 的 size 并不一定等于其各个成员的 size 之和</span></span><br><span class="line"><span class="comment">// 具体原因可以自行百度 “结构体字节对齐”，此处不要求掌握</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><h3 id="sizeof-数组名"><a href="#sizeof-数组名" class="headerlink" title="sizeof 数组名"></a><code>sizeof</code> 数组名</h3>  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 定义整型数组</span></span><br><span class="line"><span class="type">int</span> *p = arr;       <span class="comment">// 定义指针管理数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(arr);    <span class="comment">// sizeof(数组名)，返回数组总字节数，即 100 * sizeof(int)</span></span><br><span class="line"><span class="keyword">sizeof</span>(p);      <span class="comment">// sizeof(指向数组的指针)，返回指针本身大小，与机器位数有关</span></span><br><span class="line"><span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// sizeof(数组元素)，返回单个元素的大小，即 sizeof(int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *q    = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(str);          <span class="comment">// 返回 6</span></span><br><span class="line"><span class="keyword">sizeof</span>(q);            <span class="comment">// 返回 4(32位机器) 或 8(64位机器)</span></span><br><span class="line"><span class="built_in">strlen</span>(str);          <span class="comment">// 返回 5</span></span><br><span class="line"><span class="built_in">strlen</span>(q);            <span class="comment">// 返回 5</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><blockquote>
<p>在一些较复杂的项目中，除了声明必要的结构体之外，往往需要借助多维数组、并在函数原型中声明多维数组，特别是二维数组。使用二维数组时有很多易忽略的点，我们希望在接下来的内容中帮助大家更深地了解二维数组的本质，并尽量减少编程时 bug 的产生。</p>
</blockquote>
<h3 id="二维数组的存储"><a href="#二维数组的存储" class="headerlink" title="二维数组的存储"></a>二维数组的存储</h3><p><strong>二维数组，也可以看成一个一维数组，这个一维数组中的每个元素都是一个一维数组。</strong></p>
<p>因此，若将二维数组的每一行当做一个存储一维数组的元素，所有行汇集成一个一维数组，每个一维数组中各元素是连续存储的，那么就很容易理解：二维数组中的各元素在内存中是<strong>按照行优先的原则，进行连续存储。</strong></p>
<p>例如，我们定义数组<code>a[2][6]</code>，那么其在内存中从某一地址开始，存储情况如下图：</p>
<p>![截屏2023-03-10 13.31.04](&#x2F;images&#x2F;assets3&#x2F;截屏2023-03-10 13.31.04.png)</p>
<p>那么该数组中某个元素<code>a[i][j]</code>的地址<code>&amp;a[i][j]</code>可以通过如下方式求得：<code>首地址 + 单个元素长度 * (总列数 * i + j)</code>。</p>
<p>由此可知，若想知道该二维数组中某一元素的地址，就必须知道该数组的数据类型和列数，这样才能实现对二维数组中某一个元素的精确访问，<strong>这也是为什么我们在声明二维数组以及把一个二维数组当作形参传递时，必须指定列数，否则就会报错。</strong></p>
<p>我们来看如下几行代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a[][], <span class="type">int</span> b)</span>;    <span class="comment">// error：没有指定列数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a1[][], <span class="type">int</span> b)</span>;   <span class="comment">// error：没有指定列数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a2[<span class="number">2</span>][], <span class="type">int</span> b)</span>;  <span class="comment">// error：没有指定列数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a3[<span class="number">3</span>][<span class="number">4</span>], <span class="type">int</span> b)</span>; <span class="comment">// right</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a4[][<span class="number">5</span>], <span class="type">int</span> b)</span>;  <span class="comment">// right</span></span><br></pre></td></tr></table></figure></div>

<h3 id="二维数组的指针访问"><a href="#二维数组的指针访问" class="headerlink" title="二维数组的指针访问"></a>二维数组的指针访问</h3><blockquote>
<p>在此，我们推荐两种访问二维数组的方法，但不代表访问它的方法仅有如下两种。</p>
</blockquote>
<h4 id="指向元素的指针"><a href="#指向元素的指针" class="headerlink" title="指向元素的指针"></a>指向元素的指针</h4><p>这种方法最简单直接，现有如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">6</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure></div>

<p>在此种定义下，访问数组<code>a</code>中的每一个元素只需要将<code>p</code>指针依次往后推，利用 4.1 中求某元素地址的方式即可实现精确访问。在该例子中，我们便知道了<code>&amp;a[i][j] == p + sizeof(int) * (6 * i + j)</code>。</p>
<h4 id="列指针"><a href="#列指针" class="headerlink" title="列指针"></a>列指针</h4><p>这种方式通过定义指针指向二维数组的<strong>某一行的第一列</strong>，再在此基础上访问该行的某个元素，现有如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">6</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> *p[<span class="number">2</span>] = &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;; <span class="comment">// 当然，你也可以使用循环来为这个指针数组赋值</span></span><br></pre></td></tr></table></figure></div>

<p>由此，指针数组<code>p</code>中第一个元素为二维数组<code>a</code>中第一行第一个元素的地址（意即第一行的首地址），第二个元素为二维数组<code>a</code>中第二行第一个元素的地址（意即第二行的首地址）。</p>
<p>在该例子中，我们便知道了<code>&amp;a[0][j] == p[0] + sizeof(int) * j</code> 以及<code>&amp;a[1][j] == p[1] + sizeof(int) * j</code>。</p>
<h3 id="二维数组的形参传递"><a href="#二维数组的形参传递" class="headerlink" title="二维数组的形参传递"></a>二维数组的形参传递</h3><blockquote>
<p>我们在 4.1 中已经提到，当我们把一个二维数组作为形参传递进入另一个函数里（例如有些同学做第二次作业的五子棋危险判断）时，<strong>一定要指定列数</strong>。在此我们也推荐两种写法。</p>
</blockquote>
<h4 id="数组法"><a href="#数组法" class="headerlink" title="数组法"></a>数组法</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a[][<span class="number">6</span>], <span class="type">int</span> row)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    print_two_dim(a,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>请注意：以下传递方式无效，不能将二维数组的真实行数传入函数中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a[<span class="number">2</span>][<span class="number">6</span>])</span>;</span><br></pre></td></tr></table></figure></div>

<p>原因是：如同一维数组的形参传递一样，<strong>传入的数组被转化为指针，函数内部无法获取该数组大小。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下两种传递方式等效</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_one_dim1</span><span class="params">(<span class="type">int</span> num[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_one_dim2</span><span class="params">(<span class="type">int</span> num[<span class="number">20</span>])</span>; <span class="comment">// 20在这里是无效的</span></span><br></pre></td></tr></table></figure></div>

<h4 id="数组指针法"><a href="#数组指针法" class="headerlink" title="数组指针法"></a>数组指针法</h4><blockquote>
<p>数组指针指向二维数组，有些教材称这种指针为<strong>行指针</strong>，顾名思义就是操纵一行的指针。</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">6</span>], <span class="type">int</span> row)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数组名为 a，表示首元素的地址</span></span><br><span class="line">    <span class="comment">// 二维数组的首元素是二维数组的第一行</span></span><br><span class="line">    <span class="comment">// 所以传递进函数的 a ，相当于第一行的地址，是一维数组的地址</span></span><br><span class="line">    print_two_dim(a,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述代码中，我们用数组指针来接收，也必须指定有 6 列，<strong>这是为了告诉内存，第二行从哪儿开始存放。</strong></p>
<p>因此，形参中的<code>(*a)[6]</code>中，**<code>a</code>指向二维数组第一行的地址。**<code>*a</code>就是二维数组第一个元素的地址，<code>**a</code>才能找到第一个元素的具体值，为 1。</p>
<h3 id="char型二维数组"><a href="#char型二维数组" class="headerlink" title="char型二维数组"></a><code>char</code>型二维数组</h3><p>我们在 4.1 中提到，二维数组的存储方式为按行优先，连续存储。另一层意思就是说，二维数组里每一行所代表的一维数组是连续的，并非毫无关联。如果你并没有领略到这一层意思，那么请看如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> test[<span class="number">2</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        test[<span class="number">0</span>][i] = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        test[<span class="number">1</span>][i] = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">    test[<span class="number">1</span>][i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, test[<span class="number">0</span>]);</span><br><span class="line">    test[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, test[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>代码的运行结果：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">abcdefghijklmnopqrstuvwxyzabcdefg</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure></div>

<p>诶！按照惯性思维，你会发现：我第一次打印时明明只想让他打印出二维数组第一行的值，<strong>为啥它把第二行的值一起打印出来了呢？</strong></p>
<p>相信大家一定知道，<code>printf(&quot;%s&quot;,a)</code>这样一段代码，其本质上是从字符串数组<code>a</code>的首地址开始打印，知道遇到字符串终止字符（也就是<code>&#39;\0&#39;</code>）停止。</p>
<p>那么再回到上述代码，由于二维数组的顺序存储特性，<code>test[1][0]</code>元素是紧跟在<code>test[0][25]</code>元素之后的，也就是说当输出<code>test[0][25]</code>元素时，系统发现该元素之后并不是<code>&#39;\0&#39;</code>，而是一个有着具体值的字符，于是就会接着输出，直到遇到<code>&#39;\0&#39;</code>为止。于是，我们通过让<code>test[1][0]=&#39;\0&#39;</code>，成功地让输出停留在<code>test[0][25]</code>的位置上，实现了只输出第一行的目的。</p>
<p>这也告诉我们，当我们使用<code>char</code>类型二维数组时，首先需要初始化，<strong>且尽量不要让该数组的列数小到恰好等于我们想让它存储的数据个数</strong>，否则就会像上述例子一样，每一行末尾没有<code>&#39;\0&#39;</code>，在进行后续的按行操作时出现 bug。</p>
<p><em>Author: diandian, Riccardo(Version Grey)</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第五期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%BA%94%E6%9C%9F/</url>
    <content><![CDATA[<blockquote>
<p>在这一部分中，我们会针对同学们问的比较多的题目（或者易错点较多的题目），给出若干的代码。大家可以参考题解中的代码，<strong>学习一下代码规范【好好看看哪里要空格哪里要空行！！！】</strong>，对比一下自己的代码与我们给出的参考代码，孰优孰劣,亦或者代码中的某些段落可以打包成一个固定模版，在后续作业、考试中使用。</p>
</blockquote>
<p><strong>如果针对这些题，同学们有更好更简洁的方法，欢迎来找助教讨论分享，助教请喝奶茶。</strong></p>
<h2 id="表达式计算（支持空格，连乘，连除）"><a href="#表达式计算（支持空格，连乘，连除）" class="headerlink" title="表达式计算（支持空格，连乘，连除）"></a>表达式计算（支持空格，连乘，连除）</h2><p>法一：先计算乘除，再加减（先计算表达式中所有的乘除，再从左到右进行加减）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, b[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, op[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len, i,j = <span class="number">0</span>, k = <span class="number">0</span>, cnt;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans, num[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">    	<span class="comment">// 虽然数字都是int型，但int型的数字相加和相乘可能超int范围</span></span><br><span class="line">    </span><br><span class="line">    gets(a);</span><br><span class="line">    len = <span class="built_in">strlen</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            b[k++] = a[i];</span><br><span class="line">    &#125; <span class="comment">// 将清除空格后的字符串保存在数组b中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; b[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; b[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            num[j] = <span class="number">10</span> * num[j] + b[i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 非常好用的从一串字符中读取整数数字的方法</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            op[j] = b[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 将数字与运算符分别存进两个数组，一个数字对应一个运算符，下标一一对应</span></span><br><span class="line">    </span><br><span class="line">    cnt = j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            num[i] = num[i] * num[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                op[j] = op[j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                num[j] = num[j + <span class="number">1</span>];</span><br><span class="line">            i--;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若遇到*，则计算当前两个数的乘积，保存到*前的数，后面的数与运算符往前移。</span></span><br><span class="line">        <span class="comment">// 由于前移了，则下次进入循环时仍然该从当前位开始，为了抵消i++的影响，执行</span></span><br><span class="line">        <span class="comment">// 一次i--，同时总数cnt--</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            num[i] = num[i] / num[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                op[j] = op[j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                num[j] = num[j + <span class="number">1</span>];</span><br><span class="line">            i--;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ans = num[<span class="number">0</span>]; <span class="comment">// 此时表达式中的乘除已全部处理完毕，接下来从左到右执行加减运算即可。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            ans += num[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            ans -= num[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>法二：后悔法（读入什么就运算什么，读到乘除往前反悔）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, x[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, t[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, a[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, j = <span class="number">0</span>, k = <span class="number">0</span>, k1 = <span class="number">1</span>, len, len1, ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    gets(s);</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            x[k++] = s[i];</span><br><span class="line">    &#125; <span class="comment">// 将清除空格后的字符串保存在数组x中</span></span><br><span class="line">    </span><br><span class="line">    len1 = <span class="built_in">strlen</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len1 - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; x[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            a[j] = <span class="number">10</span> * a[j] + x[i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 非常好用的从一串字符中读取整数数字的方法</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            t[j] = x[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="comment">// 将数字与运算符分别存进两个数组，一个数字对应一个运算符，下标一一对应</span></span><br><span class="line">    &#125;     <span class="comment">// 不需要考虑末尾的“=”，因此循环结束条件为i&lt;len1-1</span></span><br><span class="line">    </span><br><span class="line">    ans += a[<span class="number">0</span>]; <span class="comment">// 记录第一个数字为当前运算结果</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = ans - a[i] + a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                a[i + <span class="number">1</span>] = a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="comment">// 特判，第一个符号为乘号</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                    ans = ans - a[i] + a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 1+2*3，先算1+2得到3，读到*后，往前反悔，</span></span><br><span class="line">                    <span class="comment">// 于是当前预算结果为3-2+2*3，后续思路相同</span></span><br><span class="line">                    a[i + <span class="number">1</span>] = a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                    <span class="comment">// 对于连乘，1+2*3*4，运算到1+2*3为7时，再读到乘号，需要用变量k1记录</span></span><br><span class="line">                    <span class="comment">// 连续乘or除多少次，反悔时才能找到相应位置，于是现在运算结果为7-6+6*4，</span></span><br><span class="line">                    <span class="comment">// 后续思路相同</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    ans = ans + a[i] - a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                    a[i + <span class="number">1</span>] = a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    ans *= a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    ans *= a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = ans - a[i] + a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                a[i + <span class="number">1</span>] = a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i-k1] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                    ans = ans - a[i] + a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                    a[i + <span class="number">1</span>] = a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    ans = ans + a[i] - a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                    a[i + <span class="number">1</span>] = a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    ans /= a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    ans /= a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            ans += a[i + <span class="number">1</span>];</span><br><span class="line">            k1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            ans -= a[i + <span class="number">1</span>];</span><br><span class="line">            k1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>法三：使用<code>scanf</code>函数可以自动消除空格，同时每次将一个数字和一个运算符成对读入，直接进行运算。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">0</span>, num2, num3;</span><br><span class="line">    <span class="type">char</span> op1 = <span class="string">&#x27;+&#x27;</span>, op2, op3; <span class="comment">// 这样初始化是为了输入第一个数num2时，可以实现0+num2的效果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>,&amp;num2, &amp;op2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (op2 == <span class="string">&#x27;*&#x27;</span> || op2 == <span class="string">&#x27;/&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">// 当输出乘除时，继续往后输入，直到退出连乘/除为止</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>, &amp;num3, &amp;op3);</span><br><span class="line">            <span class="keyword">if</span> (op2 == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                num2 = num2 * num3;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2 = num2 / num3;</span><br><span class="line">            op2 = op3; <span class="comment">// 更新op2为当前输入的符号</span></span><br><span class="line">        &#125; <span class="comment">// 此时已经退出连乘/除模式，往后直接执行加减操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (op1 == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            num1 = num1 + num2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op1 == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            num1 = num1 - num2;</span><br><span class="line">        </span><br><span class="line">        op1 = op2; <span class="comment">// 更新op1为当前当前输入的符号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (op1 == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num1);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="超长正整数的减法"><a href="#超长正整数的减法" class="headerlink" title="超长正整数的减法"></a>超长正整数的减法</h2><p>这道题的易错点在于：</p>
<p>1、连续借位相减（例如执行 10000 - 1 的运算）；</p>
<p>2、有些同学使用长度和字典序关系判断两数大小，这是正确且高效的方法，但请注意<code>strcmp()</code>函数的返回值；</p>
<p>3、注意<code>0</code>和<code>&#39;0&#39;</code>的区别，对其他数字也是同理。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str_a[M] = &#123;<span class="number">0</span>&#125;, str_b[M] =&#123; <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num_a[M] = &#123;<span class="number">0</span>&#125;, num_b[M] = &#123;<span class="number">0</span>&#125;, num_c[M] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len_a, len_b;</span><br><span class="line">    <span class="type">int</span> i, j, k, n, f = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    gets(str_a);</span><br><span class="line">    gets(str_b);</span><br><span class="line">    len_a = <span class="built_in">strlen</span>(str_a);</span><br><span class="line">    len_b = <span class="built_in">strlen</span>(str_b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (len_a &lt; len_b)</span><br><span class="line">        k = len_b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        k = len_a; <span class="comment">// 让k为两数组的最大长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (len_a &gt; len_b)</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len_a == len_b)</span><br><span class="line">        n = <span class="built_in">strcmp</span>(str_a, str_b) &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n = <span class="number">-1</span>; <span class="comment">//给n赋值，在之后判断需不需要打印负号</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = len_a - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--, j++)</span><br><span class="line">        num_a[j] = str_a[i] - <span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">    <span class="comment">// 很经典的将字符&#x27;0&#x27;转换成数字0的方法，且同时实现数组反序存储</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = len_b - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--, j++)</span><br><span class="line">        num_b[j] = str_b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123; <span class="comment">// 判断n是为了让程序永远执行大数减小数</span></span><br><span class="line">            <span class="keyword">if</span> (num_a[i] - num_b[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                num_c[i] = num_a[i] - num_b[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                num_c[i] = num_a[i] + <span class="number">10</span> - num_b[i];</span><br><span class="line">                num_a[i+<span class="number">1</span>]--;</span><br><span class="line">            &#125; <span class="comment">// 借位的判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (num_b[i] - num_a[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                num_c[i] = num_b[i] - num_a[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                num_c[i] = num_b[i] + <span class="number">10</span> - num_a[i];</span><br><span class="line">                num_b[i + <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num_c[i])</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 只要num_c数组中不是0，则把f赋值为1，目的只是为了消除</span></span><br><span class="line">            <span class="comment">// 打印出的数组中的前导0，所以不用重新赋值，不用考虑“新的开始”</span></span><br><span class="line">        <span class="keyword">if</span> (f || i == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num_c[i]); </span><br><span class="line">        <span class="comment">// 如果结果本身就是0，需要输出一个0，所以再加一个i==0的条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="全排列数的生成"><a href="#全排列数的生成" class="headerlink" title="全排列数的生成"></a>全排列数的生成</h2><p>这道题可以用递归或非递归实现，具体方法我们在上机的时候已经统一讲过了，这里不作赘述，直接上码！</p>
<p>法一：递归与回溯法</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tape</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *str1, <span class="type">int</span> *str2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = l; i &lt;= r; i++)</span><br><span class="line">        str1[i] = str2[i];</span><br><span class="line">&#125; <span class="comment">// 注意回溯时，一定不是简单的交换两个位置的数字，而是把这两个位置中的整段数组都进行回溯</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125; <span class="comment">// 自定义交换函数怎么写，还记得吗？</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">comb</span><span class="params">(<span class="type">int</span> *str, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            swap(&amp;(str[l]), &amp;(str[i]));</span><br><span class="line">            tape(l, r, a, str);</span><br><span class="line">            comb(str, l+<span class="number">1</span>, r);</span><br><span class="line">            tape(l, r, str, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, x, a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    comb(a, <span class="number">0</span>, x<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>法二：非递归法，从右往左找到第一对递增数，以该对数的第一个数为交换对象，再从右往左找第一个比该对象大的数，相交换，再把该位置后的数组反序。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">11</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_rev</span><span class="params">(<span class="type">int</span> s[], <span class="type">int</span> hi, <span class="type">int</span> low)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> ( ; hi &gt; low; low++, hi--) &#123;</span><br><span class="line">    temp = s[low];</span><br><span class="line">    s[low] = s[hi];</span><br><span class="line">    s[hi] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//该自定义函数可实现把数组反序，可以直接作为模版使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, temp, flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 从右往左找一对递增的数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果没找到，说明所有全排列的结果已经输出完毕</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (j = n; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[i]) &#123;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        str_rev(a, n, i + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="字符串替换（新）"><a href="#字符串替换（新）" class="headerlink" title="字符串替换（新）"></a>字符串替换（新）</h2><p>这道题的注意事项有：</p>
<p>1、关于文件的输入输出，文件名写对，<code>fgets()</code>函数的参数顺序写对；</p>
<p>2、不可以把输入文件里的所有字母都变成小写后再判断，因为不符合替换条件的字母需要原样输出；</p>
<p>3、如果要使用<code>strcat()</code>和<code>strcpy()</code>等函数完成此题，一定要判断好起始位置。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">502</span>] = &#123;<span class="number">0</span>&#125;, b[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, str[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, flag, len;</span><br><span class="line">    </span><br><span class="line">    FILE *in = fopen(<span class="string">&quot;filein.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE *out = fopen(<span class="string">&quot;fileout.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(in)) != EOF)</span><br><span class="line">        str[i++] = c;<span class="comment">// 将文件中所有字符统一存进数组</span></span><br><span class="line">    str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    len = (<span class="type">int</span>)<span class="built_in">strlen</span>(str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        flag = <span class="number">1</span>; <span class="comment">// “新的开始”，每次都让flag置为1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">tolower</span>(str[i]) != <span class="built_in">tolower</span>(a[<span class="number">0</span>])) </span><br><span class="line">            <span class="comment">// 判断大小写是否契合，直接借用此函数即可，若参数为大写字母，则其返回值为小写字母</span></span><br><span class="line">            fputc(str[i], out);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; a[j] != <span class="string">&#x27;\0&#x27;</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">tolower</span>(str[i+j]) != <span class="built_in">tolower</span>(a[j])) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="comment">// 一旦出现不匹配的位置，立即让flag为0并退出上一层循环（即for循环）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(b, out);</span><br><span class="line">                i = i + (<span class="type">int</span>)<span class="built_in">strlen</span>(a) - <span class="number">1</span>; <span class="comment">// 减1是为了抵消下一次进循环的i++</span></span><br><span class="line">            &#125; <span class="comment">// 如果与in数组匹配，则直接把out数组输出到文件里</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fputc(str[i], out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="加密文件"><a href="#加密文件" class="headerlink" title="加密文件"></a>加密文件</h2><p>此题注意事项包括但不限于：</p>
<p>1、很多同学在判断字符是否出现过时，喜欢使用循环遍历的方法，这样做固然没问题，但在数据规模较大时比较耗费时间，特别是在大作业的时候，大家感触会更深。所以可以使用<code>used</code>数组（类似于哈希表思想）进行判断，在大作业的时候大家也可以感受到不同算法所带来的效率差别；</p>
<p>2、使用数组下标的时候要统一，不要一会儿是 97-122，一会儿是 0-25，一会儿是 ‘A’-‘Z’，这样会显得很混乱，容易出错；</p>
<p>3、大家有时喜欢卡着真实的元素个数去定义数组的大小，其实完全没必要，建议开大一些（至少开大个一倍左右吧），这样能有效避免数组越界。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, key[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;, str[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, pst = <span class="number">0</span>, ch, used[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    FILE *in, *out;</span><br><span class="line">    </span><br><span class="line">    in = fopen(<span class="string">&quot;encrypt.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    out = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[str[i] - <span class="string">&#x27;a&#x27;</span>]) &#123; <span class="comment">// 如果出现过，则不写入key数组中</span></span><br><span class="line">            key[pst++] = str[i];</span><br><span class="line">            used[str[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>; <span class="comment">// 如果该字母以出现过，则对应used数组位置赋为1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="string">&#x27;z&#x27;</span>; i &gt;= <span class="string">&#x27;a&#x27;</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[i - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            key[pst++] = i;</span><br><span class="line">    &#125; <span class="comment">// 倒序加入未出现过的字母形成最终密钥</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(in)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(ch))</span><br><span class="line">            ch = key[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        fputc(ch, out);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="小型图书管理系统"><a href="#小型图书管理系统" class="headerlink" title="小型图书管理系统"></a>小型图书管理系统</h2><p>本题一种简单暴力的做法是，每进行一次操作，都将所有图书重新排序。另有以下注意事项：</p>
<p>1、在维护图书信息时，利用变量<code>cnt</code>保存图书总数，并且只针对下标小于<code>cnt</code>的元素进行操作；</p>
<p>2、一些同学使用记事本查看输出结果时，发现输出的信息不能对齐，这是由于记事本中默认字体中的字符宽度是不相等的，可以切换记事本字体，例如<code>Consolas</code>；</p>
<p>3、有些同学在执行清除操作时，喜欢直接<code>memset</code>，但全是<code>&#39;\0&#39;</code>的字符串也会进入<code>qsort</code>排序中，且<code>&#39;\0&#39;</code>的字典序是最小的，因此永远会被排在前面，如果在输出时不加以判断，则会在文件最开始输出很多空内容。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">books</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">51</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">21</span>];</span><br><span class="line">    <span class="type">char</span> press[<span class="number">31</span>];</span><br><span class="line">    <span class="type">char</span> date[<span class="number">11</span>];</span><br><span class="line">&#125;book[<span class="number">501</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p, <span class="type">const</span> <span class="type">void</span> *q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(((<span class="keyword">struct</span> books*)p)-&gt;name, ((<span class="keyword">struct</span> books*)q)-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, i  =<span class="number">0</span>, op;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    FILE *in = fopen(<span class="string">&quot;books.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE *out = fopen(<span class="string">&quot;ordered.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(in, <span class="string">&quot;%s %s %s %s&quot;</span>, book[cnt].name, book[cnt].author, </span><br><span class="line">                 book[cnt].press, book[cnt].date) != EOF) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    qsort(book, cnt, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> books), cmp); <span class="comment">// 输入完就立即进行排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s %s %s %s&quot;</span>, book[cnt].name, book[cnt].author, </span><br><span class="line">                      book[cnt].press, book[cnt].date);</span><br><span class="line">                cnt++;</span><br><span class="line">                qsort(book, cnt, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> books), cmp);</span><br><span class="line">            <span class="comment">// 插入后进行排序，如果没有此步骤，则后续查找时，可能导致输出的图书顺序有误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, temp);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strstr</span>(book[i].name, temp) != <span class="literal">NULL</span>) <span class="comment">// 使用strstr函数直接进行查找</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%-50s%-20s%-30s%-10s\n&quot;</span>, book[i].name, </span><br><span class="line">                           book[i].author, book[i].press, book[i].date);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, temp);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strstr</span>(book[i].name, temp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                        book[j] = book[j + <span class="number">1</span>]; <span class="comment">// 将后续图书全部前移，即可实现删除功能</span></span><br><span class="line">                    i--; <span class="comment">// 因为前移，需抵消下次进循环的i++影响</span></span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    qsort(book, cnt, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> books), cmp); <span class="comment">// 最后再排一次序，以防万一</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(out, <span class="string">&quot;%-50s%-20s%-30s%-10s\n&quot;</span>, book[i].name, </span><br><span class="line">                book[i].author, book[i].press, book[i].date); <span class="comment">// 对齐方式应该如此写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="面向对象的数据结构-——-数组篇"><a href="#面向对象的数据结构-——-数组篇" class="headerlink" title="面向对象的数据结构 —— 数组篇"></a>面向对象的数据结构 —— 数组篇</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><blockquote>
<p>同学们在解决实际问题时，往往会在<strong>问题理解</strong>和<strong>编程实现</strong>两方面遇到困难。我们以第三次作业第二题“空闲空间分配”为例。</p>
<p><strong>题意理解的问题形如</strong></p>
<ul>
<li>查找目标的规则是什么，我要如何判断</li>
<li>如果没找到，我要怎么标记</li>
<li>如果空间一点不剩，我需不需要特判</li>
</ul>
<p><strong>编程实现的问题形如</strong></p>
<ul>
<li>新的节点如何申请</li>
<li>删除节点怎么写，哪些指针要修改</li>
<li>什么是循环链表，怎么遍历</li>
</ul>
<p>事实上，这两大问题对应我们程序中的两大部分</p>
<ul>
<li>主函数<code>main</code>的结构，如各种循环和分支的嵌套，这是我们解决问题的逻辑</li>
<li>每个循环或分支内的具体语句，如一次赋值、一次拷贝、一次遍历等</li>
</ul>
<p>这两大部分，也就对应两类常见 bug</p>
<ul>
<li>漏了一种<code>if</code>的情况，忘记把<code>flag</code>重新置为 0 等<strong>逻辑问题</strong></li>
<li>访问了空指针，下标数错，忘加 ‘\0’ 等<strong>基本操作问题</strong></li>
</ul>
<p>事实上，如果把所有代码都写在<code>main</code>里，我们很难分清也很难定位具体的 bug。一种做法是<strong>封装一些函数</strong>，这种做法简化了代码，增强了代码的<strong>可复用性</strong>，但不妙之处在于，我们每做一道题，就要把这些内容重新写一遍，因为每道题用到的数据类型是不同的 —— <strong>这道题的<code>struct</code>里的数据项只有一个<code>int</code>，而下一道题变成了一个<code>double</code>和一个<code>char[20]</code>，我们就需要把所有的函数都修改一遍</strong>。</p>
<p>所以，单纯地封装<code>insert_node</code> <code>delete_node</code>等函数，仍然不是最理想的做法。</p>
</blockquote>
<h3 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h3><p>今天我们仅讨论线性表中的数组，为了便于说明，我们仅以<code>int</code>型的数组为例。事实上，只要稍加改进，我们就可以写出适配任何数据类型（包括结构体）的数组。</p>
<p>可是，数组有什么好写的呢？我们写下<code>int arr[10] = &#123;0&#125;;</code>，不就定义了一个数组吗？我们可以通过下标访问、也可以通过指针访问，我们可以读取内容、也可以赋值。然而，正是因为我们频繁地在代码中写下<code>printf(&quot;%d\n&quot;, arr[index]);</code>等<strong>直接操作数组</strong>的代码，我们才会犯下下标越界等导致程序崩溃的错误。<strong>如果我们在程序中加入很多条件判断，保证每一次操作的合法性，又会徒增代码量，和我们程序的运行逻辑相混淆。</strong></p>
<p>事实上，直接定义的数组只是一个存放数据的“变量”。<strong>如果将存放数据的数据结构，其相关属性，以及在数据结构上的操作封装，我们就得到了一个对象。</strong>以今天介绍的数组为例，一个<strong>“数组对象”</strong>应当包括如下三个方面</p>
<ul>
<li><strong>存储数据的数据结构</strong>，即数组本身（为了实现<strong>可变长数组</strong>，我们用一个指针管理数组并用<code>malloc</code>分配空间，而非直接写一个定长数组）</li>
<li><strong>属性</strong>，如当前数组的最大容量、当前数组的元素个数</li>
<li><strong>一系列函数</strong>，提供初始化、插入、销毁的功能</li>
</ul>
<p>为了实现上述目标，我们首先定义自己的<strong>数组类型</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_SIZE 10</span></span><br><span class="line">	<span class="comment">// 这里定义了一个宏，设置数组的初始容量。</span></span><br><span class="line">	<span class="comment">// 后续初始化数组时，如果没有指定容量，则先开辟 10 个 int 的大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">array</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *head;		<span class="comment">// 数组首地址</span></span><br><span class="line">    <span class="type">size_t</span> size;	<span class="comment">// 数组的最大容量</span></span><br><span class="line">    <span class="type">size_t</span> cur;		<span class="comment">// current，当前数组的元素个数</span></span><br><span class="line">&#125; <span class="type">array_t</span>;			</span><br><span class="line">    <span class="comment">// ‘_t’结尾是 C 的经典代码风格，表示这是 typedef 的一种新类型，即我们的“数组类型”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以后当我们写下</span></span><br><span class="line"><span class="type">array_t</span> arr1, arr2;</span><br><span class="line"><span class="comment">// 等代码时，就可以说，我们现在拥有了两个数组对象，分别叫 arr1 和 arr2</span></span><br></pre></td></tr></table></figure></div>

<p>现在，我们有了自己的数组类型，也可以定义自己的<strong>数组对象</strong>。当然，<code>arr1[1]</code>等原有的操作将不被允许了，所有的操作都将通过函数进行。在每一个函数中，我们只需要将数组对象 —— 实际上是这个对象的地址 —— 传入函数，就可以对某一个具体的数组对象进行操作。</p>
<h3 id="初始化与销毁"><a href="#初始化与销毁" class="headerlink" title="初始化与销毁"></a>初始化与销毁</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">array_t</span> arr;            <span class="comment">// 定义了一个数组对象</span></span><br><span class="line">    array_init(&amp;arr, <span class="number">100</span>);  <span class="comment">// 初始化数组对象，开辟 100 个 int 的容量</span></span><br><span class="line">    array_destroy(&amp;arr);    <span class="comment">// 销毁数组对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了实现这样简洁的代码，我们需要自己设计一系列函数</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_init</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化数组</span></span><br><span class="line"><span class="comment">    	参数</span></span><br><span class="line"><span class="comment">       		`arr`  array_t 的指针，即 struct array 的指针，代表数组对象</span></span><br><span class="line"><span class="comment">       		`size` 数组的起始容量，如果小于等于 0，则默认开辟 INIT_SIZE 个</span></span><br><span class="line"><span class="comment">       	返回值</span></span><br><span class="line"><span class="comment">       		如果初始化成功返回 0，否则返回 -1</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果没有传入数组对象，则失败</span></span><br><span class="line">    <span class="type">int</span> real_size = (size &gt; <span class="number">0</span>) ? size : INIT_SIZE; </span><br><span class="line">                                 <span class="comment">// 如果参数 size 非正，则使用预先定义的 size</span></span><br><span class="line">    <span class="keyword">if</span> ((arr-&gt;head = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * real_size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果 malloc 失败，则函数直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr-&gt;size = real_size; <span class="comment">// 更新数组的最大容量</span></span><br><span class="line">        arr-&gt;cur = <span class="number">0</span>;          <span class="comment">// 设置当前元素个数为 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 成功则返回 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_destroy</span><span class="params">(<span class="type">array_t</span> *arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 销毁数组</span></span><br><span class="line"><span class="comment">       参数</span></span><br><span class="line"><span class="comment">       		`arr`  array_t 的指针，代表要销毁的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(arr-&gt;head);  <span class="comment">// 释放数组的数据区</span></span><br><span class="line">    arr-&gt;head = <span class="literal">NULL</span>; <span class="comment">// 将数组头指针改为空值</span></span><br><span class="line">    arr-&gt;size = <span class="number">0</span>;    <span class="comment">// 将数组最大容量改为 0</span></span><br><span class="line">    arr-&gt;cur = <span class="number">-1</span>;    <span class="comment">// 将数组元素个数改为无效值 -1</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="数组的生长"><a href="#数组的生长" class="headerlink" title="数组的生长"></a>数组的生长</h3><p><strong>传统的数组大小是固定的</strong>，如果访问越界（有可能是下标过大，<strong>也有可能是下标为负数</strong>）将产生得到随机值、程序崩溃等问题。这里，我们的数组并非直接定义，而是通过<code>malloc</code>动态申请，这就为其生长提供了可能。我们规定，<strong>每当数组生长的时候，容量增加原来的一倍</strong>。当然，<strong>我们不应在程序中直接调用此函数，而是让“插入元素”等函数自动调用</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_grow</span><span class="params">(<span class="type">array_t</span> *arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 将数组容量扩大一倍</span></span><br><span class="line"><span class="comment">       参数</span></span><br><span class="line"><span class="comment">       		`arr`  array_t 的指针，代表要扩大的数组</span></span><br><span class="line"><span class="comment">       返回值</span></span><br><span class="line"><span class="comment">       		成功返回 0，失败返回 -1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> old_size = arr-&gt;size;     <span class="comment">// 生长前的容量</span></span><br><span class="line">    <span class="type">int</span> new_size = old_size * <span class="number">2</span>;  <span class="comment">// 生长后的容量</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;                <span class="comment">// 管理新分配的空间的指针</span></span><br><span class="line">    <span class="keyword">if</span> ((p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * new_size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 申请更大的空间，如果失败则直接返回</span></span><br><span class="line">                   <span class="comment">// 当然哪怕这种情况发生，原有数组中的内容仍然保存</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; old_size; i++) &#123; <span class="comment">// 循环复制原数组内容</span></span><br><span class="line">            p[i] = arr-&gt;head[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(arr-&gt;head);       <span class="comment">// 释放原数组的数据区</span></span><br><span class="line">        arr-&gt;head = p;         <span class="comment">// 更新数组首地址</span></span><br><span class="line">        arr-&gt;size = new_size;  <span class="comment">// 更新数组最大容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="元素的插入"><a href="#元素的插入" class="headerlink" title="元素的插入"></a>元素的插入</h3><p>数组的插入可以分成两类 —— <strong>尾部插入</strong>和<strong>中间插入</strong>。前者只需要传入新的元素，后者还需要获取插入的下标。这里我们仅实现前者。插入新元素，则有可能会出现越界的情况，所以<strong>这个函数需要自行判断会不会越界</strong>，如果会，则需要<strong>主动调用数组生长函数扩大空间</strong>。我们通过一张图更直观地了解数组的容量<code>size</code>和元素数量<code>cur</code>的关系。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/截屏2023-03-21 15.29.44.png"
                      alt="截屏2023-03-21 15.29.44" style="zoom:30%;" 
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_push</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 在数组 `arr` 尾部插入元素 `val` </span></span><br><span class="line"><span class="comment">       成功返回 0，出错返回 -1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr-&gt;cur == arr-&gt;size) &#123;      <span class="comment">// 这种情况表示数组已满，需要 grow</span></span><br><span class="line">        <span class="keyword">if</span> (array_grow(arr) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果 grow 失败则直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr-&gt;head[arr-&gt;cur] = val; <span class="comment">// 在尾部插入元素</span></span><br><span class="line">    arr-&gt;cur++;                <span class="comment">// 更新元素个数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>上述若干函数为我们实现了一些针对数组对象的基本操作，当然这还远远不够。你可能需要自己书写其他函数，例如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_isempty</span><span class="params">(<span class="type">array_t</span> *arr)</span>;</span><br><span class="line">    <span class="comment">// 判断数组 `arr` 是否为空。空返回 1，非空返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_get</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> index)</span>;</span><br><span class="line">    <span class="comment">// 获取数组 `arr` 中下标为 `index` 的元素值并返回</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_index_of</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="comment">// 获取数组 `arr` 中值为 `val` 的元素下标并返回，如果未查找到返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_insert</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> index, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="comment">// 在数组 `arr` 下标为 `index` 的位置插入元素 `val`。成功返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_set</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> index, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="comment">// 将数组 `arr` 中下标为 `index` 的元素设置成 `val`。成功返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_remove_index</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> index)</span>;</span><br><span class="line">    <span class="comment">// 将数组 `arr` 中下标为 `index` 的元素删除。成功返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_remove_val</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="comment">// 将数组 `arr` 中值为 `val` 的元素删除。成功返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">array_size</span><span class="params">(<span class="type">array_t</span> *arr)</span>;</span><br><span class="line">    <span class="comment">// 获取数组 `arr` 的元素个数并返回，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">array_sizeof</span><span class="params">(<span class="type">array_t</span> *arr)</span>;</span><br><span class="line">    <span class="comment">// 获取数组 `arr` 中数据部分的总字节数，功能类似传统的 sizeof(数组名)。出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">array_to_array</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> *ret)</span>;</span><br><span class="line">    <span class="comment">// 将数组对象 `arr` 转换成基本数组，存于 `ret` 中并返回。出错返回 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">array_subarray</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> *ret)</span>;</span><br><span class="line">    <span class="comment">// 将数组对象 `arr` 中下标为 [from, to) 的子序列转换成基本数组，</span></span><br><span class="line">    <span class="comment">// 存于 `ret` 中并返回。出错返回 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_sort</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> mode)</span>;</span><br><span class="line">    <span class="comment">// 将数组 `arr` 排序，规则由 `mode` 指定(如 0 为升序，1 为降序)。成功返回 0，出错返回 -1</span></span><br></pre></td></tr></table></figure></div>

<p>这些函数看起来较为麻烦，但是一经实现，你就有了独属于自己的一套模板。未来，你可以将它们扩充为适配任何类型的数组，甚至把它们<strong>做成一个头文件</strong>，每次使用时，只需要<code>#include &lt;myarray.h&gt;</code>，<strong>多是一件美事啊</strong>。实现了这些函数之后，<strong>你的代码里将不再出现大量的中括号、赋值和下标</strong>，取而代之的是 set、get、remove 等函数的调用，<strong>每一次完成一个操作，呈现在代码中的都不再是晦涩的运算符，而是具有自然语言含义的函数名</strong>，那你的代码的可读性也就增加了。</p>
<p><strong>如果同学们实现了这 12 个函数中的 8 个及以上，可以来找助教兑换小奖品。</strong></p>
<p>另外，这次封装的数组对象，也启发我们思考两个问题</p>
<ul>
<li><strong>如何封装一个链表</strong></li>
<li><strong>如何实现从<code>int</code>到任意数据类型的扩充</strong></li>
</ul>
<p>我们会在后续猪脚说中迭代地更新这部分内容。</p>
<h2 id="为什么数组比链表快"><a href="#为什么数组比链表快" class="headerlink" title="为什么数组比链表快"></a>为什么数组比链表快</h2><blockquote>
<p>已经了解过第三次作业第五题“词频统计”的同学，可以尝试用数组和链表分别实现一下。假设我们用数组实现时不用二分查找，而仍使用较低效的顺序查找，我们仍可从 judge 平台上反馈的运行时间看出，数组比链表快。这是为什么呢？</p>
<p>理论上，数组的查找时间复杂度为 $O(n)$，插入的时间复杂度也为 $O(n)$；链表的查找的时间复杂度为 $O(n)$，插入的时间复杂度为 $O(1)$。为什么数组在实践中更加高效呢？这还要从一个故事说起……</p>
</blockquote>
<h3 id="小z决战高考的故事"><a href="#小z决战高考的故事" class="headerlink" title="小z决战高考的故事"></a>小z决战高考的故事</h3><p>高中生小z打算奋战百天，决胜高考，誓死考上 BUAA。这天我们来到他的教室，看到如下场景</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/IMG_0936.JPG"
                      alt="IMG_0936" style="zoom:8%;" 
                >

<p>如图，小z的课桌上摆放了一个<strong>书立</strong>，他的课桌有一个<strong>抽屉</strong>，他的座位旁边放了一个<strong>书箱</strong>，在教室的后面还有一个<strong>储物柜</strong>。我们不难想象他会在这些地方各自存放什么东西，比如</p>
<ul>
<li>书立里放着刚考完的月考卷和今晚要做的作业；</li>
<li>抽屉里放着各科的复习书和辅导材料；</li>
<li>书箱里存放各科的课本，以备必要时参考；</li>
<li>储物柜里放着几个月前做过的卷子<del>和《故事会》</del>。</li>
</ul>
<p>按照上面的顺序，我们发现以下规律：<strong>储物量 —— 从小到大</strong>、<strong>存取物品的速度 —— 从快到慢</strong>（比如书立中的材料只需要直接抽出来、插回去，而储物柜中材料的存取还需要起身走动）、<strong>存放的内容 —— 从重要到不重要、访问频率递减</strong>。</p>
<p>很显然，这种安排符合逻辑：<strong>很快就会用到的东西就就放在手边，相对无关紧要的东西存放在别的地方</strong>。这给了我们什么启示呢？</p>
<h3 id="计算机的存储层次"><a href="#计算机的存储层次" class="headerlink" title="计算机的存储层次"></a>计算机的存储层次</h3><p><strong>计算机的存储系统从高到低大致可以分为四层：寄存器，高速缓存，内存和外存。</strong></p>
<ul>
<li><strong>外存就是硬盘等设备</strong>，如同学们常听到的“512G 的硬盘”“256G 的 iPhone”等，这些指的就是硬盘容量，U 盘等设备属于可移动的硬盘。</li>
<li>文件（包括程序）一般都存放在外存中，当它们要开始运行时，就要先<strong>加载到内存</strong>；另外，我们已经知道，<strong>程序中定义的变量、数组等也都存放在内存中</strong>。</li>
<li>寄存器位于 CPU（中央处理器） 中，<strong>存放在内存中的数据要进行运算，必须先放进寄存器</strong>。例如，我们写<code>int a = 1, b = 2; int c = 0; c = a + b;</code>，则内存中会先有<code>a</code> <code>b</code> <code>c</code>三个变量，进行第三步的运算时，先把<code>a</code>和<code>b</code>放进两个寄存器中，在 CPU 完成计算后，结果 3 被放进另一个寄存器，最后将其中的内容存放回内存中c的位置。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/截屏2023-03-23 14.48.45.png"
                      alt="截屏2023-03-23 14.48.45" style="zoom:20%;" 
                >

<p>当然，<strong>不同层级的存储设备其容量、速度和成本都是不同的</strong>。寄存器速度最快，但是容量很小（只能存放一个数）且成本高昂；内存容量比较大，但是读取和写入的速度都很慢。<strong>为了缓解 CPU 的高速和内存的低速的矛盾，人们发明了高速缓存技术。</strong></p>
<blockquote>
<p><strong>局部性原理</strong></p>
<p>局部性原理可以分为<strong>时间局部性原理</strong>和<strong>空间局部性原理</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) arr[i] = i;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>时间局部性原理：刚访问过的存储单元，不久后很可能会再次访问。</strong>例如上例中的循环变量<code>i</code>，在每一次循环中都会被访问若干次。</li>
<li><strong>空间局部性原理：刚访问过的存储单元附近的单元，不久后更可能被访问。</strong>例如上例中，我们访问了<code>arr[0]</code>，不久后就会访问其附近的<code>arr[1]</code> <code>arr[2]</code>等存储单元。</li>
</ul>
</blockquote>
<p><strong>高速缓存是一类存储设备，它们的存取速度远高于内存，但是容量比较小。</strong>根据局部性原理，把内存切割成很多<strong>块</strong>，把<strong>最近用到的</strong>一些块放进高速缓存中，每次需要访问内存时，<strong>优先到高速缓存中查找</strong>，如果找到，就可以不用访问内存，而是直接对高速缓存中的数据进行操作。如此一来，我们就可以<strong>减少直接访问内存的次数</strong>，从而<strong>提高了程序运行的效率</strong>。</p>
<p>正如同小z的例子，他会把更常用到的材料放在离手边更近的地方，从而提高寻找的效率。<strong>当然，手边的空间是有限的，他不能保证所有用到的材料都在手边；当他在手边没有找到想要的材料时，他还是得费点力气去储物柜里寻找。</strong></p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>正如前文所述，<strong>内存中的一些块会被拷贝进高速缓存中，以加快访问数据的速度</strong>。</p>
<p><strong>数组在内存中是连续存放的</strong>，因此，它们<strong>更有可能</strong>被连续地放进高速缓存中，从而在访问数据时，能够直接在高速缓存中找到，避免了查找低速的内存。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/截屏2023-03-23 15.24.35.png"
                      alt="截屏2023-03-23 15.24.35" style="zoom:35%;" 
                >

<p>链表的每一个节点都是<code>malloc</code>来的，这类动态申请的空间，<strong>离散地分布在内存中</strong>。在遍历链表的过程中，哪s怕某个节点在高速缓存中，也不能保证后续节点在高速缓存中，因此<strong>访问内存的次数大大增加</strong>，程序运行的时间增加。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/截屏2023-03-23 15.29.10.png"
                      alt="截屏2023-03-23 15.29.10" style="zoom:35%;" 
                >

<blockquote>
<p><strong>了解计算机存储相关原理并非多余或超纲。</strong>一方面，几乎所有信息类专业都要求掌握计算机组成原理 &#x2F; 计算机硬件基础 &#x2F; 计算机体系结构等科目；另一方面，多年来数据结构的大作业都是基于<strong>词频统计</strong>的，并且会根据程序运行时间进行排名，提前了解连续存储和链式存储的特点，对同学们选择解题方法有很大帮助。</p>
</blockquote>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>answers</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第四期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%9B%9B%E6%9C%9F/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/IMG_0892.jpg"
                      alt="IMG_0892" style="zoom:40%;" 
                >

<h2 id="容易忽视的-bug"><a href="#容易忽视的-bug" class="headerlink" title="容易忽视的 bug"></a>容易忽视的 bug</h2><h3 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span>* wordlist[LEN];</span><br><span class="line">  <span class="type">char</span> temp[MAXSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, temp)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(temp, wordlist[i])) &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, flag ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上代码想要实现这样的功能：每当输入一个单词时，在现有单词表<code>wordlist</code>里查找其是否已存在。若查找成功，则输出<code>YES</code>，否则输出<code>No</code>。</p>
<p>细心的同学很快能发现问题：这段代码只是让<code>flag</code>初始值为 0，只要有一次查找成功之后，<code>flag</code>的值会一直 1，不会改变。因此在此之后，无论输入什么样的单词，都会输出<code>YES</code>！</p>
<p>一种正确改法是，<strong>让<code>flag</code>获得“新的开始”。即每次进入<code>while</code>循环后，进入<code>for</code>循环之前，都执行一步<code>flag = 0;</code>，</strong>让其在每一次查找的初值都为 0，便成功 de 出了 bug。</p>
<h3 id="scanf函数返回值"><a href="#scanf函数返回值" class="headerlink" title="scanf函数返回值"></a><code>scanf</code>函数返回值</h3><p>在与同学们的交流中，我们发现同学们对于<code>scanf</code>函数的返回值不太清楚，下面举一个例子</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input: %d\n&quot;</span>, <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb=%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们直接给出程序的输入和输出结果：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">  3 4</span><br><span class="line"><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">output</span>&gt;</span></span><br><span class="line">  input: 2</span><br><span class="line">  a = 3</span><br><span class="line">  b = 4</span><br><span class="line"><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>我们再多给出一些输入输出样例：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">  3 hello</span><br><span class="line"><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">output</span>&gt;</span></span><br><span class="line">  input: 1</span><br><span class="line">  a = 3</span><br><span class="line">  b = 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>通过上述例子我们发现：</p>
<ul>
<li><p><code>scanf</code>函数的返回值<strong>并不是输入的数据，而是其具体输入的有效数据的个数</strong>（这个太容易忽略了！）；</p>
</li>
<li><p>若<code>scanf</code>函数中输入了非法的值（如第二个样例），则不会改变那一个数据的原始值，且返回值（输入的有效数据个数）不会算上此次非法输入。</p>
</li>
</ul>
<p>因此，当遇到第二次作业第五道编程题（小型图书管理系统）时，不能采取如下做法：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op)) != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为，无论你输入的是操作 1、2、3还是0，<code>scanf</code>函数的返回值都为 1。所以我们推荐如下写法：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op) != EOF) &#123;</span><br><span class="line">  <span class="keyword">if</span> (op == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="一些字符判断函数的返回值"><a href="#一些字符判断函数的返回值" class="headerlink" title="一些字符判断函数的返回值"></a>一些字符判断函数的返回值</h3><p>很多同学喜欢使用<strong>声明</strong>（啥是声明啥是定义？还记得吗？）在<code>&lt;ctype.h&gt;</code>中的库函数，例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isupper</span><span class="params">(<span class="type">char</span> c)</span>;  <span class="comment">// 判断一个字符c是否为大写字母</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isdigit</span><span class="params">(<span class="type">char</span> c)</span>;  <span class="comment">// 判断一个字符c是否为十进制数字字符0～9</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isalpha</span><span class="params">(<span class="type">char</span> c)</span>;  <span class="comment">// 判断一个字符c是否为字母</span></span><br><span class="line"><span class="comment">//类似的函数还有很多……</span></span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，在大多数编译环境中，这些函数的返回值类似于<code>strcmp</code>函数，只有<strong>零和非零值</strong>（不确定）两种情况，所以形如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(a,b) == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样的写法是有巨大隐患的。</p>
<p>事实上，**<code>if</code>语句条件不成立当且仅当括号中的表达式值为<code>0</code>或<code>&#39;\0&#39;</code>或<code>NULL</code>，所以，任何其他非零值都会进入<code>if</code>分支。<strong>以<code>&lt;ctype.h&gt;</code>库函数为代表的 C 库调用，</strong>标准写法**是</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述代码会在我们脑海中直观地翻译为<strong>“如果是数字，怎么怎么样；否则怎么怎么样”</strong>，这种写法不是<strong>更贴近自然语言的语义</strong>吗？这一个小小的细节，足以充分体现<strong>【函数命名规范】和【代码书写规范】的重要性</strong>。</p>
<h2 id="数据结构引入"><a href="#数据结构引入" class="headerlink" title="数据结构引入"></a>数据结构引入</h2><p>过去几周我们复习了诸多知识点，也学习了若干新内容，这是为后续课程做铺垫。<strong>再次简要列举必会知识点，请自行查缺补漏，后续如果出现下列基本知识的迷惑，我们的回复将包括但不限于「自己百度一下」「自己 <a href="csdn.net">csdn</a>一下」「看猪脚说」「看程设课件」等。</strong></p>
<ul>
<li>基本的递归函数的使用<ul>
<li>全排列等题目确实较难，但求解斐波那契数列你得会</li>
</ul>
</li>
<li>一维数组<ul>
<li><strong>初始化</strong></li>
<li>数组名的含义</li>
<li>数组作为函数参数</li>
</ul>
</li>
<li>字符串<ul>
<li>字符数组和字符串常量的区别</li>
<li>字符串读取，<code>scanf</code>和<code>gets</code>和<code>fgets</code>等的区别<strong>（以后再出现逐个字符构造字符串忘加<code>&#39;\0&#39;</code>的问题统一回复自己 de）</strong></li>
<li>字符数组初始化</li>
<li>字符串处理函数<code>strstr</code> <code>strcmp</code> <code>strcpy</code> <code>strncpy</code> <code>strcat</code> <code>strncat</code> <code>strlen</code> <code>strchr</code>等的功能、参数类型与顺序、返回值类型与含义</li>
<li><code>char</code>与<code>int</code>的联系和区别</li>
</ul>
</li>
<li>文件操作<ul>
<li>打开文件</li>
<li>关闭文件</li>
<li>读文件：单个字符 &#x2F; 一行 &#x2F; 按指定数据类型</li>
<li>写文件：单个字符 &#x2F; 一行 &#x2F; 按指定数据类型</li>
</ul>
</li>
<li><code>&lt;ctype.h&gt;</code><ul>
<li>判断是否为字母</li>
<li>判断是否为大写</li>
<li>判断是否为小写</li>
<li>判断是否为数字</li>
<li>判断是否为数字或字母（<code>isalnum</code>）</li>
<li>判断是否为空白字符（<code>iswhite</code>）</li>
<li>判断是否为标点符号（<code>ispunct</code>）</li>
<li>转成大写</li>
<li>转成小写</li>
</ul>
</li>
<li>二维数组<ul>
<li>定义与初始化</li>
<li><strong>作为函数参数</strong></li>
<li>遍历方式</li>
<li>指向行的指针（数组指针）</li>
<li>指向列的指针（基本类型指针）</li>
</ul>
</li>
<li><strong>指针</strong><ul>
<li>指针的定义与初始化，什么是<code>NULL</code></li>
<li>不同类型的指针的区别和联系</li>
<li>取地址（什么是地址），解引用</li>
<li>字符指针和字符数组的区别和联系</li>
<li>什么是<code>void*</code></li>
<li>指针的<code>++</code> <code>--</code>和加减运算</li>
<li>给指针赋值的含义</li>
<li>数组名和指针的区别与联系</li>
<li>函数参数的值传递</li>
<li>指针数组，管理字符串常量的指针数组</li>
<li>数组指针和函数指针（不要求熟练掌握）</li>
<li><code>main</code>函数的命令行参数</li>
</ul>
</li>
<li><strong>结构体</strong><ul>
<li>结构体的声明</li>
<li>结构体变量或数组的定义与初始化</li>
<li>结构体成员的访问</li>
<li>结构体的赋值</li>
<li>指向结构体的指针及通过指针访问成员</li>
<li>类型别名的声明及其与<code>#define</code>的区别和优劣</li>
<li>自引用结构的概念（后续继续深入学习）</li>
</ul>
</li>
<li><code>qsort</code>函数<strong>（以后不要用冒泡了！）</strong><ul>
<li>包含在哪个头文件？</li>
<li>有几个参数？顺序？含义？</li>
<li><code>cmp</code>函数怎么编写？<ul>
<li>基本类型数组的升序 &#x2F; 降序（<code>double</code>类型的比较要注意什么？）</li>
<li>二维字符数组字典序</li>
<li>二维基本类型数组多关键字</li>
<li>结构体数组单关键字 &#x2F; 多关键字</li>
</ul>
</li>
</ul>
</li>
<li><code>sizeof</code>的使用，当参数为<ul>
<li>类型名的时候</li>
<li>变量名的时候</li>
<li>指针变量名的时候</li>
<li>数组名的时候</li>
</ul>
</li>
</ul>
<blockquote>
<p>接下来我们将要学习的是数据结构正文部分，作为数据结构，理应与工具的使用（C 语言语法、IDE 的配置等）脱钩，而专注于理论知识和编程实现本身。所以希望同学们尽早排除干扰项，这样，课程本身的学习也会更加轻松。</p>
</blockquote>
<h3 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h3><p>我们不谈文邹邹的东西，<del>虽然选择题可能会考</del>。如果诸位手上有《离散数学（第三版）》，不妨翻到后面“图”和“树”的章节，看看书中是怎么定义的，<del>虽然这些内容离散 1 不教</del>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 17.42.41.png"
                      alt="截屏2023-03-17 17.42.41" style="zoom:33%;" 
                >

<hr>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 17.43.04.png"
                      alt="截屏2023-03-17 17.43.04" style="zoom:33%;" 
                >

<hr>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 17.43.32.png"
                      alt="截屏2023-03-17 17.43.32" style="zoom:33%;" 
                >

<hr>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 17.43.44.png"
                      alt="截屏2023-03-17 17.43.44" style="zoom:33%;" 
                >

<hr>
<p>我们注意到，未来我们将学习的一系列数据结构，都是通过<strong>自然语言和数学符号</strong>定义的，这和 C 语言有什么关系呢？首先，想必大家已经大致了解了“链表长啥样”“树长啥样”“图长啥样”，在此基础上，我们可以说，各个类型的数据结构，只是一种<strong>逻辑上的定义</strong>，是人们<strong>在纸面上画出来的东西</strong>、是通过数学方式总结的东西。这里，我们用“东西”当作宾语，似乎显得有点抽象了。且听我们逐细言来。</p>
<h3 id="硬件与物理"><a href="#硬件与物理" class="headerlink" title="硬件与物理"></a>硬件与物理</h3><p><strong>计算机不是魔法，是由硬件组成的</strong>，比如电线、二极管、塑料等。所以大家应该意识到，你的每一次操作（点击鼠标、摁下键盘、开启网页、执行int a &#x3D; 0;），归根结底，是某些电流的流动、某些开关的开闭、高低电压的转换，甚至可以细化到电子在你看不到的地方跃迁……</p>
<p>不管怎么说，作为一个纯物理的系统，计算机需要极其复杂的设计。这种设计给我们两点启发：其一，有赖于高性能的硬件，计算机可以用于快速处理海量的数据，效率远高于人；其二，给定一台计算机，其体系结构已经定死，其能够支持的功能必然有限。<strong>事实上，这个问题的妙处就在于：我们手里只有有限的资源，但我们利用想象力，可以解决一切问题。</strong></p>
<p><strong>计算机为我们提供了内存、硬盘（磁盘）等物理设备存放数据。</strong>当程序中定义了一个接一个的变量，它们大概率<strong>会被放在一起</strong>；当程序中定义了一个数组，<strong>内存提供一片连续的空间存放</strong>；另外，我们有<strong>指针</strong>这种工具，可以<strong>间接地引用某一片内存空间</strong>。前两者对应<strong>连续存储方式</strong>，这不难理解；而后者为我们提供了一种新的思路</p>
<ul>
<li>对于每一项数据，我们为其增加一个成员 —— <strong>用于记录地址的成员</strong> —— 将其打包成一个<strong>数据包</strong>。</li>
<li>每次新增了数据需要存放，我们<strong>在内存中申请一片空间</strong>用于存储。</li>
<li>新增的数据包的地址，会被<strong>先前已经存在</strong>的数据包中的那个记录地址的成员记录下来，以便<strong>通过已经存在的数据包，访问到新的数据包</strong>。</li>
</ul>
<p>当然对应到 C 语言中，新增的那个成员就是指针，打包过程即声明<code>struct</code>，申请空间通过<code>malloc</code>，后续操作涉及指针的赋值等。于是，不同于连续存储，一种<strong>链式存储</strong>的方式诞生了。我们只需要记录下某一些节点的位置，<strong>通过其中的指针成员不断向后访问</strong>，即可以找遍所有节点。由于指针想指谁就可以指谁，因此这些节点之间的结构可能有以下几种</p>
<ul>
<li>第一个节点指向第二个，第二个节点指向第三个，……。这种链式结构，即为<strong>链表</strong>。</li>
<li>从一个根出发，不断向后分叉。这种分叉结构，即为<strong>树</strong>。</li>
<li>乱指来指去。这种乱七八糟结构，即为<strong>图</strong>。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 21.21.16.png"
                      alt="截屏2023-03-17 21.21.16" style="zoom:40%;" 
                >

<h3 id="So-What？"><a href="#So-What？" class="headerlink" title="So What？"></a>So What？</h3><p>上一小节我们从物理硬件的支持和编程语言提供的手段，描述了一种新的存储方式。我们可以进行如下思考</p>
<ul>
<li>比起刚才提及的链式存储，<strong>数组这种连续存储方式似乎更加浅显易懂</strong>；而<strong>链式存储似乎更加灵活</strong>，因为我们可以自由地排放数据的先后顺序（前提是指针不出错）。</li>
<li>某些情况下，这<strong>两种存储方式可以相互转换</strong>。例如，链表的一个接一个的存储方式，和数组也很像 —— 反之同理 —— 区别在于<strong>数组的每一个元素在内存中真的连续存放，而链表的元素离散地存放，我们只能通过指针一个接一个地访问。</strong>再比如，图的这种一个节点可以随意和其他节点连在一起的模式，似乎用数组也能做到 —— <strong>给每个点编号，然后把相邻的节点的编号都存入一个数组里</strong>。</li>
<li><strong>这些不同的结构，可以用于实际问题中的仿真。</strong>数组 &#x2F; 链表的结构像是在<strong>排队</strong>，能不能用来模拟生活中进进出出的排队问题（如航班的离港序列、银行排队与服务）呢？图能够仿真生活中管道的铺设、道路的布局等，能不能用来<strong>求最短的路径、最少的工程用料</strong>？我们发现，<strong>不同的结构都具备了描述现实世界的强大潜能</strong>。</li>
<li>上述的各种结构与计算机的运行原理密不可分。试想，同为<strong>线性结构</strong>的数组和链表，想在中间插入一个新数据，前者需要把该位置之后的所有元素，<strong>都往后挪一个位置</strong>，然后把新元素插进去；而对于后者，需要为新数据申请一片空间，然后修改一些指针的值，<strong>使得一些指向关系发生变化，从而在逻辑意义上实现了“插入”</strong>。<ul>
<li>数组插入写起来比较容易，但是需要计算机搬运很多个元素，<strong>看起来有点浪费时间</strong>。</li>
<li>链表插入有点抽象，但是实际上只需要修个几个指针的值，快速便捷；但是如果要查找一个数据，我们必须从链表的头开始，<strong>一个接一个地往后通过指针访问每个节点</strong>，这种操作好像也很麻烦。另外，<strong>对于链表，我们也就不能用<code>qsort</code>等进行排序了。</strong></li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前两节我们说了两件事：其一，计算机作为工具，<strong>为我们提供了</strong>存放数据的不同方式、不同结构、不同逻辑；其二，这些不同的方式似乎<strong>各有特点，各有优劣</strong>。以上所讨论的，都是数据结构相关的内容，所以我们在最早的时候，将数据结构描述为一样“东西”，确有其道理。所以，数据结构可以理解成以下几部分内容</p>
<ul>
<li>海量的、相互之间有关联的数据，在计算机中应<strong>如何组织</strong>（线性的排排队还是分叉结构还是其他）</li>
<li>确立了组织方式，<strong>基本的数据操作</strong>（插入、删除、查找、排序）应该如何编程，有无更加高效的写法</li>
<li>作为描述现实世界的工具，能否利用数据结构<strong>模拟实际问题</strong>（管道铺设、最短路径）</li>
<li>数据结构本身也是数学研究的对象，能否基于数学原理、利用编程工具，<strong>解决一些数学问题</strong>（利用树实现表达式的计算？有点玄乎。。。）</li>
</ul>
<p>由于本周没有太多新知识，因此写了这样一篇文字作为接下来学习的 introduction。<strong>如果你能看到这里，那么也祝愿你在数据结构的学习中取得收获与进步～</strong></p>
<h2 id="第三次作业补充练习"><a href="#第三次作业补充练习" class="headerlink" title="第三次作业补充练习"></a>第三次作业补充练习</h2><p>1、<a class="link"   href="http://akoj.online/problem/103" >干员整理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这是适合现阶段练习结构体用法的一道非常综合的题目，由北航 AK 宝典制作小组提供，初次登录网站需要注册，建议账号为自己的学号。</p>
<p>2、<a class="link"   href="http://akoj.online/problem/16" >字符串之海 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这道题可以作为第三次作业第五题（词频统计）的补充练习，很适合大家熟悉链表的使用。</p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第六期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%85%AD%E6%9C%9F/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/IMG_67F8A8A691D4-1.jpeg"
                      alt="IMG_67F8A8A691D4-1" style="zoom:25%;" 
                >

<h2 id="容易忽视的-bug"><a href="#容易忽视的-bug" class="headerlink" title="容易忽视的 bug"></a>容易忽视的 bug</h2><h3 id="判断空指针与访问空指针"><a href="#判断空指针与访问空指针" class="headerlink" title="判断空指针与访问空指针"></a>判断空指针与访问空指针</h3><p>在给大家 debug 的时候，我们发现了一个普遍存在、且大多数同学喜欢写但是其实是错误的写法，并且这个写法往往导致了程序报<code>SIGSEGV</code>或运行时间过长的错误，请看如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span></span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// in main:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span> =</span> <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;x != <span class="number">0</span> &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么这段代码是如何访问到空指针的呢？这其中的关键就在<code>while</code>的判断里。</p>
<p>如果在某次循环后，<code>p</code>已经是空指针，逻辑上来说，<code>while</code>条件逻辑值为假，不会再进入循环。但程序执行时，两个条件都要进行判断，<strong>所以当<code>p</code>为空指针时，依然需要首先执行<code>p-&gt;x != 0</code>的判断，才能进一步判断是否进入循环</strong>，由此，程序便访问到了空指针。</p>
<p>改进方法很简单，只需要在<code>while</code>条件里只保留<code>p != NULL</code>，而把其余所有判断移到<code>while</code>循环内部进行：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;x != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此，上述例子告诉我们，在进行链表循环遍历时，<strong>不能将空指针判断与其他需要访问结构体成员的相关判断放到一起</strong>，在循环判断里只保留空指针判断，而其他涉及结构体成员的判断放到循环内部一开始执行。<strong>这也是我们一直强调的事情：请把你代码的业务逻辑和在数据结构上的基础操作分离。</strong></p>
<h3 id="循环链表的遍历输出"><a href="#循环链表的遍历输出" class="headerlink" title="循环链表的遍历输出"></a>循环链表的遍历输出</h3><p>很多同学使用如下方法进行一个循环链表的遍历输出：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (p = <span class="built_in">list</span>; p-&gt;next != <span class="built_in">list</span>; p = p-&gt;next)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="comment">/* args */</span>);</span><br></pre></td></tr></table></figure></div>

<p>该代码错误原因很明显，即<strong>当<code>p</code>为<code>list</code>的前一个节点时，就不会再进入<code>for</code>循环了，因此少打印了一个节点</strong>。修改方式当然可以是，在跳出<code>for</code>循环后，再对当前的<code>p</code>节点进行一次打印，但未免稍显繁杂，因此可以采取如下方式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">p = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="comment">/* args */</span>);</span><br><span class="line">  p = p-&gt;next;</span><br><span class="line">&#125; <span class="keyword">while</span> (p != <span class="built_in">list</span>);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 链表的规范化操作</span><br><span class="line"></span><br><span class="line">&gt; 这部分主要针对课件中链表的基本操作，请掌握不牢的同学再次自查，**千万不要出现基本操作出错的情况！** 此外我们给大家提几点使用链表的建议。</span><br><span class="line">&gt;</span><br><span class="line">&gt; - **少用`typedef`。**很多同学代码中出现大量的标识符，如`node` `_node` `Node` `PNode` `Nodeptr`等，这很可能导致某个地方将复合数据类型和它的指针类型相混淆，造成不必要的麻烦；另一方面，作为并不是很系统的一个程序，这么自定义类型别名会给看你代码的人带来困扰。</span><br><span class="line">&gt; - **规范命名**。数据域中的变量名应当与实际情况相符合，如`char book_name[64];` `long stu_id;` `int wait_time;`等，切忌`a` `b` `c` `x` `y` `z`（除非这个结构体就是表示某种特定的数学符号，如坐标`(x, y)`或图的边`&lt;u,v&gt;`）；**指针域应当统一写`next`和`prev`**。</span><br><span class="line">&gt; - **不要用全局变量，尤其是`head`头指针。**</span><br><span class="line"></span><br><span class="line">### 统一口径</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;/images/assets6/截屏2023-03-29 08.53.08.png&quot; alt=&quot;截屏2023-03-29 08.53.08&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">我们以上图所示的**单向链表**为例。假设我们的链表的节点声明如下**（什么是声明、什么是定义？）**</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct node &#123;</span><br><span class="line">    int val;           // 这是个没有意义的名字！实际使用时最好不要这么写，这里只是举个小例子</span><br><span class="line">    struct node *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>遵循不用全局变量的原则，<strong>我们把一切变量都定义在<code>main</code>中</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// call functions</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当然，作为局部变量的<code>head</code>，如果直接传入各个函数，并不能修改其值，<strong>正如同在<code>main</code>中调用<code>void f(int i) &#123; i = 100; &#125;</code>并不能修改<code>main</code>中<code>int</code>变量的值</strong>。所以，我们统一传入**<code>struct node</code>的二级指针<strong>作为参数，函数调用时统一写</strong><code>&amp;head</code>**。这里假定函数都没有返回值。</p>
<h3 id="链表的初始化"><a href="#链表的初始化" class="headerlink" title="链表的初始化"></a>链表的初始化</h3><p>链表的初始化需要做的事情是将<code>head</code>指针设置成<code>NULL</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.00.09.png"
                      alt="截屏2023-03-29 09.00.09" style="zoom:50%;" 
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initlist</span><span class="params">(<span class="keyword">struct</span> node **phead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 功能：初始化链表</span></span><br><span class="line">    *phead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链表的插入"><a href="#链表的插入" class="headerlink" title="链表的插入"></a>链表的插入</h3><p>链表的插入需要做三件事</p>
<ul>
<li>通过<code>malloc</code>申请一个新节点并设置数据。</li>
<li>假设我们要在节点<code>p</code>的后面插入，则需要将新节点的指针指向<code>p</code>的后一个节点。</li>
<li>将<code>p</code>的指针指向新节点。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.03.54.png"
                      alt="截屏2023-03-29 09.03.54" style="zoom:30%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.04.06.png"
                      alt="截屏2023-03-29 09.04.06" style="zoom:30%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.04.18.png"
                      alt="截屏2023-03-29 09.04.18" style="zoom:30%;" 
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertlist</span><span class="params">(<span class="keyword">struct</span> node **phead, <span class="keyword">struct</span> node *p, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在节点 p 后插入新节点，其数据为 val</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">    <span class="comment">// ------ 创建新节点 ------</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">q</span> =</span> (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">    	<span class="comment">/* 这里其实应该加入错误判断的代码，如果 malloc 失败，则 q 为 NULL</span></span><br><span class="line"><span class="comment">    	   当然我们写的小程序一般不会有问题，除非你开了【某些杀毒软件】</span></span><br><span class="line"><span class="comment">    	   if (q == NULL) &#123;</span></span><br><span class="line"><span class="comment">    	       perror(&quot;malloc error&quot;);</span></span><br><span class="line"><span class="comment">    	         // 这个函数声明在 &lt;stdio.h&gt; 中</span></span><br><span class="line"><span class="comment">    	         // 能够在标准错误(屏幕)上输出 malloc error: xxx</span></span><br><span class="line"><span class="comment">    	         // xxx 为此函数解析的错误信息</span></span><br><span class="line"><span class="comment">    	         // 当然你也可以写 `fprintf(stderr, &quot;malloc error\n&quot;);`</span></span><br><span class="line"><span class="comment">    	         // 或 `printf(&quot;malloc error\n&quot;);`</span></span><br><span class="line"><span class="comment">    	       exit(1); // 或 `return;`，前者直接结束程序，后者只是返回 main</span></span><br><span class="line"><span class="comment">    	   &#125;</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">    q-&gt;val = val;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// -----------------------</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;       <span class="comment">// 如果链表为空</span></span><br><span class="line">        head = q;             <span class="comment">// 头节点就是新节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;   <span class="comment">// 如果在头节点之前插入</span></span><br><span class="line">        q-&gt;next = head;       <span class="comment">// 新节点的下一个节点就是原来的头节点</span></span><br><span class="line">        head = q;             <span class="comment">// 头节点改为新节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">    &#125;</span><br><span class="line">    *phead = head;            <span class="comment">// 更新 main 中的 head 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们对三种不同的插入进行讨论。参数中的<code>p</code>表示我们要在哪个节点后插入，其中，当<code>head</code>为<code>NULL</code>时，链表必然为空，则直接给头节点赋值即可；如果链表非空，而插入的位置<code>p</code>为空，则说明要在头节点之前插入 —— 因为这里的参数<code>p</code>，必然是通过调用<strong>某个查找函数</strong>得到的，那个查找函数遍历链表，应当有如下的功能</p>
<ul>
<li>找到链表中符合条件的节点，则返回该节点的指针。</li>
<li>未找到符合条件的节点<ul>
<li>如果这是<strong>无序链表</strong>，就返回<strong>尾节点</strong>的指针，便于在尾后插入。</li>
<li>如果这是<strong>有序链表</strong>（假设从小到大），如果我们要找的比表中任何一个数都要小，则返回<code>NULL</code>，表示<strong>未来应该插在链表的头</strong>；如果我们要找的比表中任何一个数都要大，则返回<strong>尾节点</strong>的指针，表示<strong>未来应该插在尾后</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>上述说明或许稍显复杂，我们可以这么想：<code>p</code>标识我们要插入的位置，<strong>在链表的中间插入或在尾后插入，操作是相同的</strong>，所以<code>p</code>只要是一个节点的指针即可；<strong>只有在头节点前插入是特殊的，此时<code>p</code>应该为特殊值<code>NULL</code>。</strong></p>
</blockquote>
<h3 id="链表的删除"><a href="#链表的删除" class="headerlink" title="链表的删除"></a>链表的删除</h3><p>链表的删除需要做三件事</p>
<ul>
<li>找到需要删除的节点及其前序节点。</li>
<li>将前序节点的指针指向需要删除节点的下一个节点。</li>
<li>释放要删除的节点。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.28.32.png"
                      alt="截屏2023-03-29 09.28.32" style="zoom:30%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.28.42.png"
                      alt="截屏2023-03-29 09.28.42" style="zoom:30%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.28.53.png"
                      alt="截屏2023-03-29 09.28.53" style="zoom:30%;" 
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deletelist</span><span class="params">(<span class="keyword">struct</span> node **phead, <span class="keyword">struct</span> node *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 删除节点 p</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">q</span> =</span> head, *r = <span class="literal">NULL</span>;    <span class="comment">// q 从头开始遍历，r 为 q 的前一个节点</span></span><br><span class="line">    <span class="keyword">for</span> ( ; q != p; r = q, q = q-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// for 循环结束后，q 指向 p，r 指向 q 的前一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">NULL</span>) &#123;        <span class="comment">// 如果删的是头节点</span></span><br><span class="line">        head = q-&gt;next;     <span class="comment">// 改变头节点</span></span><br><span class="line">        <span class="built_in">free</span>(q);            <span class="comment">// 释放原来的头节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r-&gt;next = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    *phead = head;          <span class="comment">// 更新 main 中的 head</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链表的遍历"><a href="#链表的遍历" class="headerlink" title="链表的遍历"></a>链表的遍历</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">traverselist</span><span class="params">(<span class="keyword">struct</span> node *head, <span class="type">void</span> (*visit)(<span class="keyword">struct</span> node *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遍历链表中的每一个节点，对于每一个节点，调用函数 visit 进行访问</span></span><br><span class="line">    <span class="comment">// 第一个参数 head 即头节点，由于遍历并不会修改 head，所以不用传二级指针</span></span><br><span class="line">    <span class="comment">// 第二个参数为一个函数指针，表示访问方式</span></span><br><span class="line">    <span class="comment">//     - 这个函数的返回值是 void 类型</span></span><br><span class="line">    <span class="comment">//     - 这个函数需要接收一个 struct node * 类型的参数</span></span><br><span class="line">    <span class="comment">// 假设我们有</span></span><br><span class="line">    <span class="comment">//    void visit_1(struct node *p) &#123; printf(&quot;p-&gt;val: %d\n&quot;, p-&gt;val); &#125;</span></span><br><span class="line">    <span class="comment">// 和</span></span><br><span class="line">    <span class="comment">//    void visit_2(struct node *p) &#123; printf(&quot;(p-&gt;val)^2: %d\n&quot;, </span></span><br><span class="line">    <span class="comment">//                                             (p-&gt;val) * (p-&gt;val)); &#125;</span></span><br><span class="line">    <span class="comment">// 则可以在 main 中通过不同访问方式、打印不同信息</span></span><br><span class="line">    <span class="comment">//    traverselist(head, visit_1); traverselist(head, visit_2);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> node *p = head; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">            visit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链表的销毁"><a href="#链表的销毁" class="headerlink" title="链表的销毁"></a>链表的销毁</h3><p>销毁链表即<code>free</code>链表的每一个节点，<strong>只写<code>free(head);</code>是必然不可行的</strong>，除非链表中只剩下一个头节点。另一方面，一旦当前节点被<code>free</code>，则无法找到下一个节点，所以，销毁链表需要从最后一个节点开始。然而，找到了最后一个节点，其前一个节点又得从头遍历才能找到，所以，这里我们通过<strong>递归</strong>实现。<strong>具体的原理请画草图分析，这里不再赘述。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destroylist</span><span class="params">(<span class="keyword">struct</span> node **phead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 销毁链表，在 main 中应调用此函数</span></span><br><span class="line">    <span class="comment">// 其具体递归实现放在 recursive_free 中</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">    recursive_free(head);</span><br><span class="line">    *phead = <span class="literal">NULL</span>;  <span class="comment">// !! 将 main 中的 head 改为 NULL，防止销毁后再访问 !!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">recursive_free</span><span class="params">(<span class="keyword">struct</span> node *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放 p 及其后的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;        <span class="comment">// 如果 p 后面还有节点</span></span><br><span class="line">        recursive_free(p-&gt;next);  <span class="comment">// 释放 p 后面的所有节点</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">free</span>(p);                      <span class="comment">// 释放 p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>关于<code>free</code>函数</strong></p>
<p>我们摘要了手册中关于<code>free</code>函数的一些内容：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">  free(void *ptr);</span><br><span class="line"></span><br><span class="line">The free() function frees allocations that were created via the preceding allocation functions.[allocation: (内存)分配；preceding: 上述的]</span><br><span class="line"></span><br><span class="line">The free() function deallocates the memory allocation pointed to by ptr. If ptr is a NULL pointer, no operation is performed. [deallocates: 释放、回收、解除分配]</span><br></pre></td></tr></table></figure></div>

<p>这里，“前面提及的内存分配函数”指的是包括<code>malloc</code>在内的以<code>calloc</code> <code>valloc</code> <code>realloc</code>为代表的 C 库内存分配函数，有兴趣的同学可以自己 <strong>STFW（Search the Friendly&#x2F;F**king Web）</strong>一下。<strong>申请来的空间需要释放，这就是<code>free</code>的功能，该空间通过指针<code>ptr</code>指出。</strong>这其中的注意事项包括</p>
<ul>
<li><p><code>free</code>将<code>ptr</code>所指的内存空间全部<strong>清理</strong>，<strong>但并不会改变<code>ptr</code>还指在那里的既定事实</strong>。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pi = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*pi = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;before free, *pi = %d\n&quot;</span>, *pi);</span><br><span class="line"><span class="built_in">free</span>(pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after free, *pi = %d\n&quot;</span>, *pi); <span class="comment">// 合法，不会崩溃，大概率输出不是 10 的数</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>free</code>同一片内存多次程序会崩溃。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *p = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;first free success\n&quot;</span>);  <span class="comment">// 会输出</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;second free success\n&quot;</span>); <span class="comment">// 不会输出</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>free(NULL);</code>是安全的，这种情况下无事发生。</strong></p>
</li>
<li><p>综上三点，好习惯是：<strong>写完<code>free(p);</code>立即写<code>p = NULL;</code>。</strong>一方面可以防止你在释放空间后再次访问，因为此后访问空指针<code>p</code>程序会直接崩溃而非访问到一个奇怪的值；另一方面可以防止你不小心再次<code>free</code>而导致程序崩溃，因为<code>free</code>空指针是安全的。这里的区别在于，如果你<strong>无意中访问已经被<code>free</code>的空间，并不会报错，只是会得到错误数据而你找不出 bug</strong>，所以需要程序崩溃来<strong>提醒</strong>你错误访问了；如果你忘记考虑某些特殊情况而不慎多次<code>free</code>同一片内存，为了防止崩溃并简化代码，将指针设置成<code>NULL</code>是一个不错的选择。</p>
</li>
</ul>
</blockquote>
<h2 id="链表结构的拓展"><a href="#链表结构的拓展" class="headerlink" title="链表结构的拓展"></a>链表结构的拓展</h2><p>上述链表操作的基本思路和课件中相同，无非是<strong>节点的申请</strong>、<strong>链表头的维护</strong>和<strong>指针域的改变</strong>。在编程的时候，我们无需关心自引用结构中的底层逻辑，即不需要思考地址之类的问题，而是用更加上层的视角审视代码。此犹言</p>
<ul>
<li><code>head</code> <code>p</code> <code>q</code> <code>r</code> <code>next</code>等只是标识符，它们就<strong>代表了节点</strong>，访问时统一通过<code>-&gt;</code>即可。</li>
<li><code>p = p-&gt;next</code>等操作只是<strong>“挪一下位置”</strong>，而不应该细化为地址的赋值。</li>
<li>插入删除等函数中，一切指针赋值操作，应抽象为<strong>“声明了一个指向关系”</strong>。访问一个节点，我们要让<code>p</code>“指向”它；将 A 连接上 B，我们要让 A 的<code>next</code>“指向”B。所以，<strong>使用链表时，必须画图。</strong></li>
</ul>
<h3 id="next-next"><a href="#next-next" class="headerlink" title="next  ? next !"></a><code>next </code> ? <code>next</code> !</h3><blockquote>
<p>我的<code>next</code>是你，你的<code>next</code>是他 —— 于是，我连接你，你连接他。链表的实现思路使我们第一次看到了指针的作用，仅仅在结构体中增加了<code>next</code>成员，我们就能够创造出一种崭新的线性表。</p>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-17 21.21.16.png"
                      alt="截屏2023-03-17 21.21.16" style="zoom:30%;" 
                >

<p>还记得这张图吗？我们已经实现了其中的链表，那么树和图应该怎么实现呢？</p>
<ul>
<li><code>struct node *left, *right;</code>，假设<code>struct node</code>中有两个指针成员，那么一个<code>struct node</code>就可以最多指向两个其他的<code>struct node</code>，这就对应着<strong>二叉树</strong>结构。</li>
<li><code>struct node *neighbors[10];</code>，假设<code>struct node</code>中有一个指针数组成员（其中包含了 10 个指针），那么一个<code>struct node</code>就可以最多指向十个其他的<code>struct node</code>，这就对应着<strong>图</strong>结构。</li>
</ul>
<p>可见，有了指针，我们就<strong>在节点上定义了“指向”关系</strong>，A 指向 B，当且仅当通过 A 可以访问到 B。在程序里，指针存放节点的地址，于是通过一个节点可以访问到其他节点，这就<strong>实现了“指向”关系</strong>。</p>
<p>其实，我们可以用更加抽象的语言定义这件事情。设我们有如下集合<br>$$<br>A&#x3D;{e_1, e_2, \cdots, e_n}<br>$$<br>符号<br>$$<br>&lt;a,b&gt;<br>$$<br>用来表示 $a$ 和 $b$ 有关系。注意，这里有顺序问题，即<strong>如果 $a \neq b$ ，则 $&lt;a,b&gt;$ 和 $&lt;b,a&gt;$ 是不一样的关系</strong>。在我们的语境中，**$&lt;a,b&gt;$ 可以表示通过 $a$ 可以访问到 $b$，也就是 $a$“指向” $b$**。</p>
<p>假设上述集合 $A$ 中的每个元素都是<strong>单向链表 $L$</strong> 的节点，则 $L$ 实际上就是如下的集合<br>$$<br>L&#x3D;{&lt;e_1, e_2&gt;,&lt;e_2,e_3&gt;,\cdots,&lt;e_{n-1}, e_{n}&gt;}<br>$$<br>假设上述集合 $A$ 中的每个元素都是<strong>双向链表 $L’$</strong> 的节点，则 $L’$ 实际上就是如下的集合<br>$$<br>L’&#x3D;{&lt;e_1,e_2&gt;,\cdots, &lt;e_{n-1}, e_n&gt;,&lt;e_n,e_{n-1}, \cdots,&lt;e_2,e_1&gt;}<br>$$<br>所以我们发现，<strong>链表之所以为链表，就在于其节点通过指针域描述了一种“指向”关系</strong>，至于数据域中有什么内容，是无关紧要的。换言之，我们如果对指针域进行适当的扩充、封装，配合上一系列函数，就可以实现通用链表。</p>
<h3 id="一种双向链表的构想"><a href="#一种双向链表的构想" class="headerlink" title="一种双向链表的构想"></a>一种双向链表的构想</h3><blockquote>
<p>我们发现很多同学喜欢使用双向链表，其实在作业题中并没有太大必要使用，<strong>徒增一个指针成员只会增加犯错的几率</strong>。</p>
</blockquote>
<p>我们使用链表时其实只会顺序地遍历链表，<strong>并不会逆序遍历</strong>，另外，[2.5 节](#2.5 链表的销毁)提到的链表销毁函数，也给了我们逆序遍历的思路。所以，使用指向前一个节点的指针，<strong>无非是为了在某些特定的插入删除操作中，快速地找到前一个节点，进而修改前一个节点的<code>next</code>指针</strong>。实际上，我们想要快速访问前一个节点的<code>next</code>指针，<strong>只需要拥有那个<code>next</code>成员的地址即可</strong>。换言之，<strong>这里的<code>prev</code>指针，可以不是前一个节点的指针，而是前一个节点的<code>next</code>成员的指针</strong>。</p>
<p>于是，我们可以构造一种新的链表结构。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-31 14.13.16.png"
                      alt="截屏2023-03-31 14.13.16" style="zoom:40%;" 
                >

<ul>
<li>有一个名为<code>linkedlist_t</code>的<strong>结构体</strong>，这是<strong>链表的类型</strong>，其中包含了头节点的指针和其他必要信息，用这个类型定义出的每一个变量即为一个<strong>链表对象</strong>。</li>
<li>链表的每一个<strong>节点</strong>是名为<code>listnode_t</code>的<strong>结构体</strong>，其中包含了数据域和指针域。</li>
<li>节点中的<strong>指针域</strong>是名为<code>listlink_t</code>的<strong>结构体</strong>，其中有两个成员<code>next</code>和<code>prev</code>。<code>next</code>是<code>listnode_t</code>的<strong>一级指针</strong>，<strong>指向下一个节点</strong>；<code>prev</code>是<code>listnode_t</code>的<strong>二级指针</strong>，<strong>指向上一个节点的<code>next</code>指针</strong>。</li>
</ul>
<p>如此封装双向链表的好处就在于<strong>把数据和链表的操作分离</strong>。假设我们规定节点中的数据域的类型永远是<code>listdata_t</code>类型，每次使用时，把我们需要的数据都封装进一个结构体并命名为<code>listdata_t</code>，则我们可以一直<strong>复用</strong>先前写好的、用于链表操作的函数。这是因为，如同前文所述，<strong>链表的所有逻辑组成，就是其指针之间的相互引用关系，而非节点中存放的数据</strong>，所以，我们把指针域专门提取出来并进行封装。</p>
<h2 id="面向对象的数据结构-——-链表篇"><a href="#面向对象的数据结构-——-链表篇" class="headerlink" title="面向对象的数据结构 —— 链表篇"></a>面向对象的数据结构 —— 链表篇</h2><h3 id="新类型的声明"><a href="#新类型的声明" class="headerlink" title="新类型的声明"></a>新类型的声明</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">listnode_t</span>;</span>  <span class="comment">// 这里我们先做一个前向声明，防止后续出现无法解析类型的问题</span></span><br><span class="line">                                 <span class="comment">// listnode_t 即为链表的节点类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>           <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> **<span class="title">prev</span>;</span>          <span class="comment">// 指向上一个节点的 next 的指针</span></span><br><span class="line">&#125; <span class="type">listlink_t</span>;                    <span class="comment">// listlink_t 是指针域类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>                    <span class="comment">// 链表的节点</span></span><br><span class="line">    <span class="type">listdata_t</span> data;             <span class="comment">// 数据域 —— 不用关心</span></span><br><span class="line">    <span class="type">listlink_t</span> link;             <span class="comment">// 指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">listnode_t</span> *head;            <span class="comment">// 链表头指针</span></span><br><span class="line">    <span class="type">listnode_t</span> *tail;            <span class="comment">// 链表尾指针</span></span><br><span class="line">    <span class="type">size_t</span> size;                 <span class="comment">// 链表的节点数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当然可以有更多，如最后一次修改时间、链表的创建者等</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="type">linkedlist_t</span>;                  <span class="comment">// linkedlist_t 即为链表类型，类比上次的 array_t</span></span><br></pre></td></tr></table></figure></div>

<h3 id="链表的初始化和销毁"><a href="#链表的初始化和销毁" class="headerlink" title="链表的初始化和销毁"></a>链表的初始化和销毁</h3><blockquote>
<p><strong><code>assert</code>的使用</strong></p>
<p><code>assert</code>即为<strong>“断言”</strong>，使用时，应该包含头文件<code>&lt;assert.h&gt;</code>。<code>assert</code>有一个参数，是一个<strong>条件表达式</strong>，例如<code>assert(a != b);</code>，这条语句的含义是“断言<code>a</code>不等于<code>b</code>”—— 假设<code>a</code>真的不等于<code>b</code>，<strong>断言成立，无事发生</strong>；假设<code>a</code>等于<code>b</code>，则<strong>断言不成立，代价是程序直接崩溃</strong>。所以我们书写的链表操作函数，传入<strong>链表类型的指针</strong><code>list</code>，可以先**断言<code>list</code>不是<code>NULL</code>**。如果传入了空指针，程序直接崩溃，避免后续的麻烦。</p>
<p><strong>另，以下代码注释中的调用方式全部在<code>main</code>中，并且假设在<code>main</code>的开头已经定义了<code>linkedlist_t list;</code><strong>，即一个名为<code>list</code>、类型为<code>linkedlist_t</code>的</strong>链表对象</strong>。</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_init</span><span class="params">(<span class="type">linkedlist_t</span> *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* === 初始化链表`list` ===</span></span><br><span class="line"><span class="comment">       调用方式：list_init(&amp;list);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>); <span class="comment">// 断言传入了一个非空的参数</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="literal">NULL</span>;    <span class="comment">// 初始化链表头节点为空</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;    <span class="comment">// 初始化链表尾节点为空</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">0</span>;       <span class="comment">// 初始化链表长度为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_destroy</span><span class="params">(<span class="type">linkedlist_t</span> *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* === 销毁链表`list` ===</span></span><br><span class="line"><span class="comment">       调用方式：list_destroy(&amp;list);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head != <span class="literal">NULL</span>) &#123;  <span class="comment">// 如果链表中有节点，则递归删除每一个节点</span></span><br><span class="line">        list_recursive_free(<span class="built_in">list</span>-&gt;head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="literal">NULL</span>;  <span class="comment">// 重置链表头节点为空</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;  <span class="comment">// 重置链表尾节点为空</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">-1</span>;    <span class="comment">// 重置链表长度为无效值 -1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_recursive_free</span><span class="params">(<span class="type">listnode_t</span> *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* === 递归删除链表节点 ===</span></span><br><span class="line"><span class="comment">       由 list_destroy 函数自动调用</span></span><br><span class="line"><span class="comment">       原理见本文第一部分</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;link.next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        list_recursive_free(node-&gt;link.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链表的头插和尾插"><a href="#链表的头插和尾插" class="headerlink" title="链表的头插和尾插"></a>链表的头插和尾插</h3><blockquote>
<p>我们可能需要一个函数来创建新节点，把数据域的指针传入这个函数，即可返回一个新节点</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">listnode_t</span> *<span class="title function_">list_newnode</span><span class="params">(<span class="type">listdata_t</span> *pdata)</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* === 创建并返回一个新节点，数据由`pdata`指明 ===</span></span><br><span class="line"><span class="comment">    调用方式：</span></span><br><span class="line"><span class="comment">       listdata_t data = &#123;1, 3.14, &#x27;c&#x27;, &quot;hello&quot;&#125;; // 假设这是数据域</span></span><br><span class="line"><span class="comment">       listnode_t *node = list_newnode(&amp;data);    // p 为指向新节点的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">listnode_t</span> *node = (<span class="type">listnode_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">listnode_t</span>));</span><br><span class="line">                                       <span class="comment">// 申请新节点的内存空间</span></span><br><span class="line"> assert(node != <span class="literal">NULL</span>);  <span class="comment">// 断言 malloc 成功(node 非空)</span></span><br><span class="line"> node-&gt;data = *pdata;   <span class="comment">// 数据赋值(结构体可以直接用等号赋值)</span></span><br><span class="line"> node-&gt;link.prev = node-&gt;link.next = <span class="literal">NULL</span>; <span class="comment">// prev 和 next 初始化为空</span></span><br><span class="line">                    <span class="comment">// 注意 prev 和 next 是 node 的成员 link 的成员</span></span><br><span class="line"> <span class="keyword">return</span> node;       <span class="comment">// 返回新节点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_insert_tail</span><span class="params">(<span class="type">linkedlist_t</span> *<span class="built_in">list</span>, <span class="type">listnode_t</span> *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* === 在链表`list`尾插入节点`node` ===</span></span><br><span class="line"><span class="comment">       (本函数可以实现链栈/队的压栈/入队)</span></span><br><span class="line"><span class="comment">       调用方式：list_insert_tail(&amp;list, list_newnode(&amp;data));</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail != <span class="literal">NULL</span>) &#123;            <span class="comment">// 如果尾节点存在(即链表非空)</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;link.next = node;    <span class="comment">// 【原来尾节点】的 next 指向 node 节点</span></span><br><span class="line">        node-&gt;link.prev = &amp;(<span class="built_in">list</span>-&gt;tail-&gt;link.next);</span><br><span class="line">                      <span class="comment">// 把【原来尾节点】的 next 的地址交给 node 节点的 prev 成员</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 如果尾节点不存在(即链表为空)</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;               <span class="comment">// 头节点指针指向 node</span></span><br><span class="line">        node-&gt;link.prev = &amp;(<span class="built_in">list</span>-&gt;head); </span><br><span class="line">                              <span class="comment">// 把【头节点指针】的地址交给 node 节点的 prev 成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = node;  <span class="comment">// 更新尾节点</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;       <span class="comment">// 更新节点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_insert_head</span><span class="params">(<span class="type">linkedlist_t</span> *<span class="built_in">list</span>, <span class="type">listnode_t</span> *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* === 在链表`list`头插入节点`node` ===</span></span><br><span class="line"><span class="comment">       (本函数可以实现链队的出队)</span></span><br><span class="line"><span class="comment">       调用方式：list_insert_head(&amp;list, list_newnode(&amp;data));</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head != <span class="literal">NULL</span>) &#123;          <span class="comment">// 如果头节点存在(即链表非空)</span></span><br><span class="line">        node-&gt;link.next = <span class="built_in">list</span>-&gt;head;  <span class="comment">// 新节点 node 的 next 指向【原头节点】</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;link.prev = &amp;(node-&gt;link.next);</span><br><span class="line">                      <span class="comment">// 【原头节点】的 prev 存放新节点 node 的 next 成员的地址</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                <span class="comment">// 如果头节点不存在(即链表为空)</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;  <span class="comment">// 维护尾节点(因为在此之前尾节点为 NULL)</span></span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;link.prev = &amp;(<span class="built_in">list</span>-&gt;head); <span class="comment">// 把【头节点指针】的地址交给 node 节点的 prev 成员</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = node;               <span class="comment">// 更新头节点指针</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;                    <span class="comment">// 更新节点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="节点的删除"><a href="#节点的删除" class="headerlink" title="节点的删除"></a>节点的删除</h3><blockquote>
<p><strong>链表的删除，需要知道前一个节点的指针，在单向链表中，这个操作需要遍历链表才能实现。</strong>在我们的双向链表中，我们可以<strong>通过<code>prev</code>成员访问到前一个节点的<code>next</code>成员，这是因为<code>prev</code>存放的正是前一个节点<code>next</code>成员的地址</strong>，从而很方便地修改其值。但是，考虑这样一种情况，如果我们删除的是<strong>尾节点</strong>，固然可以通过原来尾节点的<code>prev</code>访问到其前一个节点的<code>next</code>成员并将其置为<code>NULL</code>，然而我们<strong>还有一个链表尾指针<code>list-&gt;tail</code>需要维护</strong>，我们似乎并不能<strong>通过前一个节点的<code>next</code>成员的地址，获取前一个节点的地址</strong>……怎么办呢？</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-31 22.01.41.png"
                      alt="截屏2023-03-31 22.01.41" style="zoom:40%;" 
                >

<p>根据此图，我们看出，<strong>结构体内部成员按照我们声明的顺序连续存放</strong>，假如我们知道了<code>next</code>成员的地址，减去一个<strong>“偏移量”</strong>，就可以得到节点的首地址。很自然地会想到，<strong>这个偏移量或许是<code>sizeof(struct data)</code>或<code>sizeof(int) + sizeof(char) * 11</code><strong>。但不幸的是，为了实现结构体的<a class="link"   href="https://blog.csdn.net/x2528238270/article/details/120798606?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-120798606.nonecase&spm=1018.2226.3001.4187" >字节对齐 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，</strong>结构体的各个成员之间可能会被安排一些不用于存放数据的“空洞”</strong>，所以，单纯采用<code>sizeof</code>获取偏移量的方法是不可行的。</p>
<p>不过，<strong>只要各个结构体的形态一经声明，从节点首地址到<code>next</code>成员地址的这一段“差值”，必然固定</strong>，所以我们只需要直接通过<strong>指针值的相减</strong>，不就能得出偏移了多少个字节吗？不过，在进行指针相减的时候，<strong>我们应先把指针都转化为<code>void*</code>类型，才能做到真正的整数值相减</strong>；否则，有类型的指针做减法，得到的是“相差多少个该类型的元素”。</p>
<p><strong>直接给出偏移量的计算方法：<code>(size_t) &amp; (((listnode_t*)(0))-&gt;link.next)</code>。</strong></p>
<ul>
<li>我们知道，<code>NULL</code>即为保存着地址值<code>0</code>的指针，也称为空指针。既然是指针，我们可以将其强转为<strong>节点指针</strong>的类型，即<code>((listnode_t*)(0))</code>表示的含义。这一步强转，我们手中也就<strong>获取了一个从 0 地址开始往后存放的节点结构体，虽然这个结构体并不真实存在</strong>。</li>
<li>通过指针访问成员，对应<code>(((listnode_t*)(0))-&gt;link.next)</code>，这个表达式即为其<code>next</code>成员。</li>
<li>这个“虚拟结构体”地址从 0 开始，则<strong>它的</strong><code>next</code>成员的<strong>地址值</strong>，不正是<strong>“节点的<code>next</code>成员到节点首地址的偏移量”</strong>吗？所以我们取其地址，对应<code>&amp; (((listnode_t*)(0))-&gt;link.next)</code>这个表达式。</li>
<li>最后，我们把这个偏移量强转为无符号长整型<code>size_t</code>。</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_rmnode</span><span class="params">(<span class="type">linkedlist_t</span> *<span class="built_in">list</span>, <span class="type">listnode_t</span> *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* === 删除链表`list`中的节点`node` ===</span></span><br><span class="line"><span class="comment">       (如果 node 参数取 list-&gt;tail，可以实现链栈的弹栈)</span></span><br><span class="line"><span class="comment">       调用方式：</span></span><br><span class="line"><span class="comment">          // 通过某种方式得到了想要删除的节点 p</span></span><br><span class="line"><span class="comment">          list_rmnode(&amp;list, p);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="built_in">list</span>-&gt;tail) &#123; <span class="comment">// 假设要删除链表尾节点，则需要考虑维护 tail 指针的问题</span></span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> OFFSET_OF_NEXT = (<span class="type">size_t</span>) &amp; (((<span class="type">listnode_t</span>*)(<span class="number">0</span>))-&gt;link.next);</span><br><span class="line">            <span class="comment">// 根据上文所述，定义一个无符号长整型的常量(也可以写成宏)</span></span><br><span class="line">            <span class="comment">// 这个常量用来表示【节点的 next 成员的地址】和【节点的地址】间的差值(偏移量offset)</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = (<span class="type">listnode_t</span>*)((<span class="type">void</span>*)(node-&gt;link.prev) - OFFSET_OF_NEXT);</span><br><span class="line">            <span class="comment">// 维护尾节点指针</span></span><br><span class="line">            <span class="comment">// node-&gt;link.prev 是【原尾节点的前一个节点】的【next成员】的【地址】</span></span><br><span class="line">            <span class="comment">// (void*)(node-&gt;link.prev) 是使之进行整数减法运算</span></span><br><span class="line">            <span class="comment">// 减去偏移量得到【原尾节点的前一个节点】的【地址】的数值</span></span><br><span class="line">            <span class="comment">// 将这一地址的整数值强转成【节点指针listnode_t*】类型，交给list-&gt;tail</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --- 以下是任何情况下删节点都要做的操作 ---</span></span><br><span class="line">    </span><br><span class="line">    *(node-&gt;link.prev) = node-&gt;link.next;  <span class="comment">// 前一个节点的 next 指向要删除节点的下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;link.next != <span class="literal">NULL</span>) &#123;         <span class="comment">// 如果要删除节点后还有节点(即要删的不是尾节点)</span></span><br><span class="line">        *((node-&gt;link.next)-&gt;link.prev) = node-&gt;link.prev;</span><br><span class="line">                                           <span class="comment">// 后面那个节点的 prev 指向前面那个节点的 next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--; <span class="comment">// 更新节点个数</span></span><br><span class="line">    <span class="built_in">free</span>(node);   <span class="comment">// 最后才释放内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>当然，为了实现更完整的功能，你还需要编写更多函数。</p>
</blockquote>
<h2 id="宏的常见用法"><a href="#宏的常见用法" class="headerlink" title="宏的常见用法"></a>宏的常见用法</h2><blockquote>
<p>宏（macro）可以简化代码，并且减少<strong>硬编码</strong>的成分。关于硬编码的危害，这里不再赘述了。</p>
<p><strong>宏的名称应该全部大写，多个单词间用下划线分隔。</strong></p>
<p>这一部分我们仅列举使用方法，不再添加解释性的内容。</p>
</blockquote>
<h3 id="程序中频繁使用的常量的定义"><a href="#程序中频繁使用的常量的定义" class="headerlink" title="程序中频繁使用的常量的定义"></a>程序中频繁使用的常量的定义</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDGE_NUM 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERTEX_NUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 4.2 题括号匹配，你可能需要</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT_PARENTHESES   <span class="string">&#x27;(&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT_PARENTHESES  <span class="string">&#x27;)&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT_BRACE  <span class="string">&#x27;&#123;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT_BRACE <span class="string">&#x27;&#125;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D_QUOTE <span class="string">&#x27;\&quot;&#x27;</span> <span class="comment">// D for double</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_QUOTE <span class="string">&#x27;\&#x27;  // S for single</span></span></span><br><span class="line"><span class="string"><span class="meta">// 用一些整型常数定义程序当前状态，为 flag 赋值</span></span></span><br><span class="line"><span class="string"><span class="meta">#define NORMAL 0</span></span></span><br><span class="line"><span class="string"><span class="meta">#define IN_QUOTE 1</span></span></span><br><span class="line"><span class="string"><span class="meta">#define IN_COMMENT 2</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="定义小函数"><a href="#定义小函数" class="headerlink" title="定义小函数"></a>定义小函数</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ALPHA(x) (<span class="string">&#x27;A&#x27;</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="string">&#x27;Z&#x27;</span> || <span class="string">&#x27;a&#x27;</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="string">&#x27;z&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ALNUM(x) (IS_ALPHA(x) || <span class="string">&#x27;0&#x27;</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line">      <span class="comment">// 后续定义的宏可以用到已经定义过的宏</span></span><br><span class="line">      <span class="comment">// ctype.h 的这些函数名都是小写的，可见它们并不是用简单的宏定义的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// *** 宏的参数必须全部用括号括起来，否则会出现优先级问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE_1(x) (x * x)     <span class="comment">// 错误</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE_2(x) ((x) * (x)) <span class="comment">// 正确</span></span></span><br><span class="line"><span class="comment">// printf(&quot;%d\n&quot;, SQUARE_1(5 + 5)); 会被解析成</span></span><br><span class="line"><span class="comment">// printf(&quot;%d\n&quot;, 5 + 5 * 5 + 5);</span></span><br><span class="line"><span class="comment">// printf(&quot;%d\n&quot;, SQUARE_2(5 + 5)); 会被解析成</span></span><br><span class="line"><span class="comment">// printf(&quot;%d\n&quot;, (5 + 5) * (5 + 5));</span></span><br></pre></td></tr></table></figure></div>

<h3 id="定义复杂输出格式等"><a href="#定义复杂输出格式等" class="headerlink" title="定义复杂输出格式等"></a>定义复杂输出格式等</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OUTPUT(x1, y1, x2, y2, x3, y3)                 \</span></span><br><span class="line"><span class="meta">			printf(<span class="string">&quot;A(%d, %d) B(%d, %d), C(%d, %d)&quot;</span>,    \</span></span><br><span class="line"><span class="meta">			(x1), (y1), (x2), (y2), (x3), (y3))</span></span><br><span class="line"><span class="comment">// 分多行写则行末加上反斜杠表示连接</span></span><br></pre></td></tr></table></figure></div>

<h3 id="用宏定义功能模块"><a href="#用宏定义功能模块" class="headerlink" title="用宏定义功能模块"></a>用宏定义功能模块</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，开辟一个类型为`type`大小为`size`的数组，交给指针`p`</span></span><br><span class="line"><span class="comment">// 并且将这片内存都初始化为 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_AND_INIT(p, type, size) do &#123;            \</span></span><br><span class="line"><span class="meta">       (p) = ((type)*)malloc(sizeof(type) * (size));  \</span></span><br><span class="line"><span class="meta">       memset(p, 0, sizeof(type) * (size));           \</span></span><br><span class="line"><span class="meta">   &#125; while(0)</span></span><br><span class="line"><span class="comment">// 语句外套上无用的 do-while(0) 是为了在一些特殊情况防止分号的冲突</span></span><br></pre></td></tr></table></figure></div>

<p><em>Author: Riccardo, diandian</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第七期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%B8%83%E6%9C%9F/</url>
    <content><![CDATA[<blockquote>
<p>老规矩：若针对这些题目，同学们有更好更简洁的方法，欢迎来找助教讨论，助教请喝奶茶😍😍。</p>
</blockquote>
<h2 id="连续线段"><a href="#连续线段" class="headerlink" title="连续线段"></a>连续线段</h2><p>此题使用链表和数组的解法各有优劣。有些同学在写代码时容易默认输入的点是按x坐标顺序输入的，但其实不然，因此在后续<code>for</code>循环判断时第一层变量为<code>i</code>,第二层变量为<code>j = i + 1</code>，这样就忽略了可能在该线段之前的线段中存在相连的可能性。因此一种实用的做法为先对输入的所有点进行排序，这样在后续判断时也更有逻辑。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x1;</span><br><span class="line">    <span class="type">int</span> x2;</span><br><span class="line">    <span class="type">int</span> y1;</span><br><span class="line">    <span class="type">int</span> y2;</span><br><span class="line">&#125;line[<span class="number">201</span>];<span class="comment">//所有线段的点都存储在结构体数组中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * a, <span class="type">const</span> <span class="type">void</span> * b)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">e1</span> =</span> (<span class="keyword">struct</span> node *)a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">e2</span> =</span> (<span class="keyword">struct</span> node *)b;</span><br><span class="line">    <span class="keyword">if</span>(e1-&gt;x1 &gt; e2-&gt;x1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e1-&gt;x1 &lt; e2-&gt;x1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x3=<span class="number">0</span>, y3=<span class="number">0</span>;<span class="comment">//x3和y3存储当前需要判断是否能连接的点</span></span><br><span class="line">    <span class="type">int</span> i, j, n, count[<span class="number">201</span>]=&#123;<span class="number">0</span>&#125;, ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;line[i].x1, &amp;line[i].y1, &amp;line[i].x2, &amp;line[i].y2);</span><br><span class="line">    qsort(line, n, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> node), cmp);<span class="comment">//将输入的线段按照左端点横坐标排序</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        x3 = line[i].x2;</span><br><span class="line">        y3 = line[i].y2;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(line[j].x1 == x3 &amp;&amp; line[j].y1 == y3)&#123;</span><br><span class="line">                count[i]++;</span><br><span class="line">                x3=line[j].x2;</span><br><span class="line">                y3=line[j].y2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//因为已经排好序，所以直接顺位判断是否能连接，能连接则count++</span></span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count[i]&gt;ans)&#123;</span><br><span class="line">            ans=count[i];</span><br><span class="line">            j=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//找到最大的count，该循环为经典的寻找最大值or最小值的方法</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, ans+<span class="number">1</span>, line[j].x1, line[j].y1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="空闲空间申请模拟（最佳适应）"><a href="#空闲空间申请模拟（最佳适应）" class="headerlink" title="空闲空间申请模拟（最佳适应）"></a>空闲空间申请模拟（最佳适应）</h2><p>该题的题面较长，大家一定要看清楚每一个要求，踩坑的地方包括但不限于：</p>
<p>1、找不到足够大的空闲快，则什么操作都不发生；</p>
<p>2、并不是简单地寻找到空间恰好相等的节点，而是遍历一圈找到满足要求的空间最小的节点进行操作；</p>
<p>3、在删除节点时如果使用<code>free()</code>函数，则一定要保证这个空间后续不会再被使用；</p>
<p>4、一定要注意！不能访问到空指针。形如<code>if(p-&gt;length!=0 &amp;&amp; p != NULL)</code>的形式仍是不可以的，因为<code>p</code>如果是空指针，逻辑上if条件确实不会成立，但仍存在<code>p-&gt;length!=0</code>的判断，这样就访问到了空指针。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> address;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dot[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, op, min, flag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span>, *<span class="title">q</span>, *<span class="title">r</span>, *<span class="title">r_be</span>, *<span class="title">now</span>;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;dot[<span class="number">0</span>].address, &amp;dot[<span class="number">0</span>].length);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;dot[i].address, &amp;dot[i].length);</span><br><span class="line">        dot[i<span class="number">-1</span>].next = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        dot[i<span class="number">-1</span>].next = &amp;dot[i];</span><br><span class="line">    &#125;<span class="comment">//每次输入的时候，让前一节点的next指向当前节点，因此需先输入第0个节点</span></span><br><span class="line">    now = dot[n<span class="number">-1</span>].next = &amp;dot[<span class="number">0</span>];<span class="comment">//将物理意义上的最后一个节点与第一个节点相连</span></span><br><span class="line">    q = &amp;dot[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>((<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op))!=EOF)&#123;</span><br><span class="line">        r = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        r_be = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            p = now;</span><br><span class="line">            <span class="keyword">for</span>(q = p; q-&gt;next != p; q = q-&gt;next);</span><br><span class="line">            min = <span class="number">999999</span>;<span class="comment">//“新的开始”，每次进循环为min赋初值为一个较大的数</span></span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;length&gt;=op &amp;&amp; p-&gt;length &lt; min)&#123;</span><br><span class="line">                    r = p;</span><br><span class="line">                    r_be = q;</span><br><span class="line">                    min = p-&gt;length;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">while</span>(p != now);<span class="comment">//do-while循环结构可以有效循环遍历一圈，因为其先执行操作再判断</span></span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;length &gt; op)&#123;</span><br><span class="line">                    r-&gt;length -= op;</span><br><span class="line">                    now = r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;length == op)&#123;</span><br><span class="line">                    r-&gt;length = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(r-&gt;next != r)&#123;</span><br><span class="line">                        now = r-&gt;next;</span><br><span class="line">                        r_be-&gt;next = r-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        now = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;<span class="comment">//特判：如果当前只剩一个节点，则直接让这个节点为NULL</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = now;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//特判：如果当前节点已为空，相当于全部删除完，什么都不输出</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, p-&gt;address, p-&gt;length);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(p != now);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="多项式相乘"><a href="#多项式相乘" class="headerlink" title="多项式相乘"></a>多项式相乘</h2><p>本题需要注意：</p>
<p>1、链表与数组均可解决此问题，各有优劣；</p>
<p>2、注意数据范围，应用<code>long long</code>存储指数和系数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">duo</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> xi;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> zhi;</span><br><span class="line">&#125;a[<span class="number">81</span>], b[<span class="number">81</span>], ans[<span class="number">6561</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">duo</span>* <span class="title">ia</span> =</span> (<span class="keyword">struct</span> duo*)a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">duo</span>* <span class="title">ib</span> =</span> (<span class="keyword">struct</span> duo*)b;</span><br><span class="line">    <span class="keyword">if</span>((ia-&gt;zhi &lt; ib-&gt;zhi) || ((ia-&gt;zhi == ib-&gt;zhi) &amp;&amp; (ia-&gt;xi &gt; ib-&gt;xi)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="comment">//按照指数从大到小排列，若指数相同，则系数从小到大排列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>, i1, j1, k1;</span><br><span class="line">    <span class="type">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a[i].xi, &amp;a[i].zhi);</span><br><span class="line">        c1 = getchar();</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="comment">//用此种方法可以实现换行时结束读入，且\n与\r\n都可，请大家自己思考为什么</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;b[j].xi, &amp;b[j].zhi);</span><br><span class="line">        c2 = getchar();</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(c2 == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i1 = i;</span><br><span class="line">    j1 = j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; i1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; j1; j++)&#123;</span><br><span class="line">            ans[k].xi = a[i].xi * b[j].xi;</span><br><span class="line">            ans[k].zhi = a[i].zhi + b[j].zhi;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//多项式相乘法则</span></span><br><span class="line">    k1 = k;</span><br><span class="line">    qsort(ans, k1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> duo), cmp);<span class="comment">//排序，排完序后肯定会有指数相同的相邻项</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; (j &lt; k1) &amp;&amp; (i + j &lt; k1); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i+j].zhi == ans[i].zhi)&#123;</span><br><span class="line">                ans[i].xi += ans[i+j].xi;</span><br><span class="line">                ans[i+j].zhi = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;<span class="comment">//消除指数相同的项，系数全部相加</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k1 - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i].zhi != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld &quot;</span>, ans[i].xi, ans[i].zhi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld &quot;</span>, ans[k1<span class="number">-1</span>].xi, ans[k1<span class="number">-1</span>].zhi);<span class="comment">//为防止全部都为0，最后必须输出一次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="文件加密（环）"><a href="#文件加密（环）" class="headerlink" title="文件加密（环）"></a>文件加密（环）</h2><p>该题为本次作业的重重重灾区！问题主要出在：</p>
<p>1、对于输入的字符串没有预处理末尾的换行符，或者处理方式有问题，导致后面全部出错；</p>
<p>2、原密钥对应的最后一个字符的新密钥没有被赋值，导致最终密钥表缺失；</p>
<p>3、对链表的操作不熟悉，对于表头的使用、对于链表节点的插入、删除等操作出现问题；</p>
<p>4、使用野指针或访问空指针，定义局部指针时未初始化。</p>
<p>一些建议：</p>
<p>1、增加对链表的熟悉程度，插入、删除等操作可以自己总结成一个模版；</p>
<p>2、对于复杂的题目，模块化非常重要。自定义好各司其职的函数，<code>main</code>函数里保留逻辑部分；</p>
<p>3、调试方法与技巧！一定要善于使用<code>printf</code>函数进行打印调试。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">formation</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">formation</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">char</span> * b, <span class="type">char</span> * c)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i]==c[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==k)</span><br><span class="line">            c[k++]=b[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//对于输入的字符串b，删除其重复出现的字母，结果保存到c数组里</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sheet</span><span class="params">(<span class="type">char</span> * b, <span class="type">char</span> * c)</span>&#123;</span><br><span class="line">    <span class="type">char</span> re[<span class="number">95</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, j, k=<span class="number">0</span>, tmp[<span class="number">95</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    del(b,c);</span><br><span class="line">    j = (<span class="type">int</span>)<span class="built_in">strlen</span>(c);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">        tmp[c[i]-<span class="string">&#x27; &#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">95</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[i] == <span class="number">0</span>)</span><br><span class="line">            re[k++] = i + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;<span class="comment">//将剩余的且未出现过的可见字符保存到re数组里</span></span><br><span class="line">    <span class="built_in">strcat</span>(c,re);<span class="comment">//将re数组追加到c数组后，形成原密钥</span></span><br><span class="line">&#125;<span class="comment">//对于输入的字符串b，形成原密钥c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">final</span><span class="params">(<span class="type">char</span> * b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">formation</span> *<span class="title">List</span> =</span> <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>, *r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">95</span>; i++)&#123;</span><br><span class="line">        r = (<span class="keyword">struct</span> formation *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> formation));</span><br><span class="line">        r-&gt;c = b[j++];</span><br><span class="line">        <span class="keyword">if</span>(List == <span class="literal">NULL</span>)</span><br><span class="line">            List = p = r;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;link = r;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;link = List;<span class="comment">//到此为止，循环链表已经建立</span></span><br><span class="line">    r = p;</span><br><span class="line">    p = p-&gt;link;</span><br><span class="line">    k = p-&gt;c;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;link != p)&#123;</span><br><span class="line">        r-&gt;link = p-&gt;link;</span><br><span class="line">        j = p-&gt;c;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = (<span class="keyword">struct</span> formation *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> formation));<span class="comment">//free过后，记得再申请</span></span><br><span class="line">        p = r-&gt;link;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; j; i++, r=p, p=p-&gt;link);<span class="comment">//只一条for语句，注意移动次数，便寻得所需节点</span></span><br><span class="line">        b[j<span class="number">-32</span>] = p-&gt;c;<span class="comment">//建立该字符与原密钥的的字符的对应关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    b[p-&gt;c <span class="number">-32</span>] = k;<span class="comment">//最后剩下的字符的密文为原密钥的第一个字符</span></span><br><span class="line">&#125;<span class="comment">//将原密钥b进行处理，形成密钥表，依旧保存到b中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">33</span>]=&#123;<span class="number">0</span>&#125;, pre[<span class="number">95</span>]=&#123;<span class="number">0</span>&#125;, c;</span><br><span class="line">    FILE *in = fopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE *out = fopen(<span class="string">&quot;in_crpyt.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    gets(s);</span><br><span class="line">    sheet(s, pre);</span><br><span class="line">    final(pre);<span class="comment">//逻辑部分在main函数里实现，具体操作可适当封装成函数，这样调试起来也方便发现错误</span></span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(in)) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="number">32</span> &amp;&amp; c&lt;=<span class="number">126</span>)</span><br><span class="line">            fputc(pre[c<span class="number">-32</span>], out);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fputc(c, out);</span><br><span class="line">    &#125;<span class="comment">//注意不可见字符要原样输出！</span></span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="词频统计（数组或链表实现）"><a href="#词频统计（数组或链表实现）" class="headerlink" title="词频统计（数组或链表实现）"></a>词频统计（数组或链表实现）</h2><p>本题使用数组或链表都是可以做的，但个人认为数组会更简洁。需要注意的是，题目中明确说明<strong>单词仅为有字母组成的字符序列</strong>，但并没有说<strong>单词与单词之间一定由空格隔开</strong>，不能只看样例而轻下论断，因此使用<code>fscanf</code>读取单词肯定是会出问题的。</p>
<p>一些建议：当明确地需要执行排序操作时，数组比链表更为简洁。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> word[<span class="number">51</span>];</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;wordlist[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * a, <span class="type">const</span> <span class="type">void</span> *b)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">e1</span> =</span> (<span class="keyword">struct</span> node*)a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">e2</span> =</span> (<span class="keyword">struct</span> node*)b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(e1-&gt;word,e2-&gt;word);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> table[<span class="number">5120</span>]=&#123;<span class="number">0</span>&#125;, c;</span><br><span class="line">    FILE *in = fopen(<span class="string">&quot;article.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, j, k, len, total=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((c = fgetc(in)) != EOF)</span><br><span class="line">        table[i++] = c;<span class="comment">//将文件中所有字符读进一个字符串数组</span></span><br><span class="line">    len = i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isalpha</span>(table[i]))<span class="comment">//如果不是字母</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j = <span class="number">0</span>;<span class="comment">//“新的开始”，每次需要加入新的单词时，给j赋初值为0</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isalpha</span>(table[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">islower</span>(table[i]))<span class="comment">//如果是小写字母</span></span><br><span class="line">                    wordlist[total].word[j++] = table[i];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isupper</span>(table[i]))<span class="comment">//如果是大写字母</span></span><br><span class="line">                    wordlist[total].word[j++] = table[i] + <span class="number">32</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            wordlist[total].word[j] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//最后一定要加上&#x27;\0&#x27;</span></span><br><span class="line">            wordlist[total].count = <span class="number">1</span>;<span class="comment">//让该单词的出现次数为1</span></span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; total; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(wordlist[k].word,wordlist[total].word) == <span class="number">0</span>)&#123;</span><br><span class="line">                    wordlist[k].count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//立即在已有的字母表中查找，若存在，则total维持原值，且对应单词count++</span></span><br><span class="line">            <span class="keyword">if</span>(k == total)</span><br><span class="line">                total++;<span class="comment">//若该单词不存在于现有单词表中，total++，表示将其加入单词表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(wordlist, total, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> node), cmp);<span class="comment">//按照字典序排序</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; total; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, wordlist[i].word, wordlist[i].count);</span><br><span class="line">    fclose(in);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>answers</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第八期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%85%AB%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="有关期中考试的强调"><a href="#有关期中考试的强调" class="headerlink" title="有关期中考试的强调"></a>有关期中考试的强调</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>期中考试时间为4月27日晚19:00-21:00，考试时间为2小时。</strong></li>
<li>重视期中考试前的模拟考试，到时候助教会强调与提醒一些内容，请一定牢记。</li>
<li>编程题提交后可看到评测结果，如<strong>“完全正确”</strong>、<strong>“输出错误”</strong>等，但<strong>没有详细错误信息</strong>。</li>
<li>若提交后，发现并不是所有数据点都全对，并且<code>judge</code>平台显示很多<strong>warning</strong>，请一定逐条仔细查看，尽量都修改一下。有些时候，一道题的错因就在这些<strong>warning</strong>里，且一般主要问题都集中在自定义的非<code>void</code>型函数缺少返回值。</li>
<li>选填题目不确定的，就用本地IDE运行一下查看结果，如果是概念题不确定的可以暂时放一放，以编程题为主，毕竟编程题的分值很重。</li>
<li><strong>请一定带上草稿纸、笔、大一上程设教材、大一下数据结构教材！！！</strong>到时候如果需要查询<code>ASCII</code>码表等内容时，可以直接在教材附录查询，<strong>不能上网！！！不能上网！！！不能上网！！！</strong></li>
<li>对于编程题（共两道）：<ul>
<li><strong>千万不要题目没读懂就急着敲代码！！！</strong></li>
<li>在题目中，尤其是<strong>红字标注</strong>的地方或者<strong>题面自身出现的注意事项</strong>，一定要牢记，避免写代码时忘记这些易错点，导致后续排坑浪费掉很多时间（相信大家都有过因为<strong>文件名写错或者输入输出方式写错</strong>而de好几个小时bug、浪费好几个小时的时间的经历吧）。</li>
<li>建议大家读完题目之后，先简要思考一下该用什么<strong>数据结构</strong>，是数组？还是链表？链表是单向的？还是双向的？需不需要使用循环链表？</li>
<li>大家考试时可以多在草稿纸上写一写，<strong>选填题目可以在草稿纸上推一推，编程题目可以在草稿纸上画一画流程图，</strong>这样也可以缓解考场上的紧张情绪。很多时候，题目的逻辑与解题思路清楚了，写代码也就不会东一句西一句。</li>
</ul>
</li>
</ul>
<h3 id="复习要点"><a href="#复习要点" class="headerlink" title="复习要点"></a>复习要点</h3><ul>
<li>考试主要内容对应前三次作业范围，且不涉及文件输入输出，内容不多，重点在于字符串的处理以及线性表（包括数组和链表）。</li>
<li>考试题目类型为：选填共10道（每道0.5分）、编程题2道（<strong>第一题15分，第二题10分</strong>），共30分，<strong>考试得分将全额计入课程总评</strong>。</li>
<li>前三次作业的选填还有不太懂的地方抓紧时间弄懂，可以和同学讨论，也可以来问助教。</li>
<li><strong>编程题一定是重点！！</strong>上机作业里的编程题一定要理解，只有对于每一种操作熟练掌握，才能提高代码的一次性正确率。我们也为大家提供了题解，题解中封装了不少常用操作，希望大家抽时间看看。</li>
<li>老师的授课ppt也是非常重要的，上面有很多基础概念，可以帮助大家做选填题；ppt上也有一些例题的代码，其中的思路和操作也值得大家学习。</li>
<li>平时我们发的资料与老师的授课ppt都汇总在北航云盘里了，我们也在bhpan里共享给了大家，有需要自取：</li>
<li><a class="link"   href="https://bhpan.buaa.edu.cn/link/AE82D268627E33234B178D5416D2AF03" >https://bhpan.buaa.edu.cn:443/link/AE82D268627E33234B178D5416D2AF03 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h3 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h3><ul>
<li>字符串的处理问题在前三次作业中从未缺席，同时也是我们一直在上机时或者课程群里重点强调的问题，我们针对字符串容易出现的<code>bug</code>也出了好多次猪脚说，也希望引起大家的重视。</li>
<li>作业中有关字符串处理的较复杂的编程题，一定要再看看，加深理解，以便在考场上尽快解决相关问题。</li>
<li>如果有些同学在考前想要做额外的题练练手，可以参考之前助教说给出的补充习题。</li>
<li>注意<code>strcpy</code>、<code>strcat</code>等函数的使用条件（包括<strong>内存区域不能重叠、源字符串必须以<code>&#39;\0&#39;</code>结尾</strong>等），如果考试时对于一些字符串处理库函数的细节不太清楚，可查阅《C程序设计引导》的第125页（如果大家还没有把这本书扔掉的话）。</li>
<li>注意**字符串结尾一定要有终止符<code>&#39;\0&#39;</code>**，或者在处理完字符串后，自己手动在末尾加上<code>&#39;\0&#39;</code>，或者初始化将字符输出全部赋值为<code>&#39;\0&#39;</code>。</li>
<li>再次强调<code>\r\n</code>的问题，有不少同学到现在还是会在这个点上犯错，字符串读入时一定要严谨处理，**实在不行就老老实实用<code>gets()</code>**，具体可见课程群聊天记录。</li>
<li>多总结一下平时在自己身上发生的或者向助教提问时助教提醒你的问题，在考试时尽量避免犯相同的错误。</li>
</ul>
<h3 id="关于线性表"><a href="#关于线性表" class="headerlink" title="关于线性表"></a>关于线性表</h3><ul>
<li><strong>前三次作业中出现的涉及链表的编程题，大家一定要理解并掌握！！！</strong></li>
<li>链表的相关操作也是期中考试的考查重点，对于链表的基本操作可以再去复习一下。</li>
<li>不同的链表结构，例如双向链表、循环链表，它们的节点插入、删除等基本操作，在课件里也有，大家如果还有不清楚的地方，可以再把ppt的相关内容过一遍。</li>
<li>在考场上，如果不确定自己写的代码中的链表操作的正确性，不清楚应该先赋值哪个指针、后赋值哪个指针，<strong>建议在草稿纸上画图推算，通过画图来模拟链表的节点插入、删除等操作</strong>，可以使思路更清晰。</li>
<li>我们写的第三次作业题解中，第二题给出了链表操作的示例代码，里面的一些片段或许可以直接封装使用。</li>
<li>再次强调，<strong>链表操作涉及指针时，一定要注意是不是访问了空指针！！！</strong></li>
</ul>
<h3 id="常见编译器警告与错误"><a href="#常见编译器警告与错误" class="headerlink" title="常见编译器警告与错误"></a>常见编译器警告与错误</h3><ul>
<li><code>SIGSEGV</code>：指针使用错误（使用之前一定要初始化以及判断是否访问到了空指针）、栈越界（递归调用时需要注意避免无限递归的存在）、数组访问越界等原因导致。</li>
<li><code>SIGABRT</code>：对一个指针执行连续<code>free操作</code>、<code>free</code>错误的地址、堆越界等原因导致。</li>
<li><code>SIGFPE</code>：算术错误，一般是因为在运算时发生了除以0的运算。</li>
<li><code>Unused Variables</code>：这个警告无关紧要，可以忽略。</li>
<li><code>Function return with no value in non-void functions</code>：这个问题一定要避免并解决！！！</li>
<li><code>Uninitialized variables</code>：一定要改！！！</li>
</ul>
<h2 id="一个奇怪的问题"><a href="#一个奇怪的问题" class="headerlink" title="一个奇怪的问题"></a>一个奇怪的问题</h2><p>同学们在 judge 平台上提交代码的时候，有没有好奇过这个细节？</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets8/截屏2023-04-13 11.05.30.png"
                      alt="截屏2023-04-13 11.05.30" style="zoom:30%;" 
                >

<p>诚然，我们只需要提交 .c 文件即可，想必把这个文件装入文件夹，将文件夹压缩成压缩包交上去，也是可行的。但是，显然不会有人多此一举，交一个仅含有一个文件的压缩包上去。所以很明显，压缩包对应着的，应该是含有多个文件的一个<strong>项目（Project）</strong>。</p>
<p>这时候问题就来了，C 语言项目长什么样呢？或许里面有多个 .c 文件，那还应该有什么呢？我们只实操过单个源代码文件的编译运行，多份源代码文件又要注意什么呢？如果我们把一个程序拆分成多个模块，编译器又要凭借什么把它们组织在一起呢？</p>
<p>我们不妨首先尝试探索，一份 main.c 文件应该怎么<strong>从逻辑上拆分</strong>成各个子模块。</p>
<ul>
<li><p>头文件包含，这是我们调用一些函数所必须的，如<code>printf</code> <code>malloc</code>。</p>
</li>
<li><p>通过<code>#define</code>定义一些<strong>符号常量</strong>，有助于简化代码。</p>
</li>
<li><p>声明结构体、联合等<strong>自定义的复合数据类型</strong>。</p>
</li>
<li><p>声明函数原型。</p>
<blockquote>
<p>特别注意，<strong>函数原型的声明只是给编译器看的</strong>，只是为了让它识别<strong>“有这样一个函数”</strong>。编译过程<strong>顺序扫描</strong>文本，当编译器明白了有这么一个函数之后，在<code>main</code>中调用这个函数就是合法的，调用这个函数后具体怎么执行，靠的是<code>main</code>后面的函数定义，这就无需关心；不写函数原型声明而直接把函数定义在<code>main</code>前面是可行的，这样编译器在读到函数的时候不仅知道了函数的存在性，也知道了它的执行步骤，后续在<code>main</code>中调用自然是可以的，只是<strong>不写函数原型声明，直接把函数定义放在<code>main</code>前面不符合编程规范</strong>。</p>
</blockquote>
</li>
<li><p>全局变量的定义。</p>
</li>
<li><p><code>main</code>函数。这是程序执行的入口。</p>
</li>
<li><p>其他函数的实现。</p>
</li>
</ul>
<p>通过简单的思考我们可以发现，如果<strong>以函数为单位</strong>划分程序，则我们有如下两条原则</p>
<ul>
<li><strong><code>main</code>函数应该单独拎出来考虑</strong>，因为它体现着程序核心的逻辑，程序的运行从它开始、从它结束。</li>
<li><strong>其他函数应该按照功能分组</strong>，如运算类函数一组，字符串操作类函数一组，链表操作类函数一组。</li>
</ul>
<p>以往，我们把所有东西放在一个文件里，大家坦诚相见，在文件开头声明的<code>struct A</code>，可以被每一个函数知道是什么东西。试想如果按照上述的分组思路，把各个模块放进不同的文件里，<code>struct A</code>又要怎么处理呢？为了让每一个文件里的函数都知道<code>struct A</code>，难道要在每个文件的开头都声明一遍吗？</p>
<p>另一方面，我们考虑变量。局部变量，常见的有标记当前位置的<code>pos</code>，表示数据组数的<code>n</code>，用于循环的<code>i</code>和在程序的局部表示某种状态的<code>flag</code>等。事实上，这些变量的作用是<strong>服务于函数自身的实现</strong>，一个函数的局部变量和另一个函数的局部变量并无关联。全局变量则应该在程序全局共享，因为它们有可能是<strong>全局都要访问的某些核心数据结构</strong> —— 比如，在一款音乐播放软件中，歌曲的下载、收藏和历史记录等都会涉及用户账户信息，则这个信息应该处在全局的位置被共享。问题又来了，如果一个程序由多个文件组成，一个全局变量应该定义在哪里呢？</p>
<p>以上描述主要想说明，从一个源代码文件过渡到多文件的项目是有必要且可行的，但存在很多困难，主要有两点：**(1) 如何对原有代码进行拆分；(2) 如何在各个文件间共享必要的信息**。</p>
<h2 id="另一个奇怪的问题"><a href="#另一个奇怪的问题" class="headerlink" title="另一个奇怪的问题"></a>另一个奇怪的问题</h2><blockquote>
<p><strong>悬赏</strong></p>
<p>在你的计算机设备上找到<code>printf</code>函数的源代码，最先找到者请吃一学期疯狂星期四。</p>
</blockquote>
<p>当然，在找之前，不妨先看看下面的文字。</p>
<p>首先给出<code>printf</code>的函数原型。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<p>这里的<code>fmt</code>参数就是格式串，后面的<code>...</code>是 C 的语法，表示<strong>可变参数列表</strong>（以后有机会可以介绍）。我们在<code>fmt</code>中指定要输出的内容，如果是普通字符则直接输出，如果是以<code>%</code>开头的某些特殊内容，则会到后面的参数中寻找并替换，当然也支持保留小数位数、左右对齐等更细节的格式。</p>
<p>同学们心安理得地用了这么久<code>printf</code>，有没有考虑过它是怎么实现的呢？似乎只要<code>#include &lt;stdio.h&gt;</code>，就能随心所欲地调用它了。然而，正因为它被调用得如此频繁，作为一个 C 库函数，它早已被打包成<strong>共享库</strong>，存在于系统文件之中，它的具体的 C 语言代码，是不在系统之中的。</p>
<blockquote>
<p>共享库文件是一个<strong>二进制文件</strong>，其中包含着某些可运行但不可单独运行的代码。当我们编译出hello_world.exe 可执行文件并运行时，运行到<code>printf(&quot;Helllo World\n&quot;);</code>这行代码，系统会跳转去执行共享库中属于<code>printf</code>函数的代码，从而实现了库函数的调用。</p>
</blockquote>
<p>那么，编译器在编译我们的 hello_world.c 文件时，又是如何知道<code>printf</code>的存在呢？答案其实就在<code>&lt;stdio.h&gt;</code>中，这个<strong>头文件（header）</strong>里，包含了<code>printf</code>的原型声明；编译器在<strong>预处理阶段</strong>，会在<code>#include &lt;stdio.h&gt;</code>这一句<strong>预处理指令</strong>的地方，<strong>原封不动地插入<code>&lt;stdio.h&gt;</code>的全部内容</strong>，显然这些内容中包括<code>printf</code>的声明，以及其他我们未用到的函数声明。于是，我们在<code>main</code>的前面有了<code>printf</code>函数的原型，在程序中也就可以调用了。</p>
<p>以前我们提到，**<code>FILE</code>类型是一个结构体，这个结构体及其别名的声明，同样位于<code>&lt;stdio.h&gt;</code>中**，于是我们也可以在包含了这个头文件之后，使用<code>FILE</code>类型。</p>
<blockquote>
<p><code>&lt;stdio.h&gt;</code>局部</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets8/截屏2023-04-13 15.58.05.png"
                      alt="截屏2023-04-13 15.58.05" style="zoom:25%;" 
                >

<p><code>&lt;stdlib.h&gt;</code>局部</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets8/截屏2023-04-13 15.59.25.png"
                      alt="截屏2023-04-13 15.59.25" style="zoom:25%;" 
                >

<p><code>&lt;string.h&gt;</code>局部</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets8/截屏2023-04-13 15.59.49.png"
                      alt="截屏2023-04-13 15.59.49" style="zoom:25%;" 
                >
</blockquote>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h3 id="宏的定义与类型声明"><a href="#宏的定义与类型声明" class="headerlink" title="宏的定义与类型声明"></a>宏的定义与类型声明</h3><p>有了这样的观念，我们就可以尝试编写自己的头文件了。当然，如果要使用头文件，我们最好在 IDE 中先新建一个项目，这个项目一般会默认有一个 main.c，然后我们在同一个<strong>目录（即文件夹，以后统称目录）</strong>下新建一个<code>myheader.h</code>。</p>
<blockquote>
<p>实际上，<strong>头文件的后缀名是不重要的</strong>。C 的传统风格的头文件都是 .h 后缀，C++ 则另起炉灶。在 C++ 中，原有的 C 头文件基本兼容，名字都以 c 打头且没有后缀，如 <code>&lt;cstdio&gt;</code> <code>&lt;cstdlib&gt;</code> <code>&lt;cstring&gt;</code>，当然包含原有的 C 头文件也可以，因为它们都在系统之中。C++ 也有自己独有的头文件，如 <code>&lt;queue&gt;</code> <code>&lt;stack&gt;</code> <code>&lt;algorithm&gt;</code> <code>&lt;iostream&gt;</code>等。</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myheader.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">  <span class="comment">// 在自己的头文件中可以包含其他头文件</span></span><br><span class="line">  <span class="comment">// 这里我们要使用 FILE 类型，所以要包含 stdio.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 32</span></span><br><span class="line">  <span class="comment">// 在自己的头文件中可以定义宏</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">char</span> content[MAX_LEN];</span><br><span class="line">&#125; Word;</span><br><span class="line">  <span class="comment">// 在自己的头文件中可以声明自定义复合数据类型</span></span><br></pre></td></tr></table></figure></div>

<p>这样，如果我们要在 main.c 中使用<code>MAX_LEN</code>宏或<code>Word</code>类型，只需要在 main.c 开头包含<code>myheader.h</code>头文件即可：<code>#include &quot;myheader.h&quot;</code>。</p>
<blockquote>
<p>头文件名可以用<code>&lt;&gt;</code>也可以用<code>&quot;&quot;</code>括起来，区别在于：<strong>尖括号一般用于系统的头文件</strong>，在查找时会首先到系统的库中查找，找不到时才在项目目录中查找；<strong>双引号一般用于自定义头文件</strong>，会优先在当前项目中查找。</p>
</blockquote>
<h3 id="函数声明与实现"><a href="#函数声明与实现" class="headerlink" title="函数声明与实现"></a>函数声明与实现</h3><p>我们也可以<strong>在头文件中声明函数原型，在其他的源代码文件中实现该函数。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 myheader.h 中插入</span></span><br><span class="line">Word *<span class="title function_">create_word</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="comment">// 这个函数创建一个 Word 结构体并返回其指针</span></span><br><span class="line"><span class="comment">// 将其中的文件指针设置为 NULL，cnt 设置为 0</span></span><br><span class="line"><span class="comment">// 将 content 数组填满字符 c</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在项目中新建 myheader.c 源代码文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span> <span class="comment">// 我们会用到其中的 Word 类型、MAX_LEN 宏</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   <span class="comment">// 我们在实现 create_word 时会用到 malloc 函数</span></span></span><br><span class="line">Word *<span class="title function_">create_word</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    Word *p = (Word*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Word));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// malloc 出错返回 NULL</span></span><br><span class="line">    p-&gt;fp = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LEN; i++) p-&gt;content[i] = c;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 main.c 中可以测试，<strong>在项目中执行编译</strong>会把多个源代码文件联合起来编译，但只能有一个函数叫做<code>main</code>，它仍是程序的入口。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Word *word = create_word(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (word != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        word-&gt;content[MAX_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 使之变成一个字符串</span></span><br><span class="line">        <span class="keyword">if</span> (word-&gt;fp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;word-&gt;fp is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (word-&gt;cnt == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;word-&gt;cnt is 0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;word-&gt;content: %s\n&quot;</span>, word-&gt;content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>我们知道，在多数情况下，<strong>同一个变量是不能定义多次的</strong>，如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="type">int</span> a;     <span class="comment">// 全局变量 a</span></span><br><span class="line"><span class="comment">// int a;  // 再次定义全局的 a 就会出错</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// 定义局部的 a 可以，此时无法在 main 中访问全局的 a</span></span><br><span class="line">    <span class="comment">// int i;   // 再次定义局部的 i 就会出错</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++);</span><br><span class="line">      <span class="comment">// 这个 i 属于 for 循环，仅在循环内有效，这个 i 会屏蔽掉 main 的局部的 i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>头文件解决全局变量问题的思路是，<strong>在头文件中声明某个全局变量的存在，在某一个源代码文件中的全局的位置定义该全局变量，在所有用到该全局变量的源代码文件中都应先包含头文件</strong>。例如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myheader.h 中插入</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global;</span><br><span class="line"><span class="comment">// extern 关键字告诉编译器，我的程序中会有一个全局变量</span></span><br><span class="line"><span class="comment">// 它的类型是 int，名字叫 global</span></span><br><span class="line"><span class="comment">// 显然 extern 只是声明全局变量的存在，不能在此时初始化</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myheader.c 文件第一行插入</span></span><br><span class="line"><span class="type">int</span> global = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 在某一处定义了该全局变量</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c 的 main 函数中访问该全局变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;global = %d\n&quot;</span>, global);</span><br></pre></td></tr></table></figure></div>

<h3 id="静态变量和函数"><a href="#静态变量和函数" class="headerlink" title="静态变量和函数"></a>静态变量和函数</h3><p>考虑这样一个情形，现在需要开发一个银行管理系统，其中，存款、取款、查看余额等函数已经写好，实现在 bank.c 中，并且声明在 bank.h 中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bank.h</span></span><br><span class="line">“账户”结构体声明</span><br><span class="line">存款函数声明</span><br><span class="line">取款函数声明</span><br><span class="line">查看余额函数声明</span><br><span class="line">添加账户函数声明</span><br><span class="line">删除账号函数声明</span><br><span class="line"><span class="comment">// bank.c</span></span><br><span class="line">存款函数实现</span><br><span class="line">取款函数实现</span><br><span class="line">查看余额函数实现</span><br><span class="line">添加账户函数实现</span><br><span class="line">删除账号函数实现</span><br></pre></td></tr></table></figure></div>

<p>现在我们请人为我们在 main.c 中实现这个系统的图形界面，如点击某个按钮就可以查看余额等。试想，我们应该仅把 bank.h 文件交给对方，这样对方就能知道如何调用函数了。多个银行客户的信息应当存放在一个“账户”类型的结构体数组中，<strong>如果由对方在 main.c 中创建这个全局变量，则可以在 main.c 中任意地访问这个数组，直接操作银行客户的数据，这是我们不可接受的</strong>。</p>
<p>实际上，如果把这个数组当成全局变量，就必然会存在上述问题。我们希望<strong>在 bank.c 中的每一个函数内</strong>，都能访问该数组，但又<strong>不希望它被 main.c 访问</strong>，因为 main.c 只需要调用 bank.c 的函数并接收其返回值即可。这就需要 bank.c 中有一个<strong>仅属于该文件的、并且是全局性质的变量</strong>。</p>
<p><strong>用<code>static</code>关键字修饰全局变量，则这个变量的全局性仅限于某一个文件。</strong>具体来说，在上述例子中，我们可以在 bank.c 的开头定义</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Account accounts[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></div>

<p>这样，这个数组可以被 bank.c 中的每一个函数访问，但不能被其他文件的函数访问。我们可以把 bank.c 单独编译封装为一个模块，未来在 main.c 编写完毕后与之一同编译产生最终的可执行文件。<strong>main.c 请第三方人员编写，它们只需要根据头文件中的函数原型进行调用，而无法操作到客户账户的数据。</strong></p>
<blockquote>
<p><code>static</code>关键字也可以用来修饰函数，被它修饰的函数仅在本文件内有效。</p>
</blockquote>
<p>例如，我们之前实现过可变长数组的封装，其中的增删改查等函数是由用户调用的，但是，数组的生长函数应该由“增”函数自动调用，而不应该开放给用户，此时在 array.c 中就可以这么写</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">array_grow</span><span class="params">(<span class="type">array_t</span> *arr)</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_addtail</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> var)</span> &#123;</span><br><span class="line">    <span class="comment">// call array_grow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>再比如，我们要用栈实现一个计算器并封装，我们希望调用方式是</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;result: %d\n&quot;</span>, calculate(<span class="string">&quot;3 + 4 * (5 / 2) - 1&quot;</span>));</span><br></pre></td></tr></table></figure></div>

<p>则我们可以在 calculator.c 中组织</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="built_in">stack</span>[<span class="number">105</span>];</span><br><span class="line">    <span class="comment">// 静态的全局变量，仅在此文件中可以访问，main 不能直接操作它</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 静态的全局变量，仅在此文件中可以访问，main 不能直接操作它</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123; </span><br><span class="line">    <span class="comment">/* 计算表达式 s 的结果 */</span> </span><br><span class="line">    <span class="comment">// 这个函数是给用户调用的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">char</span> op)</span> &#123;</span><br><span class="line">    <span class="comment">/* 判断运算符优先级*/</span></span><br><span class="line">    <span class="comment">// 仅在本文件内有效，由 calculate 调用，以下四个函数同理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a - b; &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a * b; &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a / b; &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h3><p><strong>声明重复多次是可以的，但是定义则不可以。</strong>很多情况下，一个头文件会在一个项目的多个文件中被重复包含多次，这很可能产生错误。事实上，考虑到<code>#include</code>的展开文本的本质，我们只希望<strong>头文件的内容在项目中仅被展开一次</strong>，这就需要用到<strong>头文件保护符</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _NAME_H_ <span class="comment">// 如果未定义标识符 _NAME_H_</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NAME_H_ <span class="comment">// 则定义标识符 _NAME_H_</span></span></span><br><span class="line"><span class="comment">// 头文件正文</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>           <span class="comment">// 结束上述 if 判断</span></span></span><br><span class="line"><span class="comment">/* 三条预处理指令的逻辑:</span></span><br><span class="line"><span class="comment">  if not define xx &#123;</span></span><br><span class="line"><span class="comment">      define xx</span></span><br><span class="line"><span class="comment">      extend contents</span></span><br><span class="line"><span class="comment">  &#125; */</span></span><br></pre></td></tr></table></figure></div>

<p>首先说明，这里的<code>_NAME_H_</code>只是惯用的写法，例如在<code>&lt;string.h&gt;</code>中就会用到<code>_STRING_H_</code>这个标识符。以上三条指令的直接翻译已经注释，当我们在项目中重复包含一个头文件时，<strong>预处理阶段</strong>第一次碰到这个头文件，发现<code>_NAME_H_</code>是<strong>未定义</strong>的（显然这么个奇奇怪怪的符号不太可能在之前被就你<code>#define</code>过），则判断条件成立，执行第二句<code>#define</code>语句，也就定义了这个符号，随后展开了头文件正文，结束条件判断。此后如果再碰到需要包含这个头文件的地方，会先判断<code>_NAME_H_</code>是否定义，结果是已经定义过了，则直接跳到<code>#endif</code>处，而不会再展开了。</p>
<p><strong>头文件保护符加在头文件的头尾，是推荐使用的例行编码习惯。</strong></p>
<h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><blockquote>
<p>实现一个银行存款和查看余额模拟。项目中有 test.c(测试)，bank.c，bank.h 三个文件。</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bank.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BANK_H_                <span class="comment">// 头文件保护符，这是例行写法</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BANK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_LENGTH 10  <span class="comment">// 定义账户 ID 号最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CNT_MAX 100   <span class="comment">// 定义最多有 100 个账户</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>         <span class="comment">// 声明账户类型</span></span><br><span class="line">    <span class="type">char</span> id[ID_LENGTH];  <span class="comment">// 账户 ID 号</span></span><br><span class="line">    <span class="type">int</span> balance;         <span class="comment">// 账户余额</span></span><br><span class="line">&#125; Account;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_account</span><span class="params">(<span class="type">char</span> *id)</span>;     <span class="comment">// 添加新账户</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *id, <span class="type">int</span> money)</span>; <span class="comment">// 往账户 id 中存款 money</span></span><br><span class="line">Account <span class="title function_">get_idx</span><span class="params">(<span class="type">int</span> idx)</span>;       <span class="comment">// 获取下标为 idx 的账户</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_num</span><span class="params">()</span>;                  <span class="comment">// 获取账户数量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bank.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bank.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// 要用到 strcmp 查找账户</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Account accounts[CNT_MAX]; <span class="comment">// 静态的 Account 数组，仅本文件访问</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;               <span class="comment">// 账户数量计数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_account</span><span class="params">(<span class="type">char</span> *id)</span> &#123;      <span class="comment">// 在数组尾部添加元素</span></span><br><span class="line">    <span class="built_in">strcpy</span>(accounts[cnt].id, id);</span><br><span class="line">    accounts[cnt].balance = <span class="number">0</span>;    <span class="comment">// 初始化余额为 0</span></span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *id, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(id, accounts[i].id) == <span class="number">0</span>) &#123; <span class="comment">// 找到账户</span></span><br><span class="line">            accounts[i].balance += money;      <span class="comment">// 存款</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Account <span class="title function_">get_idx</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> accounts[idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_num</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bank.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 【注意】main 中不能直接访问 bank.c 的那个 accounts</span></span><br><span class="line">    <span class="comment">//  请不要忽视这个权限问题，这是具有非凡意义的一个特性</span></span><br><span class="line">    </span><br><span class="line">    add_account(<span class="string">&quot;0001&quot;</span>);</span><br><span class="line">    add_account(<span class="string">&quot;0002&quot;</span>);</span><br><span class="line">    add_account(<span class="string">&quot;0003&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;0001&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    save(<span class="string">&quot;0001&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">    save(<span class="string">&quot;0003&quot;</span>, <span class="number">4500</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; get_num(); i++) &#123;</span><br><span class="line">        Account a = get_idx(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s] balance: %d\n&quot;</span>, a.id, a.balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>mid-test</tag>
      </tags>
  </entry>
</search>
