<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在前面</title>
    <url>/2023/07/13/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="此文章为何存在"><a href="#此文章为何存在" class="headerlink" title="此文章为何存在"></a>此文章为何存在</h2><p>搭建个人博客不是一件容易的事，也不是仅凭着一腔孤勇就能完成的任务。值得一提的是，该博客搭建全程基于<code>macOS</code>系统。<del>整个过程中，Diandian有不下20次想砸电脑的冲动😭</del></p>
<p>当然，此文章存在的意义不是为了抱怨搭建过程，而是希望面向访问蜜罐的朋友们回答一些问题。</p>
<h3 id="搭建个人博客的初衷"><a href="#搭建个人博客的初衷" class="headerlink" title="搭建个人博客的初衷"></a>搭建个人博客的初衷</h3><p>相信很多朋友们都知道，Diandian是一个乐于分享的人。</p>
<p>从大一开始，Diandian便持续搜集各科目资料<strong>（包括但不限于往年考题、实验报告、课程讲义）</strong>，其不仅是为了日后自我复习，还是为了分享给往后许多届的同学们。</p>
<p>毕竟，大学里要学会互帮互助，才能走得长远。因此，该博客内包括但不限于以下内容并将持续更新：</p>
<div class="note-large blue"><div class="notel-title"><p>2系：电路分析</p>
</div><div class="notel-content"><p>往年题12套</p>
<p>自写答案</p>
<p>学习方法</p>
</div></div>

<div class="note-large red"><div class="notel-title"><p>2系：基础物理学（2）</p>
</div><div class="notel-content"><p>练习题+往年题25套（题过于简单，因此无需给出答案。需要者请在首页邮箱联系或在评论区dd我）</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large purple"><div class="notel-title"><p>2系：复变函数与积分变换</p>
</div><div class="notel-content"><p>往年题16套</p>
<p>自写答案（仅给出部分，需要者请dd我）</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large cyan"><div class="notel-title"><p>2系：电子电路（1）</p>
</div><div class="notel-content"><p>期中与期末题库（几乎涵盖所有考题，详见专栏）</p>
<p>自写答案</p>
<p>全套课程讲义</p>
<p>仿真实验报告与硬件实验报告</p>
</div></div>

<div class="note-large orange"><div class="notel-title"><p>2系：电磁场理论</p>
</div><div class="notel-content"><p>6套期中+8套期末</p>
<p>自写答案</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large yellow"><div class="notel-title"><p>2系：信号与系统</p>
</div><div class="notel-content"><p>8套期末+1套题库</p>
<p>全套课程讲义</p>
<p>仿真实验报告</p>
</div></div>

<div class="note-large green"><div class="notel-title"><p>2系：FPGA基础</p>
</div><div class="notel-content"><p>（由于该门课程为21级新开设，上机实验是否祖传尚不清楚😭）</p>
<p>仿真实验报告+代码打包</p>
</div></div>

<div class="note-large blue"><div class="notel-title"><p>助教资料</p>
</div><div class="notel-content"><p>数据结构与程序设计</p>
<p>复变函数与积分变换</p>
<p>信号与系统（待定）</p>
</div></div>

<div class="note-large orange"><div class="notel-title"><p>视频剪辑</p>
</div><div class="notel-content"><p>剪辑工具如何搭配</p>
<p>剪辑思路</p>
<p>Premiere（简称pr）900个转场预设（自创，无版权要求）</p>
<p>Adobe 全家桶（2022Win&#x2F;Mac版）（无需收费与解压密码）</p>
</div></div>

<h3 id="文章编写：Typora"><a href="#文章编写：Typora" class="headerlink" title="文章编写：Typora"></a>文章编写：Typora</h3><p>该博客中所有文章均为<code>.md</code>格式（全称<code>markdown</code>），采用<code>Typora</code>软件进行编写。</p>
<p>如果你想更方便地自创与编辑<code>.md</code>格式文件，不妨用一下<code>Typora</code>软件，虽然要收费（不打折时，终身使用仅需89元），但是非常好用😋</p>
<a class="button  center large" href='https://typoraio.cn/' title='Typora软件下载'><i class='fa-solid fa-t'></i> Typora软件下载</a>

<p>当然，<code>markdown</code>语法请自己搜索学习。</p>
<h3 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h3><p>该博客已开通友链模块，想要申请加入的请私信Diandian哦～</p>
<p>（悄悄说一声，如果能提供首页缩略图和头像图就更好啦）</p>
<p>想要访问Diandian的朋友的博客，只需要回到主页，点击右上角<code>FRIENDS</code>按钮，就可以解锁更多有趣实用的博客啦！</p>
<p>当然，如果您使用手机竖屏浏览，则可能需要先点击右上角的三杠，才能看到<code>FRIENDS</code>按钮哦～</p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="评论模块"><a href="#评论模块" class="headerlink" title="评论模块"></a>评论模块</h3><p>此博客的评论模块采取<code>Giscus</code>评论系统，该系统基于<code>GitHub Discussions</code>实现，让各位蜜罐访客们能够借助<code>GitHub</code>在文章末尾留下评论。因此，评论员需要一个<code>GitHub</code>账号，如果没有的话赶快注册一个哦～</p>
<a class="button  center large" href='https://github.com/' title='GitHub账号注册'><i class='fa-brands fa-github'></i> GitHub账号注册</a>

<p>当然，此步骤可能需要你会科学上网。在此提供一种macOS上自测有效（Windows也可）的方法</p>
<a class="button  center large" href='https://doc.miyun.app/clashx/' title='免费开启ClashX代理'><i class='fa-solid fa-face-awesome'></i> 免费开启ClashX代理</a>

<p>当然，<code>ClashX</code>并不适用于所有设备端口，如果你不能搜索到足够多的代理<code>url</code>，则还是得付费。在此推荐另一个可长期免费白嫖的付费机场，速度和稳定性超级高。这是一个电脑和手机都能免费使用的梯子软件，经过数年的更新迭代，线路协议逐渐从<code>ssr</code>过渡到<code>V2ray</code>和<code>Trojan</code>，直到目前以免费的<code>Trojan</code>节点为主，它就是<code>Westworld</code>。</p>
<a class="button  center large" href='https://xbsj3462.fun/i/ask031' title='点击我直达Westworld官网'><i class='fa-solid fa-w'></i> 点击我直达Westworld官网</a>

<p>长期免费使用这个梯子的关键在于【临时邮箱】。因为在注册阶段，用户是通过邮箱进行注册的，这个邮箱可以是临时邮箱，注册成功后的账户有三天不限流量的免费使用时间，这时候用户就可以每隔三天，不断更换临时邮箱注册新账号，从而达到长期免费使用的目的。（可直接谷歌或百度搜索关键词<code>临时邮箱</code>，有海量的免费邮箱资源，根本用不完）</p>
<p>当然，如果各位不想通过评论区的方式与我交流联系，也可直接访问首页大字<code>Dian·Stay Curious</code>下三个图标中的<code>邮箱</code>，此按钮会引导你编辑内容发送到<code>zhongyd2004@163.com</code>。</p>
<blockquote>
<p>注意：<br><code>Giscus</code>仍处于活跃开发中，<code>GitHub</code>也还在活跃地开发<code>Discussions</code>及其<code>API</code>，因此一些<code>Giscus</code>的特性可能随时间损坏或变更。当然，Diandian将密切关注此情况。</p>
</blockquote>
<h3 id="Search模块"><a href="#Search模块" class="headerlink" title="Search模块"></a><code>Search</code>模块</h3><p>搜索模块的实现基于<code>Hexo-generator-searchdb</code>插件，位于主页的右上角，图标为<code>🔍</code>。</p>
<p>点击进入搜索模块后，只需要在弹出的输入框内输入您想要看到的内容关键字词，即可精确定位到文章标题、文章内容。（意即无论此关键字词出现在标题还是在内容里，都能被快速精准地搜索到）</p>
<h3 id="文章、分类与标签"><a href="#文章、分类与标签" class="headerlink" title="文章、分类与标签"></a>文章、分类与标签</h3><h4 id="阅读文章"><a href="#阅读文章" class="headerlink" title="阅读文章"></a>阅读文章</h4><p>只需要点击文章的缩略图或者<code>Read more</code>按钮，即可阅读文章全文。</p>
<h4 id="分类模块"><a href="#分类模块" class="headerlink" title="分类模块"></a>分类模块</h4><p>在侧边栏的两个浮块中均有<code>Categories</code>按钮，点击后即可进入分类模块。此模块将所有博客文章以分类的形式呈现，方便访客们更有目的性地浏览各文章。点击具体分类名的模块，即可浏览在该分类下的文章。</p>
<p>如果一个分类下有多个子分类，即可点击大的分类名，所有子分类将自动展开。</p>
<h4 id="标签模块"><a href="#标签模块" class="headerlink" title="标签模块"></a>标签模块</h4><p>在侧边栏的两个浮块中均有<code>Tags</code>按钮，点击后即可进入标签模块。此模块将所有博客文章以其所阐述的重点主题为划分标准，给访客们呈现了具体的文章关键词。点击具体标签名的模块，即可查看与此标签相关的文章。</p>
<h3 id="Archives模块"><a href="#Archives模块" class="headerlink" title="Archives模块"></a><code>Archives</code>模块</h3><p>请允许Diandian将此模块称为档案室，它按照时间顺序收录了博客内所有文章，方便访客们按照时间顺序查阅。</p>
<p>想要访问此模块，只需点击主页右上角或侧边栏的<code>ARCHIVES</code>按钮即可。</p>
<h2 id="加速方法"><a href="#加速方法" class="headerlink" title="加速方法"></a>加速方法</h2><h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>内容分发网络（CDN）是一种分布式系统，<strong>它将内容存储在离用户最近的服务器上</strong>，从而提高用户访问网站的速度和性能。<code>CDN</code>会将用户的请求转发到最近的服务器上，而不是将请求转发到网站的源服务器上。这样可以减少源服务器的负载，同时也可以提高用户访问网站的速度。</p>
<p>本博客基于<code>EvanNotFound</code>大佬的阿里云<code>OSS</code>采取CDN加速，以期望带给各位更顺畅的体验。</p>
<h3 id="All-Minifier资源压缩"><a href="#All-Minifier资源压缩" class="headerlink" title="All Minifier资源压缩"></a>All Minifier资源压缩</h3><p>通常，在代码中，<code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>、图片等代码文件都是没有打包压缩的。</p>
<p><code>hexo-all-minifier</code>插件集成了<code>html-minifier</code>、<code>clean-css</code>、<code>uglify</code>和<code>imagemin</code>，能有效减少网站的加载时间。</p>
<h2 id="开源相关"><a href="#开源相关" class="headerlink" title="开源相关"></a>开源相关</h2><p><a class="link"   href="https://github.com/XPoet/hexo-theme-keep" >https://github.com/XPoet/hexo-theme-keep <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/volantis-x/hexo-theme-volantis" >https://github.com/volantis-x/hexo-theme-volantis <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/theme-next/hexo-theme-next" >https://github.com/theme-next/hexo-theme-next <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/jerryc127/hexo-theme-butterfly" >https://github.com/jerryc127/hexo-theme-butterfly <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://m3.material.io/" >https://m3.material.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://developer.apple.com/design/human-interface-guidelines/" >https://developer.apple.com/design/human-interface-guidelines/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://fluent2.microsoft.design/" >https://fluent2.microsoft.design/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.sketch.com/" >https://www.sketch.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://hexo.io/zh-cn/" >https://hexo.io/zh-cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://highlightjs.org/" >https://highlightjs.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/next-theme/hexo-filter-mathjax" >https://github.com/next-theme/hexo-filter-mathjax <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" >https://github.com/webappdevelp/hexo-filter-mermaid-diagrams <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/theme-next/hexo-generator-searchdb" >https://github.com/theme-next/hexo-generator-searchdb <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/hexojs/hexo-generator-feed" >https://github.com/hexojs/hexo-generator-feed <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/yanyiwu/nodejieba" >https://github.com/yanyiwu/nodejieba <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://aplayer.js.org/#/" >https://aplayer.js.org/#/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://fontawesome.com/" >https://fontawesome.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.zhheo.com/p/557c9e72.html" >https://blog.zhheo.com/p/557c9e72.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/mattboldt/typed.js/" >https://github.com/mattboldt/typed.js/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="Stay-Curious-Stay-Interesting"><a href="#Stay-Curious-Stay-Interesting" class="headerlink" title="Stay Curious, Stay Interesting"></a>Stay Curious, Stay Interesting</h2><p>在此篇博客的主页会出现<code>Dian·Stay curious</code>，侧边公告栏中出现<code>Stay curious, stay interesting.</code></p>
<p>此句是Diandian最喜欢的英语句子，源于Diandian的高中英语老师<code>Chelsea</code>。我们每次英语课前的老师问好环节，<code>Chelsea</code>会喊出前一句，我们则说出后一句😋。</p>
<p><strong>因此，让我们也在文章末尾大声地说出：“Stay curious, stay interesting!”</strong></p>
]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第一期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%B8%80%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="什么是猪脚说"><a href="#什么是猪脚说" class="headerlink" title="什么是猪脚说"></a>什么是猪脚说</h2><p>为了改善同学们的上机体验，减轻同学们的压力，集中回答编程中常见问题，继承上一辈助教的优良传统，我们<strong>为大家精心准备了猪脚说</strong>。</p>
<p>猪脚说，就是<del>猪脚</del>助教们想对大家说的话。每次上机后，我们会及时总结大家<strong>提问相对较多</strong>或<strong>比较重要</strong>的问题，在猪脚说中以详细的篇幅加以阐述，希望同学们或多或少得到一些启发。</p>
<p>猪脚说包括但不限于<strong>共性问题</strong>, <strong>coding 小技巧</strong>, <strong>课外习题</strong>。</p>
<h2 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h2><h3 id="指针详详详解"><a href="#指针详详详解" class="headerlink" title="指针详详详解"></a>指针详详详解</h3><h4 id="指针与地址"><a href="#指针与地址" class="headerlink" title="指针与地址"></a>指针与地址</h4><p>考虑如下代码，发生了什么？</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure></div>

<p>要回答这个问题，我们要从最开始的地方说起。</p>
<h5 id="你好，世界！"><a href="#你好，世界！" class="headerlink" title="你好，世界！"></a>你好，世界！</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>我们知道，数据总是存储在计算机里的。我们要打印的字符串，应该存在哪里呢？为了便于说明这个问题，我们把计算机内部存储数据的地方<strong>想象成一个大柜子，柜子有一个一个的抽屉</strong>；每个抽屉的容量是有限的，只能放得下一个字符，也就是一个<code>char</code>的内容。这里为了避免引入“字节”的概念，给出如下的大小关系：<code>4个char的大小 = 1个int的大小</code>，<code>8个char的大小 = 2个int的大小 = 1个double的大小 = 1个long long</code>的大小。</p>
<p>上述语句中的字符串，用<strong>双引号</strong>括起来，称为<strong>“字符串字面值常量”</strong>。作为字符串，它由若干字符拼接而成，后来的故事我们都知道了，在它的最后还有一个看不见的<code>&#39;\0&#39;</code>作为结束的标志；作为常量，这类字符串的内容不能被修改。</p>
<p>这样的字符串常量，储存在大柜子里的一块特定区域，称为<strong>常量区</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 15.50.21.png"
                      alt="截屏2023-02-24 15.50.21" style="zoom:40%;" 
                >

<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="type">int</span>  i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>

<p>后来我们学了变量，它们当然也装在这个大柜子里。如果这只是个有很多抽屉的柜子，那么数据的存取将变得异常困难，一个很显然的做法是，<strong>为每个抽屉编号</strong>。但另一个问题又来了，计算机自然可以通过编号访问数据；但作为编程者，我们并不知道每个变量存在哪个编号的抽屉里。于是另一个很显然的做法是，我们可以为存有变量的抽屉<strong>贴上标签</strong>，这就是<strong>标识符</strong>，例如<code>c</code>和<code>i</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.12.35.png"
                      alt="截屏2023-02-24 16.12.35" style="zoom:40%;" 
                >

<p><strong>特别要注意的是，<code>int</code>变量<code>i</code>占用了 4 个抽屉。</strong>有了这个模型，我们就能知道<code>int i = 10;</code>中，<code>i</code>表示的是存放了数字 10 的那 4 个抽屉的标签；它的编号是 21；从编号 21 开始之所以放了 4 个抽屉，是类型<code>int</code>决定的。</p>
<p><strong>后来我们知道了，这个编号，就是指针。指针，就是地址。</strong></p>
<h5 id="回答一下前面的问题"><a href="#回答一下前面的问题" class="headerlink" title="回答一下前面的问题"></a>回答一下前面的问题</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.22.14.png"
                      alt="截屏2023-02-24 16.22.14" style="zoom:40%;" 
                >

<ul>
<li>首先定义一个普通变量<code>a</code>，被装在 4 个抽屉里，抽屉的起始编号是 21，抽屉的内容是 10。</li>
<li>然后定义了一个指针变量<code>p</code>，<code>p</code>也需要 4 个抽屉存放<strong>（因为<code>p</code>的本质也是一个整数！！！）</strong>，<code>p</code>也有自己的编号 44，<code>p</code>的内容是存放<code>a</code>的抽屉的起始编号，即 21。</li>
<li><code>p</code>只存放了<code>a</code>的起始地址，<code>p</code>怎么知道<code>a</code>从 21 开始占了多少个抽屉呢？这由定义<code>p</code>的<code>int *</code>中的<code>int</code>决定。<strong>换言之，</strong><ul>
<li><code>char *p</code>表示<code>p</code>中存放一个整数，这个整数是一个地址，从那个地址开始的 1 个抽屉的内容是一个<code>char</code>变量，因为<code>char</code>只需要 1 个抽屉。</li>
<li><code>int *p</code>表示<code>p</code>中存放一个整数，这个整数是一个地址，从那个地址开始的 4 个抽屉的内容是一个<code>int</code>变量，因为<code>int</code>需要 4 个抽屉。</li>
<li><code>double *p</code>表示<code>p</code>中存放了一个整数，这个整数是一个地址，从那个地址开始的 8 个抽屉的内容是一个<code>double</code>变量，因为<code>double</code>需要 8 个抽屉。</li>
<li>……</li>
</ul>
</li>
</ul>
<h5 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h5><p>有了指针，在我们的程序里，要访问一个变量就有两种方法了。一方面，可以通过<strong>抽屉的标签</strong>，也就是<strong>变量名</strong>访问；另一方面，可以通过<strong>抽屉的编号 —— 指针</strong>，间接地访问。后者自然要加上**指针运算符（解引用）<code>*</code>**。</p>
<p>显然，在多数情况下，偏要用指针间接访问一个变量是毫无意义的。但在某些情况下，我们只能通过指针访问。考察下面的程序</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pass_by_value</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pass_by_pointer</span><span class="params">(<span class="type">int</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    pass_by_value(x);</span><br><span class="line">    pass_by_pointer(&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>稍有经验的同学不难看出，<code>x</code>的值不会被修改，<code>y</code>的值会被修改。为什么呢？</p>
<p><strong>C 程序的函数参数都是值传递的。</strong>这句话的意思是，一个函数的运行，自然会涉及一些变量，其中的一部分是函数参数，另一部分是函数内部定义的变量；<strong>在函数运行期间，函数需要借用一些抽屉来存放这些变量的值</strong>。对于<code>pass_by_value(x);</code>中的<code>x</code>，函数只会把**<code>x</code>的值<strong>放在自己借用的抽屉里，而不会意识到<code>x</code>是某处的一个标签；对于<code>pass_by_pointer(&amp;y);</code>中的<code>&amp;y</code>，函数只会把</strong><code>&amp;y</code>的值** —— <strong>这个值是一个普通整数，并且是一个地址</strong> —— 放在自己借用的抽屉里。两者的不同之处在于，前者真的只是传了一个普通整数；而<strong>后者传入的整数同时也是地址</strong>，我们在函数内部确实访问了这个地址的内容，从而真的修改了<code>y</code>的值。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.56.33.png"
                      alt="截屏2023-02-24 16.56.33" style="zoom:35%;" 
                >

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><blockquote>
<p>为了绘图简便，我们考察<code>short</code>型的数组。一个<code>short</code>变量占两个抽屉。此处我们仅考虑数组和指针的关系，数组的定义、初始化、元素访问等不再赘述。</p>
</blockquote>
<p>我们会说，<strong>数组名就是指针</strong>，这句话的意思是</p>
<ul>
<li><strong>只要知道了数组的首地址，就可以访问数组的每个元素。</strong>假设<code>p</code>存放着数组的首地址，下标从 0 开始，我们要访问下标为<code>index</code>的元素，一种写法是<code>p[index]</code> —— 相当于从数组首元素<strong>往后数</strong><code>index</code>个元素，然后访问那个元素 —— 等价于<code>*(p + index)</code>，即将<code>p</code><strong>偏移</strong>，从而使之指向欲访问的元素，然后解引用。</li>
<li>系统手里有一张表，叫做<strong>符号表</strong>。数组名是符号表中的一项，它是一个<strong>不可修改的常量</strong>，指代数组的首地址。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 17.30.56.png"
                      alt="截屏2023-02-24 17.30.56" style="zoom:40%;" 
                >

<p>当数组作为函数参数传递的时候，<strong>统一当成指针处理</strong>，所以以下三种函数声明等价：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *arr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arr[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arr[<span class="number">999</span>])</span>; <span class="comment">// 并不关心数组多大</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>后面两种声明会被翻译成第一种声明，也就是指针的形式。<ul>
<li>数组可以通过首地址访问，所以传入首地址是可行的。</li>
<li>通过指针，在<code>main</code>函数里定义的数组，可以在<code>func</code>中被修改，这与普通变量的值传递不同。</li>
</ul>
</li>
<li>前面说到，函数参数需要借一些抽屉临时存放。而函数能借到的抽屉是<strong>有限的</strong>，如果真的把一个长度为 999 的数组传入，则需要 999 × 4 个抽屉，这不太现实。只传入指针，则只需要 4 个抽屉即可 —— 通过指针间接访问数组。</li>
<li>此外，上一点也提醒我们，<strong>函数内部并不知道数组有多大，它只知道数组的首地址</strong>。所以对数组操作的函数，一般需要再加上一个<code>size</code>参数，保证函数中不会出现<strong>数组越界</strong>的情况。</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>在最开始的地方谈到，用双引号扩起来的字符串常量，被存放在大柜子的一块特定区域，即常量区。事实上，不仅是我们想要输出的文本信息，<strong>C 程序中任何地方</strong>出现的字符串常量，都会被存在那里。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="type">char</span> *s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br></pre></td></tr></table></figure></div>

<p>这里的<code>&quot;%d %d&quot;</code> <code>&quot;hello world&quot;</code> <code>&quot;%s\n&quot;</code>都是字符串常量，都会被预先存在常量区。另一方面，这种字符串常量的最后都默认有一个看不见的<code>&#39;\0&#39;</code>作为结束的标志，这是系统自动加上的。</p>
<p>我们想象这样的画面，每个抽屉只能装一个字符，<strong>只要我们知道了字符串的第一个字符装在哪个抽屉，然后依次往后拉开抽屉，直到拉开了存放<code>&#39;\0&#39;</code>的那个抽屉为止，我们就获得了字符串的所有内容</strong>。于是，<strong>字符串的首地址就成为了确定一个字符串唯一所需要的信息。</strong><code>char *s = &quot;hello world&quot;;</code>的那个指针<code>s</code>，做的就是这件事。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 11.57.03.png"
                      alt="截屏2023-02-25 11.57.03" style="zoom:40%;" 
                >

<p><strong>另一方面，字符串也可以存在我们自定义的数组里，但是其初始化值得考察。</strong>假设我们要存入的是<code>&quot;abc&quot;</code>。</p>
<ul>
<li><p>数组大小应该开够，因为需要有<code>&#39;\0&#39;</code>作为结束标志</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 开得足够大，并且别忘了 \0</span></span><br><span class="line"><span class="type">char</span> s[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;   <span class="comment">// 不写大小，由系统自动判断，此处 s 大小即为 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">4</span>]; s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>; s[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>; s[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span> = s[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 更加麻烦的逐一赋值，但 OK</span></span><br></pre></td></tr></table></figure></div>

  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 12.02.53.png"
                      alt="截屏2023-02-25 12.02.53" style="zoom:40%;" 
                >
</li>
<li><p>有一种<strong>便捷手段</strong>，在初始化的时候，<strong>用字符串字面值常量为字符数组赋初值</strong></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 开大点总是保险</span></span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>;   <span class="comment">// 这么做默认 s 大小为 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严禁这么做！</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>]; <span class="comment">// 定义了一个数组，数组名是符号表中的常量</span></span><br><span class="line">s = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 给一个符号常量赋值，是绝对不行的</span></span><br></pre></td></tr></table></figure></div>

  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 12.08.20.png"
                      alt="截屏2023-02-25 12.08.20" style="zoom:40%;" 
                ></li>
</ul>
<h4 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h4><p><strong>指针是工具，是用来使用的。</strong></p>
<p>对指针的本质进行解析，为的是让大家理解其使用方式。使用指针，需要的是在脑海中形成意识“我们就是这么做的”“这么做是合理的”。对于指针的基本理解包括但不限于以下几点</p>
<ul>
<li>指针是个<strong>变量</strong>，指针是个<strong>整数</strong>。</li>
<li>取变量的地址赋值给指针，我们就说指针指向了那个变量。</li>
<li>指针“指向”，只是说指针中存了一个整数地址；<strong>要访问变量，需要一次解引用</strong>。</li>
<li><strong>数组名是一个符号</strong>，等价于数组首地址。</li>
<li>双引号扩起来的字符串是常量，只读不写。</li>
</ul>
<p>我们需要培养一些基本的意识，要知道“我可以写什么，不可以写什么”。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr; <span class="comment">// arr符号代表首地址，赋值给指针，当然可以</span></span><br><span class="line">p[<span class="number">1</span>] = <span class="number">5</span>;     <span class="comment">// 指针也可以像数组一样访问</span></span><br><span class="line">*(p + <span class="number">2</span>) = <span class="number">2</span>; <span class="comment">// 指针自己也具备了“偏移 + 解引用”操作</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *s  = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 这是指针指向字符串常量</span></span><br><span class="line"><span class="type">char</span> t[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 这是一个普通数组，并使用了便捷方式初始化</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span>;       <span class="comment">// 字符串常量不能修改！</span></span><br><span class="line">t[<span class="number">1</span>] = <span class="string">&#x27;y&#x27;</span>;       <span class="comment">// 数组当然可以修改</span></span><br></pre></td></tr></table></figure></div>

<p>最后补充的是<code>NULL</code>和<code>const</code>指针。</p>
<h5 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a><code>NULL</code></h5><p>指针是一个<strong>整型变量</strong>，它的取值无非有这么几种</p>
<ul>
<li>只定义但未初始化，是一个随机值。</li>
<li>进行初始化或赋值，“指向了其他的变量”。</li>
<li>初始化为 0。（编号为 0 的那个抽屉存了啥？）</li>
</ul>
<p><code>NULL</code>是一个宏，代表整数 0，用于指针的初始化：<code>int *p = NULL;</code> 当然也可以写 <code>int *p = 0;</code>。</p>
<p>当一个指针未初始化时，它可能指向任何地方，但是那里究竟能不能访问是未知的，这就是<strong>野指针</strong>。在有些情况下，访问了不该访问的地方，可能导致系统崩溃。人们规定，<strong>编号为 0 的那个抽屉是一个无效的抽屉，一旦访问，程序运行就强制结束了</strong>（总比系统崩溃好）。所以在将指针指向某个变量之前，初始化为 0 或<code>NULL</code>，是有必要的。</p>
<h5 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a><code>const</code>指针</h5><p>我们知道字符串常量存在常量区，但其他常量，如<code>const int</code>，还是和普通变量放在一起的。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></div>

<p>当编译器看到这两行代码，它会说：“<code>a</code>被定义为常量，你却要为<code>a</code>赋其他值，不可以！”于是报错。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line">*p = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></div>

<p>当编译器看到这两行代码，它会说：“<code>a</code>是常量，存在内存里了。<code>p</code>想要指向它，当然可以。对指针<code>p</code>解引用进行赋值，当然可以。”于是真的，一个<code>const int</code>的值通过指针被修改了。</p>
<p>所以我们有必要避免这种情况，手段就是<strong>“指向常量的指针”</strong>。前文说到，<strong>指针是统一的一种类型，就是整型</strong>。定义指针时前面的类型，只是告诉系统，“连续打开几个抽屉”。打开抽屉后，无非有两种操作：看一下里面是什么（<strong>读</strong>操作）和修改一下内容（<strong>写</strong>操作）。对于后者，如果抽屉里装的是常量，则应该避免。</p>
<p>在定义指针的最前面加上<code>const</code>修饰，如<code>const int *p = &amp;a;</code>，就定义了指向常量的指针。这么做的好处是，<code>p</code>说：“我是指针，我指向<code>a</code>，但你<strong>无法通过我</strong>修改<code>a</code>的值，<strong>你有没有其他手段修改<code>a</code>的值，与我无关。</strong>”</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a; <span class="comment">// 这是正确的，定义了指向常量的指针</span></span><br><span class="line">*p = <span class="number">100</span>;          <span class="comment">// 通过 p 无法修改 a</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *q = &amp;b; <span class="comment">// 指向常量的指针指向了普通变量</span></span><br><span class="line"><span class="type">int</span> *r = &amp;b;       <span class="comment">// 普通的指针指向了普通变量</span></span><br><span class="line">*q = <span class="number">100</span>;          <span class="comment">// 无法通过 q 修改 b 了，哪怕 b 是一个普通变量</span></span><br><span class="line">*r = <span class="number">100</span>;          <span class="comment">// 这么改当然可以</span></span><br></pre></td></tr></table></figure></div>

<p>于是我们会在大量字符串处理函数的原型中，看到参数都定义为<code>const char *p</code>类型，这就是说，字符串通过<code>p</code>传入函数，<strong>保证在函数内部，不会修改字符串的内容</strong>。这么做是严谨的。</p>
<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><h4 id="库函数功能介绍"><a href="#库函数功能介绍" class="headerlink" title="库函数功能介绍"></a>库函数功能介绍</h4><p><code>size_t</code> 为无符号整数类型，它是 <strong><code>sizeof</code></strong> 关键字的结果。</p>
<p>下列常用字符串处理函数均定义在头文件  <code>&lt;string.h&gt;</code> 中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 把 str1 和 str2 的前 n 个字节进行比较。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 从 src 复制 n 个字符到 dest。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复制字符 c （一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</span></span><br><span class="line"><span class="comment">	e.g.想要将一个 int 类型数组 a[50] 全部置为0:</span></span><br><span class="line"><span class="comment">		memset(a, 0, sizeof(a));</span></span><br><span class="line"><span class="comment">	等效于 for (i=0; i &lt; 50; i++) a[i] = 0;</span></span><br><span class="line"><span class="comment">	【特别注意】一般此函数仅用于全部归零，其他值不能随便设置！！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="comment">// 把 src 所指向的字符串（包括&#x27;\0&#x27;）追加到 dest 所指向的字符串的结尾（删除 dest 原来末尾的&#x27;\0&#x27;）。</span></span><br><span class="line"><span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 的字符串。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 把 src 所指向的字符串的前 n 个字符追加到 dest 所指向的字符串的结尾（删除 dest 原来末尾的&#x27;\0&#x27;）。</span></span><br><span class="line"><span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 的字符串。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="comment">	返回值为该字符串中第一次出现的字符的指针，若不包含该字符则返回 NULL 空指针。</span></span><br><span class="line"><span class="comment">	char *strrchr(const char *str, int c);</span></span><br><span class="line"><span class="comment">	在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	把 str1 所指向的字符串和 str2 所指向的字符串进行比较并返回整数。若两字符串相等，则返回零。</span></span><br><span class="line"><span class="comment">	若 str1 &lt; str2, 则返回负数; 若 str1 &gt; str2, 则返回正数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line">	<span class="comment">// 把含有&#x27;\0&#x27;结束符的字符串 src 复制到以 dest 开始的地址空间。</span></span><br><span class="line">	<span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 字符串。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line">	<span class="comment">// 把字符串 src 的前 n 个字符复制到以 dest 开始的地址空间。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">// 计算字符串 str 的长度，知道空结束字符但不包括空结束字符。返回值数据类型为无符号整型。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="comment">// 在字符串 dest 中查找第一次出现字符串 src（不包含空结束字符）的位置。</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>补充练习：字符串处理函数与指针的使用。<strong>此题将在下周上机详细讲评。</strong></p>
<p>输入 n 个字符串，将每个字符串中的<code>good</code>子串全部替换为<code>perfect</code>后输出。（不用担心数据范围，写代码实现此功能即可）。</p>
<p><strong>样例输入</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">abc123</span><br><span class="line">BUAA  goodddd 123 Good</span><br><span class="line">godgoodgodgoooood goo? gooD good!</span><br></pre></td></tr></table></figure></div>

<p><strong>样例输出</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc123</span><br><span class="line">BUAA perfectddd 123 Good</span><br><span class="line">godperfectgodgoooood goo? gooD perfect!</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="读取字符串"><a href="#读取字符串" class="headerlink" title="读取字符串"></a>读取字符串</h4><p>很多同学在使用 <code>gets()</code> 函数读取字符串时，可能在 judge 平台的编译器上收到这样的提示:</p>
<p><strong>Warning: the ‘gets’ function is dangerous and should not be used.</strong></p>
<p>原因在于：**<code>gets()</code>函数不做地址越界检查！**若输入的字符串大于既定数组的长度，程序运行会出现难以预期的错误。<a class="link"   href="https://blog.csdn.net/weixin_33748818/article/details/89776085" >有兴趣的同学可以从这篇文章中作详细了解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>在此，我们建议使用如下两种方式读取字符串:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"><span class="comment">// 该函数更多被用来读取单词，而非整行字符串。它从一个非空白字符开始，读到下一个空白字符为止。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[BUFSIZ] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">fgets(buf, BUFSIZ, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="comment">// 该函数的第二个参数代表规定从标准输入读取字符上限的数量，这也是它优于 gets() 函数的地方。</span></span><br><span class="line"><span class="comment">// 我们更推荐大家使用此种方法来读取整行字符串。</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>BUFSIZ</code>是宏定义在头文件里的常数，一般值为 512，对于大家完成上机作业已经够用了。</p>
</li>
<li><p><code>stdin</code>为标准输入，也就是键盘输入。在之后的文件输入输出时，可以修改此参数为文件指针。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong></p>
<p><code>fgets()</code> 函数会读取 <code>&#39;\n&#39;</code> 并写进数组中, 因此使用<code>strlen()</code> 函数求取数组长度时, 得到的长度比实际可见字符数多 1，其中包含了最后一个换行符。</p>
</blockquote>
<h3 id="char与int的转换"><a href="#char与int的转换" class="headerlink" title="char与int的转换"></a><code>char</code>与<code>int</code>的转换</h3><p>先来看第一次作业填空题第四题:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">invert</span><span class="params">(<span class="type">char</span> str[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>, j = <span class="built_in">strlen</span>(str)<span class="number">-1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">		k = str[i];</span><br><span class="line">		str[i] = str[j];</span><br><span class="line">		str[j] = k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不少同学都来提问: <code>k</code>不是<code>int</code>类型的变量吗，怎么能够和一个字符进行相应的运算关系？</p>
<p>需要指出的是：某个字符和它由 <strong>ASCII 码表</strong>所对应的整型值是等价的。即如果用整型值 48 赋值给某个字符，则其输出结果会是 ‘0’; 如果用字符常量 ‘0’ 赋值给某个整型变量，则其输出后为 48。</p>
<p><code>char</code>型实际上就是 0 到 127 的整型数经过 <strong>ASCII 码表</strong>映射的结果，其与<code>int</code>型的转换需要代入映射后得到对应值。</p>
<p>如果还有同学有疑问或者想要了解更多例子，不妨看下面一些代码:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) </span><br><span class="line">    <span class="comment">// do something</span></span><br></pre></td></tr></table></figure></div>

<p>上述代码为最简单的两个字符比较大小，其本质上是以相应的<strong>ASCII码表</strong>值的大小作为字符比较的标准。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">char</span> str[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line"> 			str[i] += <span class="number">32</span>; </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码可以实现把一段字符串中的大写字母全部转化为小写字母，其中倒数第三行就是字符与整型量的运算。</p>
<h2 id="第一次作业补充练习"><a href="#第一次作业补充练习" class="headerlink" title="第一次作业补充练习"></a>第一次作业补充练习</h2><p><a class="link"   href="https://www.luogu.com.cn/training/48079" >此链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>可以收藏起来，若有需求可以去做一些练习。</p>
<p>1、 <a class="link"   href="https://www.luogu.com.cn/problem/P5734" >处理字符串，主要考察大家对常用字符串处理库函数的运用。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>2、 <a class="link"   href="https://www.luogu.com.cn/problem/P1308" >单词统计，注意题干要求处理大小写字母。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>3、 <a class="link"   href="https://www.luogu.com.cn/problem/P1022" >改良计算器，为第一次上机第二道编程的拓展。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>4、 <a class="link"   href="https://www.luogu.com.cn/problem/P8652" >对于小数点后位数的处理。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>5、<a class="link"   href="https://www.luogu.com.cn/problem/P2293" >高精度开根，第一次上机第四道编程的拓展。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第二期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%BA%8C%E6%9C%9F/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets2/IMG_0716.jpg"
                      alt="IMG_0716" style="zoom:33%;" 
                >

<blockquote>
<p><strong>写在前面 —— 关于理论与实验</strong></p>
<p>我们可以很负责地告诉大家，几乎所有的计算机软件核心专业课（如计算机组成原理、操作系统、编译原理、计算机网络等），都由理论和实验两部分构成。前者，基本建立在抽象的层面上，一般以<strong>文字表述和数学公式</strong>给出；后者，基本需要个人在实践中完成。实验的内容一般由指导书、手册等给出，需要<strong>自行阅读了解</strong>；而其中涉及的工具和方法，如虚拟机、编程工具、编程语言等，完全<strong>通过自学解决</strong>。</p>
<p>幸运的是，作为一门承上启下的课程，数据结构课的重点知识并非仅纯数学符号。由于我们的学习进度尚有限，这门课在日常教学中也融入了大量 C 语言代码，并且几乎可以当作“板子”。所谓板子，就是<strong>可以直接拷贝黏贴</strong>的东西，<del>每到考试，也会出现打板子、拼接板子等现象</del>。</p>
<p>这给我们两点启发。其一，很多知识在课件里就能找到，当同学们遇到困难时（如文件操作、结构体），不必等老师讲授，自行看课件、搬运代码，很多问题就能迎刃而解。其二，我们必须强调自学的重要性，善于通过各类渠道解决问题。举个例子，仅通过搜索引擎，就可以查询到近来上机出现的诸多问题。</p>
<p>此外，由于实验的基本形式是选填和编程题，而非从零开始迭代着制造一个东西，所以就没有指导书的必要。<strong>我们的“猪脚说”则作为上机实验的补充指导，解答共性问题、提供知识总结，希望对大家有所帮助。</strong></p>
</blockquote>
<h2 id="常见问题汇总"><a href="#常见问题汇总" class="headerlink" title="常见问题汇总"></a>常见问题汇总</h2><blockquote>
<p><strong>为什么我本地测试正确，提交运行却出现了多余字符？</strong></p>
</blockquote>
<p>数组是一片连续的内存空间，<strong>数组之外的内容是不可控的</strong>。当我们越界访问时，有可能成功，有可能报错，有可能读取到随机内容。因此，这类问题的主要原因是数组开得不够大和未初始化。</p>
<p><strong>(1) 数组大小。</strong>题目不一定给出明确的数据范围，如果有数据范围，比如 80，则开到100 比较合适，甚至 200、500 等都不过分。如果没有数据范围，则根据经验考虑，如字符数组开 512 或 1024 大小，整型数组开 200、1000 等。一般不会在数据范围的问题上为难大家，但如果开得和题目说的一样大，确实更容易出错（如忘了字符串末尾的<code>&#39;\0&#39;</code>，下标从 1 开始等）。</p>
<p><strong>(2) 初始化。</strong>很多时候都需要把一个数组或变量初始化成 0。考虑这样一种情况，我们逐个字符地构造一个字符串，结果最后忘了添加<code>&#39;\0&#39;</code>，<strong>如果这个字符数组先前被初始化成全 0，则字符串的后面还是有<code>&#39;\0&#39;</code>的</strong>；如果未初始化，字符串后面的内容则是未知的，极有可能出错。下面给出一些常见的初始化方式。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码都处在 main 函数中</span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;          <span class="comment">// 初始化为全 0</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">10</span>] = &#123;<span class="number">1</span>&#125;;          <span class="comment">// 仅 arr2[0] 为 1，其他都是 0</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;          <span class="comment">// 全部初始化为 &#x27;\0&#x27;，等价于 char str[10] = &#123;&#x27;\0&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环也是初始化的常见方式，千万不要觉得麻烦！</span></span><br><span class="line"><span class="type">int</span> arr3[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr3[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> arr4[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">        arr4[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>(3) 全局变量。</strong>全局变量会执行<strong>默认初始化</strong>，一般自动初始化成 0；且在各个函数中都能直接访问，简化了参数列表。但正如同先前谈到的代码风格问题，频繁使用全局变量并不是一个好习惯。一般地，只有需要很大的数组，如<code>int [1000000]</code>，或常量，如<code>const int MAX_LENGTH = 1024;</code>的时候，才会使用全局变量。</p>
<blockquote>
<p><strong>为什么错误输出和期望输出一模一样还会 WA？</strong></p>
</blockquote>
<p>这种问题多数是由于通过<code>printf(&quot;%c&quot;, c);</code>的方式输出导致的。在打印过程中，可能不慎打印了空白字符。空白字符在网页上显示不出来，但在评测机进行比对的时候，就会认为错误。解决的方法是，在本地把代码改成<code>printf(&quot;%c0&quot;, c);</code>（我们假设正确的输出中不含 0，如果有冲突就换一个字符），这样如果输出了诸如<code>a0b0c00</code>的内容，就说明在最后一个 0 的前面还输出了不可见字符。打印了空白字符很可能是为字符变量赋值或初始化的逻辑有漏洞引起的，需要结合代码具体分析。</p>
<blockquote>
<p><strong>为什么这种不合法的情况也还是会输出啊？</strong></p>
</blockquote>
<p>没有按照题目要求输出内容，多数是代码逻辑的问题引起的。我们仅以第一次作业的“拓展字符”为例，看一种典型的错误。伪代码如下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">遍历字符串:</span><br><span class="line">    <span class="keyword">if</span> (当前字符为 <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;-&#x27;</span> 的前后同为 a-z 或 A-Z 或 <span class="number">0</span><span class="number">-9</span>) &#123;</span><br><span class="line">            <span class="type">int</span> d = 后字符 - 前字符;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= d; i++) &#123;</span><br><span class="line">                print 前字符 + i；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        原样输出字符;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>对于合法的可拓展字符，这段代码可以成功拓展。考虑 “g - a” 这类情况，程序会先连续进入两个<code>if</code>，但是<code>d</code>算出来为负数，所以<code>for</code>循环不执行，好像也符合要求。但是，一旦进了第一个<code>if</code>，则<code>else</code>分支原样输出将不被执行。这就是典型的逻辑漏洞。</p>
<p>另外，多数情况下的“运行超时”都是死循环导致的，这与代码逻辑也密不可分。</p>
<p>解决逻辑问题的常见手段是调试。如果你尚未掌握自己所用 IDE 的调试方法，不妨在程序的多个地方<strong>打印变量的值</strong>，观察程序的运行过程；如果需要判断是否进入某个分支、循环多少次等，也可以采用打印的方法。通过有效的<strong>工具手段和纸面演算</strong>解决程序逻辑问题，是每个人必备的基本功。当然，<strong>将代码提取成函数</strong>，也有助于缩小错误的范围。</p>
<h2 id="qsort函数详解"><a href="#qsort函数详解" class="headerlink" title="qsort函数详解"></a><code>qsort</code>函数详解</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>C 标准库 ```<stdlib.h>```中。函数原型如下：</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```C</span><br><span class="line">void qsort(void *base, </span><br><span class="line">           size_t num, </span><br><span class="line">           size_t width, </span><br><span class="line">           int(*cmp)(const void* e1, const void* e2));</span><br></pre></td></tr></table></figure></div>

<p><strong>该函数可实现的功能是：按照某种自定义的规则（ <code>cmp</code>函数），对数组<code>base</code>的 <code>num</code>个元素进行排序。</strong></p>
<p>想要理解<code>qsort</code>函数的具体实现方式，我们首先引入<strong>回调函数</strong>的概念：</p>
<blockquote>
<p>回调函数就是一个<strong>通过函数指针调用的函数</strong>。如果把函数的指针作为<strong>参数</strong>传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。</p>
</blockquote>
<p>显然<code>qsort</code>函数的四个参数中，**<code>cmp</code>参数就是回调函数，我们需要使用它来指导<code>qsort</code>函数的进行**。当<code>qsort</code>函数想要确定某两个元素的排列顺序时，会将这两个元素的指针 p1 和 p2 传入<code>cmp</code>函数进行元素值的比较：</p>
<ul>
<li><p>如果<code>cmp</code>函数返回值小于 0，则 p1 所指向元素会被排在 p2 所指向元素的前面；</p>
</li>
<li><p>如果<code>cmp</code>函数返回值等于 0，则 p1 所指向元素与 p2 所指向元素的顺序不确定（因为<strong>在某种意义上</strong>两个相同的元素谁在前谁在后都无伤大雅）；</p>
</li>
<li><p>如果<code>cmp</code>函数返回值大于 0，则 p1 所指向元素会被排在 p2 所指向元素的后面。</p>
</li>
</ul>
<p>可是，<strong>设计者在设计<code>qsort</code>函数时，不知道使用者会排序什么类型的元素，<code>qsort</code>函数自身也不清楚数组元素的类型是什么，但是它又必须实现元素两两之间的比较与交换。</strong>怎么办呢？最高效的方式就是从数据的存储入手，我们只需要<strong>将两个数据所占有的内存的内容交换【可以表述成：将属于 p1 的若干个抽屉的内容全部取出，将属于 p2 的若干个抽屉的内容全部取出，两者交换（详见猪脚说第一期😋）】</strong>便可实现任意类型元素的排序了。</p>
<p>需要交换的字节大小视具体情况而定，这时候参数<code>width</code>与<code>cmp</code>函数里的<code>void *</code>的作用就体现出来了。</p>
<p><strong><code>void *</code>称为通用指针</strong>，它就像一个垃圾桶，什么地址都可以往里扔，我们需要做的只是<strong>在自己写的<code>cmp</code>函数里对扔进来的地址做强制类型转换</strong>，再通过<code>width</code>参数规定所交换字节内容的大小，如<code>sizeof(int)</code>、<code>sizeof(char)</code>、  <code>sizeof(struct Node)</code>等，就可以使<code>qsort</code>函数按你所需地对目标数组元素进行排序。</p>
<p>现在我们以一段实操代码为例，感受<code>qsort</code>函数的使用方式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span>*)e1 &lt; *(<span class="type">int</span>*)e2) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 也可写成如下形式：</span></span><br><span class="line">    <span class="comment">// int *a = (int *)e1;</span></span><br><span class="line">    <span class="comment">// int *b = (int *)e2;</span></span><br><span class="line">    <span class="comment">// return (*a &lt; *b) ? -1 : 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    qsort(a, <span class="number">1000</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	特别要注意，部分教程在 cmp 中直接写</span></span><br><span class="line"><span class="comment">	`return *a - *b;`</span></span><br><span class="line"><span class="comment">	这是有巨大隐患的。具体原因请结合 int 能表示的范围有限思考。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p>通过我们自己写的<code>cmp</code>函数得知，当返回值小于 0（即 e1 所指向元素小于 e2 所指向元素时），e1 所指向元素会被排列在 e2 所指向元素的前面，且每次<strong>严格按照<code>int</code>类型所占有的字节宽度为限度</strong>进行交换，由此可实现数组 a 中所有元素由小到大排序。</p>
<p>当然，若想实现元素由大到小排序，只需将<code>cmp</code>中内容改写为<code>return (*(int*)e1 &gt; *(int*)e2) ? -1 : 1;</code></p>
<p>值得注意的是，若对于<code>double</code>类型数组进行由小到大的排序，我们需将<code>cmp</code>函数写为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span> <span class="comment">// 调用 fabs 需要包含此头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(*(<span class="type">double</span>*)e1 - *(<span class="type">double</span>*)e2) &gt; <span class="number">1e-7</span>)  <span class="comment">// 浮点数判断是否相等的方式：和极小量比较！</span></span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">double</span>*)e1 &gt; *(<span class="type">double</span>*)e2 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="学习结构体的意义在哪儿"><a href="#学习结构体的意义在哪儿" class="headerlink" title="学习结构体的意义在哪儿"></a>学习结构体的意义在哪儿</h2><blockquote>
<p>结构体的声明、定义和使用都相对简单，结合课件即可掌握。较新的内容是指向结构体的指针，<strong>建议忽略本质、注重语法和使用</strong>，随着一两周后链表的学习，很快即可上手。</p>
</blockquote>
<p>先来考虑这样一种需要处理的情形：一个班级里有若干学生，每个学生的学号、姓名、成绩三个信息需要被记录，现在我们需要对其中的某些学生的信息进行数据处理，声明结构体如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> number[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>显然，如果我们只需要记录一位学生，大可不必使用<code>struct student kid;</code>的定义形式，也不需要在后续访问变量时使用<code>kid.number</code>、<code>kid.name</code>、<code>kid.grade</code>如此繁杂的方式。我们只需要分别定义两个字符串数组、一个<code>int</code>类型变量即可，此时<strong>为了某种程度上的整洁而声明结构体类型、定义结构体变量反而显得多此一举</strong>。</p>
<p>可是，一个班级的整体数据肯定不能只由一位同学代表，往往我们需要处理多达上百个同学的数据，这时结构体的优势就开始显现。如果我们借助结构体变量的数组存储，那么只需要定义<code>struct student info[200];</code>后续每个学生的学号、姓名、成绩均可以作为成员储存在一个结构体变量中。</p>
<p>虽然我们仍可分别定义以下三个数组储存学生信息，每个学生的信息一一对应地储存于各数组中:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> stu_number[<span class="number">200</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> stu_name[<span class="number">200</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> stu_grade[<span class="number">200</span>];</span><br></pre></td></tr></table></figure></div>

<p>显然，若我们需要了解第 i+1 个学生的信息（假设数组下标从 0 开始），我们可以直接在<code>info[i]</code>这一结构体变量中全部寻得，也可以通过依次访问<code>stu_number[i]</code>、<code>stu_name[i]</code>、<code>stu_grade[i]</code>寻得。但前者不是更简洁方便、显得整体化吗？</p>
<p>因此，我们可以这样说：<strong>结构体存在的意义在有数组时才能体现。</strong></p>
<p>但是，如果只需完成类似于统计班级里有多少同学姓“王”、有多少同学成绩在 90 分以上这样的任务，大可以使用上述三个数组，用遍历的方法求得满足条件学生的总数，似乎数组完全可以代替结构体变量，并且不会导致任何工作量的增加。<strong>这是因为这样的任务并没有把学生的三个信息建立起联系，对某一个信息进行统计的时候可以完全不用顾虑其他信息与之对应。</strong></p>
<p>那么问题来了：当需要将学生的成绩按照<strong>由大到小</strong>的顺序输出，并同时输出每个同学对应的姓名与学号，使用哪种方式更好呢？</p>
<p>对于这个问题，刚刚学习了<code>qsort</code>函数的你想要进行实践。若你使用常规的数组存储，很快便遇到了困难。你并不知道<code>qsort</code>函数每次是对哪两个具体元素进行了比较，因此你单纯地将<code>stu_grade</code>数组排好了序，但其余两个数组与<code>stu_grade</code>数组的对应关系已经完全丧失，再无可能正确地输出每一个成绩所对应的姓名与学号。</p>
<p><strong>但如果用<code>qsort</code>函数对结构体进行排序呢？</strong></p>
<p>通过前文的讲解我们知道，我们的**<code>cmp</code>函数规则应该是对于每个结构体中的<code>grade</code>变量进行比较，但比较后的结果，是交换这个结构体变量所拥有的全部字节内容<strong>，而这个内容中既包含了<code>grade</code>、也包含了<code>number[]</code>和<code>name[]</code>，因此我们便做到了</strong>在保留原有成员变量一一对应关系的基础之上，对学生成绩进行了排序**。</p>
<p>综上所述，在排序这样一个实际例子中，结构体变量存在着至关重要的意义与价值。</p>
<p>当然，结构体还有许多的应用场景，比如大家后续所要学习的链表……这里我们就不再详述。</p>
<p>另值一提的是，请同学们看看如下代码是否正确：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> student*)e1-&gt;grade &lt; (<span class="keyword">struct</span> student*)e2-&gt;grade) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果<code>cmp</code>函数内容如上所示，则使用<code>qsort</code>函数排序会出现奇怪的错误。原因是因为**类型转换符<code>(type *)</code>的运算优先级低于箭头运算符<code>-&gt;</code>**。所以会先计算<code>e2-&gt;grade</code>，再去做类型转换。因此正确写法为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">struct</span> student*)e2)-&gt;grade &lt; ((<span class="keyword">struct</span> student*)e1)-&gt;grade) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="标准-C-库文件-I-O"><a href="#标准-C-库文件-I-O" class="headerlink" title="标准 C 库文件 I&#x2F;O"></a>标准 C 库文件 I&#x2F;O</h2><blockquote>
<p><strong>文件 I&#x2F;O，即文件的输入输出（Input &#x2F; Output）</strong>，几乎是每一个软件项目必备的模块。此外，我们称读取一个文件的内容为<strong>“读文件”</strong>，称编辑一个文件的内容为<strong>“写文件”</strong>。</p>
<p>以 macOS、Linux、Windows 为代表的多数操作系统，都引入了文件的概念。<strong>资源即文件。</strong>文件不仅包括屏幕上显示的一个个“文件”，还包括各类设备，如鼠标、键盘、打印机、屏幕（标准输出）、音响、U 盘等。一般来说，我们接触到的文件有两类 —— <strong>文本文件</strong>和<strong>二进制文件</strong>。前者，可以理解为<strong>字符构成的有序集合</strong>，如 filein.txt 文本文件、test.c 源代码文件；后者的典型代表是 a.exe 这类<strong>可执行文件</strong>。特别要注意，word 等工具编辑出的 .docx 文件属于二进制文件，是不能直接用我们接下来要讲到的文件操作函数处理的。</p>
<p>这门课程涉及的文件操作无非基本的读写，可以理解成<strong>程序中字符数组里的内容与文件间的交换</strong>。关于判断文件是否存在、文件的创建 &#x2F; 删除 &#x2F; 复制 &#x2F; 移动 &#x2F; 重命名等操作，感兴趣的同学可以自己了解。</p>
</blockquote>
<h3 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h3><p>操作系统中的文件构成一个<strong>树状结构</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets2/截屏2023-03-05 14.26.17.png"
                      alt="截屏2023-03-05 14.26.17" style="zoom:30%;" 
                >

<p>文件系统从一个根出发，<strong>每个文件夹就是树枝的分叉、每个文件就是树叶</strong>。这里的<strong>文件夹，就是目录</strong>。目录下可以包含若干文件，也可以为空。<strong>目录本身也是文件，是一种特殊的文件。目录中默认有两个隐藏的文件，文件名为<code>.</code>和<code>..</code>，分别表示自身和父目录。</strong></p>
<p>定位一个文件，就需要给出文件的路径。一种方法是从根开始，一路写到当前文件，如<code>D:\MyFiles\DSLearning\main.c</code>，这就表示打开 D 盘，进入 Myfiles 文件夹，进入 DSLearning 文件夹，就可以找到 main.c 文件。这种方式称为<strong>绝对路径</strong>。另一种方法是，以<strong>当前所在的目录为基准点，描述目标的相对位置</strong>。以上图为例，假设我们处在 gcctest 目录下，则 foo.c 文件可以直接写<code>foo.c</code>或<code>./foo.c</code>（因为<code>.</code>表示当前目录），libfoo.so 文件可以写成 <code>include/libfoo.so</code>，bank.c 文件可以写成<code>../IPCtest/bank.c</code>（因为<code>..</code>表示父目录）。</p>
<p>上文中提到“当前所在目录”，可以简单理解为<strong>程序运行的目录</strong>，即 .exe 文件所在的目录。一般来说，<strong>把文件和 .exe 文件放在一起，在函数调用时直接指定文件名即可</strong>。</p>
<h3 id="标准-C-库文件操作函数"><a href="#标准-C-库文件操作函数" class="headerlink" title="标准 C 库文件操作函数"></a>标准 C 库文件操作函数</h3><p>在学习 C 语言的第一天，我们就知道要<code>#include &lt;stdio.h&gt;</code>，std 即 standard，io 即上文所述。我们调用的<code>printf</code>等，正是 C 库提供的 I&#x2F;O 函数。调用以下函数，也应包含此头文件。</p>
<h4 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">FILE* <span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">	<span class="comment">// 打开文件，成功返回文件指针，出错返回 NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 关闭文件，成功返回 0，出错返回 -1</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>这里的“文件指针”<code>FILE*</code>，是在<code>&lt;stdio.h&gt;</code>中定义的一个<strong>结构体指针</strong>，该结构体包含了一个文件的各类信息。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此代码块内容仅供了解 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> cnt;			<span class="comment">// 剩余字节数</span></span><br><span class="line">    <span class="type">char</span> *ptr;			<span class="comment">// 下一个字符的位置</span></span><br><span class="line">    <span class="type">char</span> *base;			<span class="comment">// 缓冲区的位置</span></span><br><span class="line">    <span class="type">int</span> flag;			<span class="comment">// 文件访问模式</span></span><br><span class="line">    <span class="type">int</span> fd;				<span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="comment">// 还有很多</span></span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>获取了一个文件的文件指针，将其作为参数传递给其他函数，即可读写对应的文件。</strong>很多时候，文件打开会失败，则<code>fopen</code>返回<code>NULL</code>。因此，建议同学们以以下方式打开一个文件。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示范代码，这部分代码位于 main 中</span></span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen error&quot;</span>); <span class="comment">// 此函数在 &lt;stdio.h&gt; 中，能帮助输出错误信息</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);               <span class="comment">// 此函数在 &lt;stdlib.h&gt; 中，能强制结束程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>fopen</code>函数的第一个参数为<strong>文件路径</strong>，前文已经说明。第二个参数指定打开方式，常见的是<code>&quot;r&quot;</code>和<code>&quot;w&quot;</code>。前者表示读，后者表示写。<strong>读文件，要求文件已经存在</strong>，否则会打开失败；写文件，<strong>默认不存在则创建</strong>，如果存在且已经有内容，则<strong>清空</strong>后从头开始写。</p>
</li>
<li><p>程序运行时默认已经打开了三个文件 —— 标准输入<code>stdin</code>、标准输出<code>stdout</code>、标准错误<code>stderr</code>，这是三个文件指针，分别对应键盘、屏幕、屏幕。</p>
</li>
</ul>
<blockquote>
<p>使用<code>fopen</code>打开一个文件，则应当使用<code>fclose</code>关闭。当然做编程题的时候不写也没事。但是，这种规范操作仍应当强调，即便你可能并不会在意。当然，如果日后你因为忘记 close 或 free 而导致一个实际项目出现 bug，你一定会有所感悟的。</p>
</blockquote>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>通过<code>fopen</code>获得文件指针后，可以调用相关 I&#x2F;O 函数读写文件。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> size, FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 以行为单位读取文件指针 fp 对应的文件中的内容，存到字符数组 str 中，一次最多读取 size 个字符</span></span><br><span class="line">    <span class="comment">// 读取成功返回 str，读到文件末返回 NULL</span></span><br><span class="line">	<span class="comment">// 此函数会读取换行符，这与 gets 不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 1</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">fgets(str, <span class="number">1024</span>, <span class="built_in">stdin</span>);  <span class="comment">// 从键盘读取字符串，基本等价 gets，但会读进换行符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 2</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);              <span class="comment">// 如果打开失败则结束程序</span></span><br><span class="line"><span class="keyword">while</span> (fgets(buffer, <span class="number">1024</span>, fp) != <span class="literal">NULL</span>) &#123; <span class="comment">// 逐行读取文件内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line">	<span class="comment">// 功能同 scanf，只是多了参数指出输入来源于哪个文件</span></span><br><span class="line">	<span class="comment">// 读到文件末返回 EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 1</span></span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">fscanf</span>(<span class="built_in">stdin</span>, <span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c); <span class="comment">// 同 scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span></span><br><span class="line"><span class="comment">// 【特别提醒】读字符串的时候，不要加 &amp; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 2</span></span><br><span class="line"><span class="comment">// 从文件中读取空格分隔的若干学生的成绩（整数），求平均分并输出（一位小数）</span></span><br><span class="line"><span class="type">int</span> score, sum = <span class="number">0</span>, cnt = <span class="number">0</span>;                <span class="comment">// 很多同学都会忘记初始化</span></span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;scores.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;score) != EOF) &#123;</span><br><span class="line">    sum += score;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;average: %.1f\n&quot;</span>, sum * <span class="number">1.0</span> / cnt); <span class="comment">// 整数运算结果还是整数，你还记得这个细节吗</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 从 fp 所指的文件中读取一个字符，调用时可写 char c = fgetc(fp);</span></span><br><span class="line">	<span class="comment">// 读到文件末返回 EOF</span></span><br><span class="line">	<span class="comment">// 上一期猪脚说解释了为什么很多理应用 char 的地方写成了 int，这是合理且安全的</span></span><br><span class="line">	<span class="comment">// 我们自己在写程序时，也可以写 int c = fgetc(fp); printf(&quot;%c&quot;, c);</span></span><br></pre></td></tr></table></figure></div>

<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>这里仅提供函数原型，使用与非文件 I&#x2F;O 版本无异，只是多传入一个文件指针而已。<strong>写文件时，应指定<code>fopen</code>打开模式为<code>&quot;w&quot;</code>。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 将字符串 s 写入 fp 所指的文件中</span></span><br><span class="line">	<span class="comment">// 不同于 puts，此函数不会自动换行</span></span><br><span class="line">	<span class="comment">// fputs(s, stdout); 等价于 printf(&quot;%s&quot;, s);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line">	<span class="comment">// 类比 printf，当 fp 为 stdout 时等价于 printf</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 类比 putchar，当 fp 为 stdout 时等价于 putchar</span></span><br></pre></td></tr></table></figure></div>

<h3 id="文件偏移量"><a href="#文件偏移量" class="headerlink" title="文件偏移量"></a>文件偏移量</h3><p>我们在读写文件时，很自然地会认为我们是不断向文件尾部读取或添加内容。假如读完一个文件，还想再读一遍，一种做法是先 close 再 open。那我们能不能像实际编辑文件那样在读完一部分内容后，跳到前面再读一遍，或者是在文件中间插入内容呢。<strong>正如同使用 word 时的那个不断闪烁的光标，当我们操作文件的时候，FILE 结构体也在维护一个文件偏移量，它指的是距离文件头的字符数（准确是是字节数），文件的读写，都是从当前偏移量开始往后进行的。</strong></p>
<p><strong>使用<code>fopen</code>打开文件时，文件偏移量为 0，即光标位于文件头。</strong>当我们不断读取内容，光标不断后移，则文件偏移量不断增大。<strong>当文件偏移量等于文件字节数（一般等于文件字符数 &#x2F; 文件大小）的时候，就读到了文件末尾。</strong></p>
<p>一个很显然的想法是，<strong>不同的文件读取方式，每次文件偏移量的增量也不同。</strong>例如，刚打开一个文件（假设其中的内容足够多），连续调用两次**<code>fgetc</code>，则每次偏移量加一<strong>；调用</strong><code>fgets</code><strong>，则偏移量从第一行的第三个字符</strong>跳到行尾<strong>；再次</strong><code>fgets</code>，则偏移量跨过第二行跳到第二行行尾<strong>；进行<code>fscanf</code>，假设格式串为<code>&quot;(%d,%d)%c%lf&quot;</code>，且第三行的数据类型符合要求，则文件偏移量跳过 1 个字节</strong>吞掉**<code>(</code>、跳过 4 个字节<strong>读取</strong><code>int</code>、跳过 1 个字节<strong>吞掉</strong><code>,</code>、跳过 4 个字节<strong>读取</strong><code>int</code>、跳过 1 个字节<strong>吞掉</strong><code>)</code>、跳过 1 个字节<strong>读取</strong><code>char</code>、最后跳过 8 个字节<strong>读取</strong><code>double</code>。</p>
<p>介绍文件偏移量有助于我们理解文件的写入和读取顺序，如果想要<strong>手动设置文件偏移量</strong>，实现更加复杂的文件操作，请自行学习<code>fseek</code>等函数。</p>
<h2 id="第二次作业补充练习"><a href="#第二次作业补充练习" class="headerlink" title="第二次作业补充练习"></a>第二次作业补充练习</h2><p>1、<a class="link"   href="https://www.luogu.com.cn/problem/P1104" >按照结构体某一成员变量进行排序。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>2、<a class="link"   href="https://www.luogu.com.cn/problem/P1786" >稍微有一点难度的结构体排序。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第三期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%B8%89%E6%9C%9F/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets3/IMG_0781.jpg"
                      alt="IMG_0781" style="zoom:40%;" 
                >

<h2 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h2><blockquote>
<p><strong>注意</strong></p>
<p>在此课程中，使用结构体的时候请确保源代码文件是<code>.c</code>后缀而非<code>.cpp</code>。C++ 中的结构体和 C 完全不同，或者说，C++ 里的<code>struct</code>不是结构体，而是<strong>类（class）</strong>。C++ 和 C 语法相近，但很多细节存在差异，甚至可能导致截然不同的编译错误和运行结果 —— 水很深，请谨慎！</p>
</blockquote>
<h3 id="声明（declaration）"><a href="#声明（declaration）" class="headerlink" title="声明（declaration）"></a>声明（declaration）</h3><p>当我们写下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>    i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">char</span>   str[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>的时候，我们声明了一种<strong>自定义的结构体类型</strong>。其中，</p>
<ul>
<li><code>struct</code>是结构体<strong>关键字（key word）</strong>，<code>struct mystruct</code>是<strong>类型（type）</strong>。<ul>
<li><code>struct</code>不是任何类型，<strong>仅仅只是</strong>一个关键字；</li>
<li><code>struct mystruct</code>是类型，是和<code>int</code> <code>double</code> <code>char</code>等并列的<strong>数据类型</strong>，并且是<strong>复合数据类型</strong>。</li>
</ul>
</li>
</ul>
<p>但是，上文的写法单纯是<strong>类型的声明</strong>—— 它指明了这一新类型<strong>应该长什么样</strong> —— 含有一个<code>int</code>成员、一个<code>double</code>成员和一个<code>char</code>数组成员。于是我们有了一些新名词：成员变量（member variable）、字段（field）、域（field）、属性（attribute），从某种意义说上它们是等价的。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>上述声明的自定义复合数据类型为<code>struct mystruct</code>。这种类型写起来比较复杂，所以可以为之起一个别名</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span> <span class="title">Type</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>此后，<strong>任何用到<code>struct mystruct</code>类型的地方，都可以用别名<code>Type</code>指代</strong>。此外，我们也可以另外为指向该结构体的<strong>指针类型</strong>起一个别名</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span> * <span class="title">Type_ptr</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>当然，在<strong>声明结构体的同时</strong>就可以为新类型起别名</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125; m_type, * m_type_ptr;</span><br></pre></td></tr></table></figure></div>

<p>我们注意到，上述代码片段中<code>struct</code>关键字后并没有结构体原本的名字，这种<strong>无名</strong>的结构体，要么需要在声明的同时为之起别名，以便在后续程序中使用这一类型；要么必须在声明后立即定义相关变量（详见下文）。</p>
<blockquote>
<p><strong>补充</strong></p>
<p>我们用到的很多头文件中都进行了大量别名的声明。</p>
<ul>
<li><p><code>FILE</code>类型其实是一个结构体，为了使之更加<strong>贴近英文语义</strong>，所以为之起了别名</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// much more...</span></span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>size_t</code>是用于描述<strong>字节数</strong>或“大小”“长度”的类型，如<code>sizeof</code>的返回值、数组大小等</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">size_t</span>; <span class="comment">// 无符号长整型，用 %lu 输出</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>部分字符串处理函数中，会使用<code>ssize_t</code>类型表示<strong>字符串的长度</strong></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> <span class="type">ssize_t</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>操作系统中，为<strong>进程编号（Process ID）</strong>类型起了别名</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">pid_t</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><del>部分同学为了书写简便，为<code>long long</code>起了别名</del></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll; <span class="comment">// 好吧我承认这么写没毛病😋</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</blockquote>
<h3 id="定义（definition）"><a href="#定义（definition）" class="headerlink" title="定义（definition）"></a>定义（definition）</h3><p>当我们写下<code>int a = 10;</code>的时候，<strong>定义</strong>了一个整型<strong>变量</strong>。我们有了自己的类型<code>struct mytype</code>，为之声明了别名<code>Type</code>，为其指针声明了别名<code>Type_ptr</code>，我们也可以定义此类型的变量和数组。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytype</span>  <span class="title">t1</span>, <span class="title">t2</span>;</span> <span class="comment">// 两个结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytype</span>* <span class="title">t3</span>, <span class="title">t4</span>;</span> <span class="comment">// t3 是结构体的指针，t4 是结构体变量</span></span><br><span class="line"></span><br><span class="line">Type  t5, t6; <span class="comment">// 两个结构体变量</span></span><br><span class="line">Type* t7, t8; <span class="comment">// t7 是结构体的指针，t8 是结构体变量</span></span><br><span class="line"></span><br><span class="line">Type_ptr p1, p2, p3; <span class="comment">// 三个都是结构体的指针</span></span><br></pre></td></tr></table></figure></div>

<p>当然我们可以在<strong>声明结构体的同时</strong>定义变量和数组</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; a1, a2, arr[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></div>

<p><strong>如果声明的同时用<code>typedef</code>起了别名，则不能在其后直接定义变量。</strong></p>
<p>前面提到的无名结构体，如果没有在声明的同时为之起别名，则只能在声明的同时定义变量和数组</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">&#125; v1, v2, v3[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></div>

<p>很显然，我们在后续的程序中只能访问<code>v1</code> <code>v2</code> <code>v3</code>，而不能再定义此类型的变量或数组了 —— 因为这个类型没有名字。</p>
<blockquote>
<p><strong>注意：请严格区分声明与定义！</strong></p>
</blockquote>
<h3 id="前向声明"><a href="#前向声明" class="headerlink" title="前向声明"></a>前向声明</h3><p>我们知道<strong>声明结构体的时候不能嵌套</strong>，如<code>struct A &#123; struct A a; &#125;;</code>，因为这会造成无穷的嵌套，导致报错。那么假设<strong>两个结构体相互引用对方，并且均采用了类型别名的形式</strong>，会不会出现问题呢？</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    type_B *pb;</span><br><span class="line">&#125; type_A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    type_A *pa;</span><br><span class="line">&#125; type_B;</span><br></pre></td></tr></table></figure></div>

<p>当编译器读到结构体 A 的声明时，它发现需要有一个类型<code>type_B</code>的指针变量，然而<code>type_B</code>声明在后方，编译器暂时不知道其存在。假如把 A 和 B 的声明顺序对调，同样存在这一问题。</p>
<p>解决方法是使用<strong>前向声明（forward declaration）</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">type_B</span>;</span></span><br><span class="line">    <span class="comment">// 告诉编译器，我现在有一个 struct B 类型，它的别名是 type_B</span></span><br><span class="line">	<span class="comment">// struct B 具体长什么样，你自己到后面去找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    type_B *pb;    <span class="comment">// 编译器读到这里，它已经知道有 type_B 这个类型了，所以编译通过</span></span><br><span class="line">&#125; type_A;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    type_A *pa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="一定要记得初始化😭😭😭"><a href="#一定要记得初始化😭😭😭" class="headerlink" title="一定要记得初始化😭😭😭"></a>一定要记得初始化😭😭😭</h2><p>「为什么我会输出乱码啊」「为什么会多输出几个字符啊」「为什么字符串长度和追加出错了啊」……</p>
<p><strong>请再次检查，你是否对每一个变量、数组都初始化了。</strong></p>
<p>我们讨论初始化，并不是说什么时候需要初始化、什么时候可以不初始化，而是说<strong>任何情况</strong>、<strong>不论全局还是局部</strong>，都必须初始化！</p>
<ul>
<li><p>在任何地方都<strong>绝不允许</strong>写<code>int i;</code>而<strong>必须</strong>写<code>int i = 0;</code></p>
</li>
<li><p>在任何地方都<strong>绝不允许</strong>写<code>char str[100];</code>而<strong>必须</strong>写<code>char str[100] = &#123;0&#125;;</code></p>
</li>
<li><p>设我们有结构体</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>  在任何地方都<strong>绝不允许</strong>只写<code>struct A test[100];</code>而<strong>必须</strong>写</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">test</span>[100];</span></span><br><span class="line"><span class="comment">/*****************************</span></span><br><span class="line"><span class="comment">  以下初始化内容必须写！不许说麻烦。</span></span><br><span class="line"><span class="comment">*****************************/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;         <span class="comment">// 结构体数组必须初始化，且用循环初始化</span></span><br><span class="line">    test[i].i = <span class="number">0</span>;</span><br><span class="line">    test[i].d = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;      <span class="comment">// 一维数组必须初始化，用循环初始化或用 memset</span></span><br><span class="line">        test[i].s[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;      <span class="comment">// 二维数组必须初始化，且用循环初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++) &#123;</span><br><span class="line">            test[i].arr[j][k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>另外关于<code>memset</code>的使用，我们只需要知道</p>
<ul>
<li><p><strong>仅能将所有元素初始化为 0</strong></p>
</li>
<li><p>仅有如下的基本使用方法</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="type">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> l_array[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(l_array));</span><br><span class="line"></span><br><span class="line"><span class="comment">// memset 其他值是会出错的，可以试试如下代码</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">1</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p><strong>补充</strong></p>
<p>DevC++ 默认使用 C89 标准，此时局部变量仅能定义在函数开头。而我们很多时候见到的<code>for(int i = 0; ...)</code>这种在后续代码中定义变量的形式，是从 C99 标准开始才支持的。解决方法如下</p>
<ul>
<li><p>Step1：打开工具菜单</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets3/3-1.jpg"
                      alt="3-1" style="zoom:50%;" 
                >
</li>
<li><p>Step2：在下拉菜单中选择“编译选项”</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets3/3-2.PNG"
                      alt="3-2" style="zoom:20%;" 
                >
</li>
<li><p>Step3：勾选“编译时加入以下命令”，加入<code>-std=c99 -Wall</code>，点击“确定”。这两个选项，前者指定了使用 C99 标准，后者能帮我们输出更多警告信息。</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets3/3-3.PNG"
                      alt="3-3" style="zoom:25%;" 
                ></li>
</ul>
</blockquote>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a><code>sizeof</code></h2><p>上文提到，<code>sizeof</code>返回对象的字节数大小，类型为<code>size_t</code>，可用<code>%lu</code>输出，用<code>%d</code>一般没有问题但是会给警告。</p>
<ul>
<li><h3 id="sizeof-基本类型或其变量"><a href="#sizeof-基本类型或其变量" class="headerlink" title="sizeof 基本类型或其变量"></a><code>sizeof</code> 基本类型或其变量</h3>  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>);   <span class="comment">// int 的大小一般都是 4 个字节</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;    <span class="comment">// 如果想要使用与机器类型无关的整型变量，&lt;stdint.h&gt; 中有很多可供选择</span></span><br><span class="line"><span class="keyword">sizeof</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">char</span>*);    <span class="comment">// 32 位机器的指针大小为 4 字节，64 位机器则为 8 字节</span></span><br><span class="line"><span class="type">double</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(p);        <span class="comment">// 指针大小固定，与所指的类型无关</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><h3 id="sizeof-结构体类型或其变量"><a href="#sizeof-结构体类型或其变量" class="headerlink" title="sizeof 结构体类型或其变量"></a><code>sizeof</code> 结构体类型或其变量</h3>  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> test);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">t1</span>;</span></span><br><span class="line"><span class="keyword">sizeof</span>(t1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，struct 的 size 并不一定等于其各个成员的 size 之和</span></span><br><span class="line"><span class="comment">// 具体原因可以自行百度 “结构体字节对齐”，此处不要求掌握</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><h3 id="sizeof-数组名"><a href="#sizeof-数组名" class="headerlink" title="sizeof 数组名"></a><code>sizeof</code> 数组名</h3>  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 定义整型数组</span></span><br><span class="line"><span class="type">int</span> *p = arr;       <span class="comment">// 定义指针管理数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(arr);    <span class="comment">// sizeof(数组名)，返回数组总字节数，即 100 * sizeof(int)</span></span><br><span class="line"><span class="keyword">sizeof</span>(p);      <span class="comment">// sizeof(指向数组的指针)，返回指针本身大小，与机器位数有关</span></span><br><span class="line"><span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// sizeof(数组元素)，返回单个元素的大小，即 sizeof(int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *q    = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(str);          <span class="comment">// 返回 6</span></span><br><span class="line"><span class="keyword">sizeof</span>(q);            <span class="comment">// 返回 4(32位机器) 或 8(64位机器)</span></span><br><span class="line"><span class="built_in">strlen</span>(str);          <span class="comment">// 返回 5</span></span><br><span class="line"><span class="built_in">strlen</span>(q);            <span class="comment">// 返回 5</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><blockquote>
<p>在一些较复杂的项目中，除了声明必要的结构体之外，往往需要借助多维数组、并在函数原型中声明多维数组，特别是二维数组。使用二维数组时有很多易忽略的点，我们希望在接下来的内容中帮助大家更深地了解二维数组的本质，并尽量减少编程时 bug 的产生。</p>
</blockquote>
<h3 id="二维数组的存储"><a href="#二维数组的存储" class="headerlink" title="二维数组的存储"></a>二维数组的存储</h3><p><strong>二维数组，也可以看成一个一维数组，这个一维数组中的每个元素都是一个一维数组。</strong></p>
<p>因此，若将二维数组的每一行当做一个存储一维数组的元素，所有行汇集成一个一维数组，每个一维数组中各元素是连续存储的，那么就很容易理解：二维数组中的各元素在内存中是<strong>按照行优先的原则，进行连续存储。</strong></p>
<p>例如，我们定义数组<code>a[2][6]</code>，那么其在内存中从某一地址开始，存储情况如下图：</p>
<p>![截屏2023-03-10 13.31.04](&#x2F;images&#x2F;assets3&#x2F;截屏2023-03-10 13.31.04.png)</p>
<p>那么该数组中某个元素<code>a[i][j]</code>的地址<code>&amp;a[i][j]</code>可以通过如下方式求得：<code>首地址 + 单个元素长度 * (总列数 * i + j)</code>。</p>
<p>由此可知，若想知道该二维数组中某一元素的地址，就必须知道该数组的数据类型和列数，这样才能实现对二维数组中某一个元素的精确访问，<strong>这也是为什么我们在声明二维数组以及把一个二维数组当作形参传递时，必须指定列数，否则就会报错。</strong></p>
<p>我们来看如下几行代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a[][], <span class="type">int</span> b)</span>;    <span class="comment">// error：没有指定列数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a1[][], <span class="type">int</span> b)</span>;   <span class="comment">// error：没有指定列数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a2[<span class="number">2</span>][], <span class="type">int</span> b)</span>;  <span class="comment">// error：没有指定列数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a3[<span class="number">3</span>][<span class="number">4</span>], <span class="type">int</span> b)</span>; <span class="comment">// right</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a4[][<span class="number">5</span>], <span class="type">int</span> b)</span>;  <span class="comment">// right</span></span><br></pre></td></tr></table></figure></div>

<h3 id="二维数组的指针访问"><a href="#二维数组的指针访问" class="headerlink" title="二维数组的指针访问"></a>二维数组的指针访问</h3><blockquote>
<p>在此，我们推荐两种访问二维数组的方法，但不代表访问它的方法仅有如下两种。</p>
</blockquote>
<h4 id="指向元素的指针"><a href="#指向元素的指针" class="headerlink" title="指向元素的指针"></a>指向元素的指针</h4><p>这种方法最简单直接，现有如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">6</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure></div>

<p>在此种定义下，访问数组<code>a</code>中的每一个元素只需要将<code>p</code>指针依次往后推，利用 4.1 中求某元素地址的方式即可实现精确访问。在该例子中，我们便知道了<code>&amp;a[i][j] == p + sizeof(int) * (6 * i + j)</code>。</p>
<h4 id="列指针"><a href="#列指针" class="headerlink" title="列指针"></a>列指针</h4><p>这种方式通过定义指针指向二维数组的<strong>某一行的第一列</strong>，再在此基础上访问该行的某个元素，现有如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">6</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> *p[<span class="number">2</span>] = &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;; <span class="comment">// 当然，你也可以使用循环来为这个指针数组赋值</span></span><br></pre></td></tr></table></figure></div>

<p>由此，指针数组<code>p</code>中第一个元素为二维数组<code>a</code>中第一行第一个元素的地址（意即第一行的首地址），第二个元素为二维数组<code>a</code>中第二行第一个元素的地址（意即第二行的首地址）。</p>
<p>在该例子中，我们便知道了<code>&amp;a[0][j] == p[0] + sizeof(int) * j</code> 以及<code>&amp;a[1][j] == p[1] + sizeof(int) * j</code>。</p>
<h3 id="二维数组的形参传递"><a href="#二维数组的形参传递" class="headerlink" title="二维数组的形参传递"></a>二维数组的形参传递</h3><blockquote>
<p>我们在 4.1 中已经提到，当我们把一个二维数组作为形参传递进入另一个函数里（例如有些同学做第二次作业的五子棋危险判断）时，<strong>一定要指定列数</strong>。在此我们也推荐两种写法。</p>
</blockquote>
<h4 id="数组法"><a href="#数组法" class="headerlink" title="数组法"></a>数组法</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a[][<span class="number">6</span>], <span class="type">int</span> row)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    print_two_dim(a,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>请注意：以下传递方式无效，不能将二维数组的真实行数传入函数中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> a[<span class="number">2</span>][<span class="number">6</span>])</span>;</span><br></pre></td></tr></table></figure></div>

<p>原因是：如同一维数组的形参传递一样，<strong>传入的数组被转化为指针，函数内部无法获取该数组大小。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下两种传递方式等效</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_one_dim1</span><span class="params">(<span class="type">int</span> num[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_one_dim2</span><span class="params">(<span class="type">int</span> num[<span class="number">20</span>])</span>; <span class="comment">// 20在这里是无效的</span></span><br></pre></td></tr></table></figure></div>

<h4 id="数组指针法"><a href="#数组指针法" class="headerlink" title="数组指针法"></a>数组指针法</h4><blockquote>
<p>数组指针指向二维数组，有些教材称这种指针为<strong>行指针</strong>，顾名思义就是操纵一行的指针。</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_two_dim</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">6</span>], <span class="type">int</span> row)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数组名为 a，表示首元素的地址</span></span><br><span class="line">    <span class="comment">// 二维数组的首元素是二维数组的第一行</span></span><br><span class="line">    <span class="comment">// 所以传递进函数的 a ，相当于第一行的地址，是一维数组的地址</span></span><br><span class="line">    print_two_dim(a,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述代码中，我们用数组指针来接收，也必须指定有 6 列，<strong>这是为了告诉内存，第二行从哪儿开始存放。</strong></p>
<p>因此，形参中的<code>(*a)[6]</code>中，**<code>a</code>指向二维数组第一行的地址。**<code>*a</code>就是二维数组第一个元素的地址，<code>**a</code>才能找到第一个元素的具体值，为 1。</p>
<h3 id="char型二维数组"><a href="#char型二维数组" class="headerlink" title="char型二维数组"></a><code>char</code>型二维数组</h3><p>我们在 4.1 中提到，二维数组的存储方式为按行优先，连续存储。另一层意思就是说，二维数组里每一行所代表的一维数组是连续的，并非毫无关联。如果你并没有领略到这一层意思，那么请看如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> test[<span class="number">2</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        test[<span class="number">0</span>][i] = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        test[<span class="number">1</span>][i] = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">    test[<span class="number">1</span>][i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, test[<span class="number">0</span>]);</span><br><span class="line">    test[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, test[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>代码的运行结果：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">abcdefghijklmnopqrstuvwxyzabcdefg</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure></div>

<p>诶！按照惯性思维，你会发现：我第一次打印时明明只想让他打印出二维数组第一行的值，<strong>为啥它把第二行的值一起打印出来了呢？</strong></p>
<p>相信大家一定知道，<code>printf(&quot;%s&quot;,a)</code>这样一段代码，其本质上是从字符串数组<code>a</code>的首地址开始打印，知道遇到字符串终止字符（也就是<code>&#39;\0&#39;</code>）停止。</p>
<p>那么再回到上述代码，由于二维数组的顺序存储特性，<code>test[1][0]</code>元素是紧跟在<code>test[0][25]</code>元素之后的，也就是说当输出<code>test[0][25]</code>元素时，系统发现该元素之后并不是<code>&#39;\0&#39;</code>，而是一个有着具体值的字符，于是就会接着输出，直到遇到<code>&#39;\0&#39;</code>为止。于是，我们通过让<code>test[1][0]=&#39;\0&#39;</code>，成功地让输出停留在<code>test[0][25]</code>的位置上，实现了只输出第一行的目的。</p>
<p>这也告诉我们，当我们使用<code>char</code>类型二维数组时，首先需要初始化，<strong>且尽量不要让该数组的列数小到恰好等于我们想让它存储的数据个数</strong>，否则就会像上述例子一样，每一行末尾没有<code>&#39;\0&#39;</code>，在进行后续的按行操作时出现 bug。</p>
<p><em>Author: diandian, Riccardo(Version Grey)</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第五期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%BA%94%E6%9C%9F/</url>
    <content><![CDATA[<blockquote>
<p>在这一部分中，我们会针对同学们问的比较多的题目（或者易错点较多的题目），给出若干的代码。大家可以参考题解中的代码，<strong>学习一下代码规范【好好看看哪里要空格哪里要空行！！！】</strong>，对比一下自己的代码与我们给出的参考代码，孰优孰劣,亦或者代码中的某些段落可以打包成一个固定模版，在后续作业、考试中使用。</p>
</blockquote>
<p><strong>如果针对这些题，同学们有更好更简洁的方法，欢迎来找助教讨论分享，助教请喝奶茶。</strong></p>
<h2 id="表达式计算（支持空格，连乘，连除）"><a href="#表达式计算（支持空格，连乘，连除）" class="headerlink" title="表达式计算（支持空格，连乘，连除）"></a>表达式计算（支持空格，连乘，连除）</h2><p>法一：先计算乘除，再加减（先计算表达式中所有的乘除，再从左到右进行加减）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, b[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, op[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len, i,j = <span class="number">0</span>, k = <span class="number">0</span>, cnt;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans, num[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">    	<span class="comment">// 虽然数字都是int型，但int型的数字相加和相乘可能超int范围</span></span><br><span class="line">    </span><br><span class="line">    gets(a);</span><br><span class="line">    len = <span class="built_in">strlen</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            b[k++] = a[i];</span><br><span class="line">    &#125; <span class="comment">// 将清除空格后的字符串保存在数组b中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; b[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; b[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            num[j] = <span class="number">10</span> * num[j] + b[i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 非常好用的从一串字符中读取整数数字的方法</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            op[j] = b[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 将数字与运算符分别存进两个数组，一个数字对应一个运算符，下标一一对应</span></span><br><span class="line">    </span><br><span class="line">    cnt = j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            num[i] = num[i] * num[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                op[j] = op[j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                num[j] = num[j + <span class="number">1</span>];</span><br><span class="line">            i--;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若遇到*，则计算当前两个数的乘积，保存到*前的数，后面的数与运算符往前移。</span></span><br><span class="line">        <span class="comment">// 由于前移了，则下次进入循环时仍然该从当前位开始，为了抵消i++的影响，执行</span></span><br><span class="line">        <span class="comment">// 一次i--，同时总数cnt--</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            num[i] = num[i] / num[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                op[j] = op[j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                num[j] = num[j + <span class="number">1</span>];</span><br><span class="line">            i--;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ans = num[<span class="number">0</span>]; <span class="comment">// 此时表达式中的乘除已全部处理完毕，接下来从左到右执行加减运算即可。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op[i] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            ans += num[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            ans -= num[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>法二：后悔法（读入什么就运算什么，读到乘除往前反悔）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, x[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, t[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, a[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, j = <span class="number">0</span>, k = <span class="number">0</span>, k1 = <span class="number">1</span>, len, len1, ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    gets(s);</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            x[k++] = s[i];</span><br><span class="line">    &#125; <span class="comment">// 将清除空格后的字符串保存在数组x中</span></span><br><span class="line">    </span><br><span class="line">    len1 = <span class="built_in">strlen</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len1 - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; x[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            a[j] = <span class="number">10</span> * a[j] + x[i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 非常好用的从一串字符中读取整数数字的方法</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            t[j] = x[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="comment">// 将数字与运算符分别存进两个数组，一个数字对应一个运算符，下标一一对应</span></span><br><span class="line">    &#125;     <span class="comment">// 不需要考虑末尾的“=”，因此循环结束条件为i&lt;len1-1</span></span><br><span class="line">    </span><br><span class="line">    ans += a[<span class="number">0</span>]; <span class="comment">// 记录第一个数字为当前运算结果</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = ans - a[i] + a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                a[i + <span class="number">1</span>] = a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="comment">// 特判，第一个符号为乘号</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                    ans = ans - a[i] + a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 1+2*3，先算1+2得到3，读到*后，往前反悔，</span></span><br><span class="line">                    <span class="comment">// 于是当前预算结果为3-2+2*3，后续思路相同</span></span><br><span class="line">                    a[i + <span class="number">1</span>] = a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                    <span class="comment">// 对于连乘，1+2*3*4，运算到1+2*3为7时，再读到乘号，需要用变量k1记录</span></span><br><span class="line">                    <span class="comment">// 连续乘or除多少次，反悔时才能找到相应位置，于是现在运算结果为7-6+6*4，</span></span><br><span class="line">                    <span class="comment">// 后续思路相同</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    ans = ans + a[i] - a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                    a[i + <span class="number">1</span>] = a[i] * a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    ans *= a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    ans *= a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = ans - a[i] + a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                a[i + <span class="number">1</span>] = a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i-k1] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                    ans = ans - a[i] + a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                    a[i + <span class="number">1</span>] = a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    ans = ans + a[i] - a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                    a[i + <span class="number">1</span>] = a[i] / a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    ans /= a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t[i - k1] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    ans /= a[i + <span class="number">1</span>];</span><br><span class="line">                    k1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            ans += a[i + <span class="number">1</span>];</span><br><span class="line">            k1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            ans -= a[i + <span class="number">1</span>];</span><br><span class="line">            k1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>法三：使用<code>scanf</code>函数可以自动消除空格，同时每次将一个数字和一个运算符成对读入，直接进行运算。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">0</span>, num2, num3;</span><br><span class="line">    <span class="type">char</span> op1 = <span class="string">&#x27;+&#x27;</span>, op2, op3; <span class="comment">// 这样初始化是为了输入第一个数num2时，可以实现0+num2的效果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>,&amp;num2, &amp;op2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (op2 == <span class="string">&#x27;*&#x27;</span> || op2 == <span class="string">&#x27;/&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">// 当输出乘除时，继续往后输入，直到退出连乘/除为止</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>, &amp;num3, &amp;op3);</span><br><span class="line">            <span class="keyword">if</span> (op2 == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                num2 = num2 * num3;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2 = num2 / num3;</span><br><span class="line">            op2 = op3; <span class="comment">// 更新op2为当前输入的符号</span></span><br><span class="line">        &#125; <span class="comment">// 此时已经退出连乘/除模式，往后直接执行加减操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (op1 == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            num1 = num1 + num2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op1 == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            num1 = num1 - num2;</span><br><span class="line">        </span><br><span class="line">        op1 = op2; <span class="comment">// 更新op1为当前当前输入的符号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (op1 == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num1);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="超长正整数的减法"><a href="#超长正整数的减法" class="headerlink" title="超长正整数的减法"></a>超长正整数的减法</h2><p>这道题的易错点在于：</p>
<p>1、连续借位相减（例如执行 10000 - 1 的运算）；</p>
<p>2、有些同学使用长度和字典序关系判断两数大小，这是正确且高效的方法，但请注意<code>strcmp()</code>函数的返回值；</p>
<p>3、注意<code>0</code>和<code>&#39;0&#39;</code>的区别，对其他数字也是同理。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str_a[M] = &#123;<span class="number">0</span>&#125;, str_b[M] =&#123; <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num_a[M] = &#123;<span class="number">0</span>&#125;, num_b[M] = &#123;<span class="number">0</span>&#125;, num_c[M] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len_a, len_b;</span><br><span class="line">    <span class="type">int</span> i, j, k, n, f = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    gets(str_a);</span><br><span class="line">    gets(str_b);</span><br><span class="line">    len_a = <span class="built_in">strlen</span>(str_a);</span><br><span class="line">    len_b = <span class="built_in">strlen</span>(str_b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (len_a &lt; len_b)</span><br><span class="line">        k = len_b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        k = len_a; <span class="comment">// 让k为两数组的最大长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (len_a &gt; len_b)</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len_a == len_b)</span><br><span class="line">        n = <span class="built_in">strcmp</span>(str_a, str_b) &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n = <span class="number">-1</span>; <span class="comment">//给n赋值，在之后判断需不需要打印负号</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = len_a - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--, j++)</span><br><span class="line">        num_a[j] = str_a[i] - <span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">    <span class="comment">// 很经典的将字符&#x27;0&#x27;转换成数字0的方法，且同时实现数组反序存储</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = len_b - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--, j++)</span><br><span class="line">        num_b[j] = str_b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123; <span class="comment">// 判断n是为了让程序永远执行大数减小数</span></span><br><span class="line">            <span class="keyword">if</span> (num_a[i] - num_b[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                num_c[i] = num_a[i] - num_b[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                num_c[i] = num_a[i] + <span class="number">10</span> - num_b[i];</span><br><span class="line">                num_a[i+<span class="number">1</span>]--;</span><br><span class="line">            &#125; <span class="comment">// 借位的判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (num_b[i] - num_a[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                num_c[i] = num_b[i] - num_a[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                num_c[i] = num_b[i] + <span class="number">10</span> - num_a[i];</span><br><span class="line">                num_b[i + <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num_c[i])</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 只要num_c数组中不是0，则把f赋值为1，目的只是为了消除</span></span><br><span class="line">            <span class="comment">// 打印出的数组中的前导0，所以不用重新赋值，不用考虑“新的开始”</span></span><br><span class="line">        <span class="keyword">if</span> (f || i == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num_c[i]); </span><br><span class="line">        <span class="comment">// 如果结果本身就是0，需要输出一个0，所以再加一个i==0的条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="全排列数的生成"><a href="#全排列数的生成" class="headerlink" title="全排列数的生成"></a>全排列数的生成</h2><p>这道题可以用递归或非递归实现，具体方法我们在上机的时候已经统一讲过了，这里不作赘述，直接上码！</p>
<p>法一：递归与回溯法</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tape</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *str1, <span class="type">int</span> *str2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = l; i &lt;= r; i++)</span><br><span class="line">        str1[i] = str2[i];</span><br><span class="line">&#125; <span class="comment">// 注意回溯时，一定不是简单的交换两个位置的数字，而是把这两个位置中的整段数组都进行回溯</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125; <span class="comment">// 自定义交换函数怎么写，还记得吗？</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">comb</span><span class="params">(<span class="type">int</span> *str, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            swap(&amp;(str[l]), &amp;(str[i]));</span><br><span class="line">            tape(l, r, a, str);</span><br><span class="line">            comb(str, l+<span class="number">1</span>, r);</span><br><span class="line">            tape(l, r, str, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, x, a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    comb(a, <span class="number">0</span>, x<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>法二：非递归法，从右往左找到第一对递增数，以该对数的第一个数为交换对象，再从右往左找第一个比该对象大的数，相交换，再把该位置后的数组反序。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">11</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_rev</span><span class="params">(<span class="type">int</span> s[], <span class="type">int</span> hi, <span class="type">int</span> low)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> ( ; hi &gt; low; low++, hi--) &#123;</span><br><span class="line">    temp = s[low];</span><br><span class="line">    s[low] = s[hi];</span><br><span class="line">    s[hi] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//该自定义函数可实现把数组反序，可以直接作为模版使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, temp, flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 从右往左找一对递增的数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果没找到，说明所有全排列的结果已经输出完毕</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (j = n; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[i]) &#123;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        str_rev(a, n, i + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="字符串替换（新）"><a href="#字符串替换（新）" class="headerlink" title="字符串替换（新）"></a>字符串替换（新）</h2><p>这道题的注意事项有：</p>
<p>1、关于文件的输入输出，文件名写对，<code>fgets()</code>函数的参数顺序写对；</p>
<p>2、不可以把输入文件里的所有字母都变成小写后再判断，因为不符合替换条件的字母需要原样输出；</p>
<p>3、如果要使用<code>strcat()</code>和<code>strcpy()</code>等函数完成此题，一定要判断好起始位置。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">502</span>] = &#123;<span class="number">0</span>&#125;, b[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, str[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, flag, len;</span><br><span class="line">    </span><br><span class="line">    FILE *in = fopen(<span class="string">&quot;filein.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE *out = fopen(<span class="string">&quot;fileout.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(in)) != EOF)</span><br><span class="line">        str[i++] = c;<span class="comment">// 将文件中所有字符统一存进数组</span></span><br><span class="line">    str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    len = (<span class="type">int</span>)<span class="built_in">strlen</span>(str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        flag = <span class="number">1</span>; <span class="comment">// “新的开始”，每次都让flag置为1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">tolower</span>(str[i]) != <span class="built_in">tolower</span>(a[<span class="number">0</span>])) </span><br><span class="line">            <span class="comment">// 判断大小写是否契合，直接借用此函数即可，若参数为大写字母，则其返回值为小写字母</span></span><br><span class="line">            fputc(str[i], out);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; a[j] != <span class="string">&#x27;\0&#x27;</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">tolower</span>(str[i+j]) != <span class="built_in">tolower</span>(a[j])) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="comment">// 一旦出现不匹配的位置，立即让flag为0并退出上一层循环（即for循环）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="built_in">fputs</span>(b, out);</span><br><span class="line">                i = i + (<span class="type">int</span>)<span class="built_in">strlen</span>(a) - <span class="number">1</span>; <span class="comment">// 减1是为了抵消下一次进循环的i++</span></span><br><span class="line">            &#125; <span class="comment">// 如果与in数组匹配，则直接把out数组输出到文件里</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fputc(str[i], out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="加密文件"><a href="#加密文件" class="headerlink" title="加密文件"></a>加密文件</h2><p>此题注意事项包括但不限于：</p>
<p>1、很多同学在判断字符是否出现过时，喜欢使用循环遍历的方法，这样做固然没问题，但在数据规模较大时比较耗费时间，特别是在大作业的时候，大家感触会更深。所以可以使用<code>used</code>数组（类似于哈希表思想）进行判断，在大作业的时候大家也可以感受到不同算法所带来的效率差别；</p>
<p>2、使用数组下标的时候要统一，不要一会儿是 97-122，一会儿是 0-25，一会儿是 ‘A’-‘Z’，这样会显得很混乱，容易出错；</p>
<p>3、大家有时喜欢卡着真实的元素个数去定义数组的大小，其实完全没必要，建议开大一些（至少开大个一倍左右吧），这样能有效避免数组越界。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, key[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;, str[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, pst = <span class="number">0</span>, ch, used[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    FILE *in, *out;</span><br><span class="line">    </span><br><span class="line">    in = fopen(<span class="string">&quot;encrypt.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    out = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[str[i] - <span class="string">&#x27;a&#x27;</span>]) &#123; <span class="comment">// 如果出现过，则不写入key数组中</span></span><br><span class="line">            key[pst++] = str[i];</span><br><span class="line">            used[str[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>; <span class="comment">// 如果该字母以出现过，则对应used数组位置赋为1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="string">&#x27;z&#x27;</span>; i &gt;= <span class="string">&#x27;a&#x27;</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[i - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            key[pst++] = i;</span><br><span class="line">    &#125; <span class="comment">// 倒序加入未出现过的字母形成最终密钥</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(in)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(ch))</span><br><span class="line">            ch = key[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        fputc(ch, out);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="小型图书管理系统"><a href="#小型图书管理系统" class="headerlink" title="小型图书管理系统"></a>小型图书管理系统</h2><p>本题一种简单暴力的做法是，每进行一次操作，都将所有图书重新排序。另有以下注意事项：</p>
<p>1、在维护图书信息时，利用变量<code>cnt</code>保存图书总数，并且只针对下标小于<code>cnt</code>的元素进行操作；</p>
<p>2、一些同学使用记事本查看输出结果时，发现输出的信息不能对齐，这是由于记事本中默认字体中的字符宽度是不相等的，可以切换记事本字体，例如<code>Consolas</code>；</p>
<p>3、有些同学在执行清除操作时，喜欢直接<code>memset</code>，但全是<code>&#39;\0&#39;</code>的字符串也会进入<code>qsort</code>排序中，且<code>&#39;\0&#39;</code>的字典序是最小的，因此永远会被排在前面，如果在输出时不加以判断，则会在文件最开始输出很多空内容。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">books</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">51</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">21</span>];</span><br><span class="line">    <span class="type">char</span> press[<span class="number">31</span>];</span><br><span class="line">    <span class="type">char</span> date[<span class="number">11</span>];</span><br><span class="line">&#125;book[<span class="number">501</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p, <span class="type">const</span> <span class="type">void</span> *q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(((<span class="keyword">struct</span> books*)p)-&gt;name, ((<span class="keyword">struct</span> books*)q)-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, i  =<span class="number">0</span>, op;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    FILE *in = fopen(<span class="string">&quot;books.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE *out = fopen(<span class="string">&quot;ordered.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(in, <span class="string">&quot;%s %s %s %s&quot;</span>, book[cnt].name, book[cnt].author, </span><br><span class="line">                 book[cnt].press, book[cnt].date) != EOF) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    qsort(book, cnt, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> books), cmp); <span class="comment">// 输入完就立即进行排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s %s %s %s&quot;</span>, book[cnt].name, book[cnt].author, </span><br><span class="line">                      book[cnt].press, book[cnt].date);</span><br><span class="line">                cnt++;</span><br><span class="line">                qsort(book, cnt, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> books), cmp);</span><br><span class="line">            <span class="comment">// 插入后进行排序，如果没有此步骤，则后续查找时，可能导致输出的图书顺序有误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, temp);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strstr</span>(book[i].name, temp) != <span class="literal">NULL</span>) <span class="comment">// 使用strstr函数直接进行查找</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%-50s%-20s%-30s%-10s\n&quot;</span>, book[i].name, </span><br><span class="line">                           book[i].author, book[i].press, book[i].date);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, temp);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strstr</span>(book[i].name, temp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; cnt - <span class="number">1</span>; j++)</span><br><span class="line">                        book[j] = book[j + <span class="number">1</span>]; <span class="comment">// 将后续图书全部前移，即可实现删除功能</span></span><br><span class="line">                    i--; <span class="comment">// 因为前移，需抵消下次进循环的i++影响</span></span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    qsort(book, cnt, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> books), cmp); <span class="comment">// 最后再排一次序，以防万一</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(out, <span class="string">&quot;%-50s%-20s%-30s%-10s\n&quot;</span>, book[i].name, </span><br><span class="line">                book[i].author, book[i].press, book[i].date); <span class="comment">// 对齐方式应该如此写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="面向对象的数据结构-——-数组篇"><a href="#面向对象的数据结构-——-数组篇" class="headerlink" title="面向对象的数据结构 —— 数组篇"></a>面向对象的数据结构 —— 数组篇</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><blockquote>
<p>同学们在解决实际问题时，往往会在<strong>问题理解</strong>和<strong>编程实现</strong>两方面遇到困难。我们以第三次作业第二题“空闲空间分配”为例。</p>
<p><strong>题意理解的问题形如</strong></p>
<ul>
<li>查找目标的规则是什么，我要如何判断</li>
<li>如果没找到，我要怎么标记</li>
<li>如果空间一点不剩，我需不需要特判</li>
</ul>
<p><strong>编程实现的问题形如</strong></p>
<ul>
<li>新的节点如何申请</li>
<li>删除节点怎么写，哪些指针要修改</li>
<li>什么是循环链表，怎么遍历</li>
</ul>
<p>事实上，这两大问题对应我们程序中的两大部分</p>
<ul>
<li>主函数<code>main</code>的结构，如各种循环和分支的嵌套，这是我们解决问题的逻辑</li>
<li>每个循环或分支内的具体语句，如一次赋值、一次拷贝、一次遍历等</li>
</ul>
<p>这两大部分，也就对应两类常见 bug</p>
<ul>
<li>漏了一种<code>if</code>的情况，忘记把<code>flag</code>重新置为 0 等<strong>逻辑问题</strong></li>
<li>访问了空指针，下标数错，忘加 ‘\0’ 等<strong>基本操作问题</strong></li>
</ul>
<p>事实上，如果把所有代码都写在<code>main</code>里，我们很难分清也很难定位具体的 bug。一种做法是<strong>封装一些函数</strong>，这种做法简化了代码，增强了代码的<strong>可复用性</strong>，但不妙之处在于，我们每做一道题，就要把这些内容重新写一遍，因为每道题用到的数据类型是不同的 —— <strong>这道题的<code>struct</code>里的数据项只有一个<code>int</code>，而下一道题变成了一个<code>double</code>和一个<code>char[20]</code>，我们就需要把所有的函数都修改一遍</strong>。</p>
<p>所以，单纯地封装<code>insert_node</code> <code>delete_node</code>等函数，仍然不是最理想的做法。</p>
</blockquote>
<h3 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h3><p>今天我们仅讨论线性表中的数组，为了便于说明，我们仅以<code>int</code>型的数组为例。事实上，只要稍加改进，我们就可以写出适配任何数据类型（包括结构体）的数组。</p>
<p>可是，数组有什么好写的呢？我们写下<code>int arr[10] = &#123;0&#125;;</code>，不就定义了一个数组吗？我们可以通过下标访问、也可以通过指针访问，我们可以读取内容、也可以赋值。然而，正是因为我们频繁地在代码中写下<code>printf(&quot;%d\n&quot;, arr[index]);</code>等<strong>直接操作数组</strong>的代码，我们才会犯下下标越界等导致程序崩溃的错误。<strong>如果我们在程序中加入很多条件判断，保证每一次操作的合法性，又会徒增代码量，和我们程序的运行逻辑相混淆。</strong></p>
<p>事实上，直接定义的数组只是一个存放数据的“变量”。<strong>如果将存放数据的数据结构，其相关属性，以及在数据结构上的操作封装，我们就得到了一个对象。</strong>以今天介绍的数组为例，一个<strong>“数组对象”</strong>应当包括如下三个方面</p>
<ul>
<li><strong>存储数据的数据结构</strong>，即数组本身（为了实现<strong>可变长数组</strong>，我们用一个指针管理数组并用<code>malloc</code>分配空间，而非直接写一个定长数组）</li>
<li><strong>属性</strong>，如当前数组的最大容量、当前数组的元素个数</li>
<li><strong>一系列函数</strong>，提供初始化、插入、销毁的功能</li>
</ul>
<p>为了实现上述目标，我们首先定义自己的<strong>数组类型</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_SIZE 10</span></span><br><span class="line">	<span class="comment">// 这里定义了一个宏，设置数组的初始容量。</span></span><br><span class="line">	<span class="comment">// 后续初始化数组时，如果没有指定容量，则先开辟 10 个 int 的大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">array</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *head;		<span class="comment">// 数组首地址</span></span><br><span class="line">    <span class="type">size_t</span> size;	<span class="comment">// 数组的最大容量</span></span><br><span class="line">    <span class="type">size_t</span> cur;		<span class="comment">// current，当前数组的元素个数</span></span><br><span class="line">&#125; <span class="type">array_t</span>;			</span><br><span class="line">    <span class="comment">// ‘_t’结尾是 C 的经典代码风格，表示这是 typedef 的一种新类型，即我们的“数组类型”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以后当我们写下</span></span><br><span class="line"><span class="type">array_t</span> arr1, arr2;</span><br><span class="line"><span class="comment">// 等代码时，就可以说，我们现在拥有了两个数组对象，分别叫 arr1 和 arr2</span></span><br></pre></td></tr></table></figure></div>

<p>现在，我们有了自己的数组类型，也可以定义自己的<strong>数组对象</strong>。当然，<code>arr1[1]</code>等原有的操作将不被允许了，所有的操作都将通过函数进行。在每一个函数中，我们只需要将数组对象 —— 实际上是这个对象的地址 —— 传入函数，就可以对某一个具体的数组对象进行操作。</p>
<h3 id="初始化与销毁"><a href="#初始化与销毁" class="headerlink" title="初始化与销毁"></a>初始化与销毁</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">array_t</span> arr;            <span class="comment">// 定义了一个数组对象</span></span><br><span class="line">    array_init(&amp;arr, <span class="number">100</span>);  <span class="comment">// 初始化数组对象，开辟 100 个 int 的容量</span></span><br><span class="line">    array_destroy(&amp;arr);    <span class="comment">// 销毁数组对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了实现这样简洁的代码，我们需要自己设计一系列函数</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_init</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化数组</span></span><br><span class="line"><span class="comment">    	参数</span></span><br><span class="line"><span class="comment">       		`arr`  array_t 的指针，即 struct array 的指针，代表数组对象</span></span><br><span class="line"><span class="comment">       		`size` 数组的起始容量，如果小于等于 0，则默认开辟 INIT_SIZE 个</span></span><br><span class="line"><span class="comment">       	返回值</span></span><br><span class="line"><span class="comment">       		如果初始化成功返回 0，否则返回 -1</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果没有传入数组对象，则失败</span></span><br><span class="line">    <span class="type">int</span> real_size = (size &gt; <span class="number">0</span>) ? size : INIT_SIZE; </span><br><span class="line">                                 <span class="comment">// 如果参数 size 非正，则使用预先定义的 size</span></span><br><span class="line">    <span class="keyword">if</span> ((arr-&gt;head = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * real_size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果 malloc 失败，则函数直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr-&gt;size = real_size; <span class="comment">// 更新数组的最大容量</span></span><br><span class="line">        arr-&gt;cur = <span class="number">0</span>;          <span class="comment">// 设置当前元素个数为 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 成功则返回 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_destroy</span><span class="params">(<span class="type">array_t</span> *arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 销毁数组</span></span><br><span class="line"><span class="comment">       参数</span></span><br><span class="line"><span class="comment">       		`arr`  array_t 的指针，代表要销毁的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(arr-&gt;head);  <span class="comment">// 释放数组的数据区</span></span><br><span class="line">    arr-&gt;head = <span class="literal">NULL</span>; <span class="comment">// 将数组头指针改为空值</span></span><br><span class="line">    arr-&gt;size = <span class="number">0</span>;    <span class="comment">// 将数组最大容量改为 0</span></span><br><span class="line">    arr-&gt;cur = <span class="number">-1</span>;    <span class="comment">// 将数组元素个数改为无效值 -1</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="数组的生长"><a href="#数组的生长" class="headerlink" title="数组的生长"></a>数组的生长</h3><p><strong>传统的数组大小是固定的</strong>，如果访问越界（有可能是下标过大，<strong>也有可能是下标为负数</strong>）将产生得到随机值、程序崩溃等问题。这里，我们的数组并非直接定义，而是通过<code>malloc</code>动态申请，这就为其生长提供了可能。我们规定，<strong>每当数组生长的时候，容量增加原来的一倍</strong>。当然，<strong>我们不应在程序中直接调用此函数，而是让“插入元素”等函数自动调用</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_grow</span><span class="params">(<span class="type">array_t</span> *arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 将数组容量扩大一倍</span></span><br><span class="line"><span class="comment">       参数</span></span><br><span class="line"><span class="comment">       		`arr`  array_t 的指针，代表要扩大的数组</span></span><br><span class="line"><span class="comment">       返回值</span></span><br><span class="line"><span class="comment">       		成功返回 0，失败返回 -1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> old_size = arr-&gt;size;     <span class="comment">// 生长前的容量</span></span><br><span class="line">    <span class="type">int</span> new_size = old_size * <span class="number">2</span>;  <span class="comment">// 生长后的容量</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;                <span class="comment">// 管理新分配的空间的指针</span></span><br><span class="line">    <span class="keyword">if</span> ((p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * new_size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 申请更大的空间，如果失败则直接返回</span></span><br><span class="line">                   <span class="comment">// 当然哪怕这种情况发生，原有数组中的内容仍然保存</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; old_size; i++) &#123; <span class="comment">// 循环复制原数组内容</span></span><br><span class="line">            p[i] = arr-&gt;head[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(arr-&gt;head);       <span class="comment">// 释放原数组的数据区</span></span><br><span class="line">        arr-&gt;head = p;         <span class="comment">// 更新数组首地址</span></span><br><span class="line">        arr-&gt;size = new_size;  <span class="comment">// 更新数组最大容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="元素的插入"><a href="#元素的插入" class="headerlink" title="元素的插入"></a>元素的插入</h3><p>数组的插入可以分成两类 —— <strong>尾部插入</strong>和<strong>中间插入</strong>。前者只需要传入新的元素，后者还需要获取插入的下标。这里我们仅实现前者。插入新元素，则有可能会出现越界的情况，所以<strong>这个函数需要自行判断会不会越界</strong>，如果会，则需要<strong>主动调用数组生长函数扩大空间</strong>。我们通过一张图更直观地了解数组的容量<code>size</code>和元素数量<code>cur</code>的关系。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/截屏2023-03-21 15.29.44.png"
                      alt="截屏2023-03-21 15.29.44" style="zoom:30%;" 
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_push</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 在数组 `arr` 尾部插入元素 `val` </span></span><br><span class="line"><span class="comment">       成功返回 0，出错返回 -1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr-&gt;cur == arr-&gt;size) &#123;      <span class="comment">// 这种情况表示数组已满，需要 grow</span></span><br><span class="line">        <span class="keyword">if</span> (array_grow(arr) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果 grow 失败则直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr-&gt;head[arr-&gt;cur] = val; <span class="comment">// 在尾部插入元素</span></span><br><span class="line">    arr-&gt;cur++;                <span class="comment">// 更新元素个数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>上述若干函数为我们实现了一些针对数组对象的基本操作，当然这还远远不够。你可能需要自己书写其他函数，例如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">array_isempty</span><span class="params">(<span class="type">array_t</span> *arr)</span>;</span><br><span class="line">    <span class="comment">// 判断数组 `arr` 是否为空。空返回 1，非空返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_get</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> index)</span>;</span><br><span class="line">    <span class="comment">// 获取数组 `arr` 中下标为 `index` 的元素值并返回</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_index_of</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="comment">// 获取数组 `arr` 中值为 `val` 的元素下标并返回，如果未查找到返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_insert</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> index, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="comment">// 在数组 `arr` 下标为 `index` 的位置插入元素 `val`。成功返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_set</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> index, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="comment">// 将数组 `arr` 中下标为 `index` 的元素设置成 `val`。成功返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_remove_index</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> index)</span>;</span><br><span class="line">    <span class="comment">// 将数组 `arr` 中下标为 `index` 的元素删除。成功返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_remove_val</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="comment">// 将数组 `arr` 中值为 `val` 的元素删除。成功返回 0，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">array_size</span><span class="params">(<span class="type">array_t</span> *arr)</span>;</span><br><span class="line">    <span class="comment">// 获取数组 `arr` 的元素个数并返回，出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">array_sizeof</span><span class="params">(<span class="type">array_t</span> *arr)</span>;</span><br><span class="line">    <span class="comment">// 获取数组 `arr` 中数据部分的总字节数，功能类似传统的 sizeof(数组名)。出错返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">array_to_array</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> *ret)</span>;</span><br><span class="line">    <span class="comment">// 将数组对象 `arr` 转换成基本数组，存于 `ret` 中并返回。出错返回 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">array_subarray</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> *ret)</span>;</span><br><span class="line">    <span class="comment">// 将数组对象 `arr` 中下标为 [from, to) 的子序列转换成基本数组，</span></span><br><span class="line">    <span class="comment">// 存于 `ret` 中并返回。出错返回 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array_sort</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> mode)</span>;</span><br><span class="line">    <span class="comment">// 将数组 `arr` 排序，规则由 `mode` 指定(如 0 为升序，1 为降序)。成功返回 0，出错返回 -1</span></span><br></pre></td></tr></table></figure></div>

<p>这些函数看起来较为麻烦，但是一经实现，你就有了独属于自己的一套模板。未来，你可以将它们扩充为适配任何类型的数组，甚至把它们<strong>做成一个头文件</strong>，每次使用时，只需要<code>#include &lt;myarray.h&gt;</code>，<strong>多是一件美事啊</strong>。实现了这些函数之后，<strong>你的代码里将不再出现大量的中括号、赋值和下标</strong>，取而代之的是 set、get、remove 等函数的调用，<strong>每一次完成一个操作，呈现在代码中的都不再是晦涩的运算符，而是具有自然语言含义的函数名</strong>，那你的代码的可读性也就增加了。</p>
<p><strong>如果同学们实现了这 12 个函数中的 8 个及以上，可以来找助教兑换小奖品。</strong></p>
<p>另外，这次封装的数组对象，也启发我们思考两个问题</p>
<ul>
<li><strong>如何封装一个链表</strong></li>
<li><strong>如何实现从<code>int</code>到任意数据类型的扩充</strong></li>
</ul>
<p>我们会在后续猪脚说中迭代地更新这部分内容。</p>
<h2 id="为什么数组比链表快"><a href="#为什么数组比链表快" class="headerlink" title="为什么数组比链表快"></a>为什么数组比链表快</h2><blockquote>
<p>已经了解过第三次作业第五题“词频统计”的同学，可以尝试用数组和链表分别实现一下。假设我们用数组实现时不用二分查找，而仍使用较低效的顺序查找，我们仍可从 judge 平台上反馈的运行时间看出，数组比链表快。这是为什么呢？</p>
<p>理论上，数组的查找时间复杂度为 $O(n)$，插入的时间复杂度也为 $O(n)$；链表的查找的时间复杂度为 $O(n)$，插入的时间复杂度为 $O(1)$。为什么数组在实践中更加高效呢？这还要从一个故事说起……</p>
</blockquote>
<h3 id="小z决战高考的故事"><a href="#小z决战高考的故事" class="headerlink" title="小z决战高考的故事"></a>小z决战高考的故事</h3><p>高中生小z打算奋战百天，决胜高考，誓死考上 BUAA。这天我们来到他的教室，看到如下场景</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/IMG_0936.JPG"
                      alt="IMG_0936" style="zoom:8%;" 
                >

<p>如图，小z的课桌上摆放了一个<strong>书立</strong>，他的课桌有一个<strong>抽屉</strong>，他的座位旁边放了一个<strong>书箱</strong>，在教室的后面还有一个<strong>储物柜</strong>。我们不难想象他会在这些地方各自存放什么东西，比如</p>
<ul>
<li>书立里放着刚考完的月考卷和今晚要做的作业；</li>
<li>抽屉里放着各科的复习书和辅导材料；</li>
<li>书箱里存放各科的课本，以备必要时参考；</li>
<li>储物柜里放着几个月前做过的卷子<del>和《故事会》</del>。</li>
</ul>
<p>按照上面的顺序，我们发现以下规律：<strong>储物量 —— 从小到大</strong>、<strong>存取物品的速度 —— 从快到慢</strong>（比如书立中的材料只需要直接抽出来、插回去，而储物柜中材料的存取还需要起身走动）、<strong>存放的内容 —— 从重要到不重要、访问频率递减</strong>。</p>
<p>很显然，这种安排符合逻辑：<strong>很快就会用到的东西就就放在手边，相对无关紧要的东西存放在别的地方</strong>。这给了我们什么启示呢？</p>
<h3 id="计算机的存储层次"><a href="#计算机的存储层次" class="headerlink" title="计算机的存储层次"></a>计算机的存储层次</h3><p><strong>计算机的存储系统从高到低大致可以分为四层：寄存器，高速缓存，内存和外存。</strong></p>
<ul>
<li><strong>外存就是硬盘等设备</strong>，如同学们常听到的“512G 的硬盘”“256G 的 iPhone”等，这些指的就是硬盘容量，U 盘等设备属于可移动的硬盘。</li>
<li>文件（包括程序）一般都存放在外存中，当它们要开始运行时，就要先<strong>加载到内存</strong>；另外，我们已经知道，<strong>程序中定义的变量、数组等也都存放在内存中</strong>。</li>
<li>寄存器位于 CPU（中央处理器） 中，<strong>存放在内存中的数据要进行运算，必须先放进寄存器</strong>。例如，我们写<code>int a = 1, b = 2; int c = 0; c = a + b;</code>，则内存中会先有<code>a</code> <code>b</code> <code>c</code>三个变量，进行第三步的运算时，先把<code>a</code>和<code>b</code>放进两个寄存器中，在 CPU 完成计算后，结果 3 被放进另一个寄存器，最后将其中的内容存放回内存中c的位置。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/截屏2023-03-23 14.48.45.png"
                      alt="截屏2023-03-23 14.48.45" style="zoom:20%;" 
                >

<p>当然，<strong>不同层级的存储设备其容量、速度和成本都是不同的</strong>。寄存器速度最快，但是容量很小（只能存放一个数）且成本高昂；内存容量比较大，但是读取和写入的速度都很慢。<strong>为了缓解 CPU 的高速和内存的低速的矛盾，人们发明了高速缓存技术。</strong></p>
<blockquote>
<p><strong>局部性原理</strong></p>
<p>局部性原理可以分为<strong>时间局部性原理</strong>和<strong>空间局部性原理</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) arr[i] = i;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>时间局部性原理：刚访问过的存储单元，不久后很可能会再次访问。</strong>例如上例中的循环变量<code>i</code>，在每一次循环中都会被访问若干次。</li>
<li><strong>空间局部性原理：刚访问过的存储单元附近的单元，不久后更可能被访问。</strong>例如上例中，我们访问了<code>arr[0]</code>，不久后就会访问其附近的<code>arr[1]</code> <code>arr[2]</code>等存储单元。</li>
</ul>
</blockquote>
<p><strong>高速缓存是一类存储设备，它们的存取速度远高于内存，但是容量比较小。</strong>根据局部性原理，把内存切割成很多<strong>块</strong>，把<strong>最近用到的</strong>一些块放进高速缓存中，每次需要访问内存时，<strong>优先到高速缓存中查找</strong>，如果找到，就可以不用访问内存，而是直接对高速缓存中的数据进行操作。如此一来，我们就可以<strong>减少直接访问内存的次数</strong>，从而<strong>提高了程序运行的效率</strong>。</p>
<p>正如同小z的例子，他会把更常用到的材料放在离手边更近的地方，从而提高寻找的效率。<strong>当然，手边的空间是有限的，他不能保证所有用到的材料都在手边；当他在手边没有找到想要的材料时，他还是得费点力气去储物柜里寻找。</strong></p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>正如前文所述，<strong>内存中的一些块会被拷贝进高速缓存中，以加快访问数据的速度</strong>。</p>
<p><strong>数组在内存中是连续存放的</strong>，因此，它们<strong>更有可能</strong>被连续地放进高速缓存中，从而在访问数据时，能够直接在高速缓存中找到，避免了查找低速的内存。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/截屏2023-03-23 15.24.35.png"
                      alt="截屏2023-03-23 15.24.35" style="zoom:35%;" 
                >

<p>链表的每一个节点都是<code>malloc</code>来的，这类动态申请的空间，<strong>离散地分布在内存中</strong>。在遍历链表的过程中，哪s怕某个节点在高速缓存中，也不能保证后续节点在高速缓存中，因此<strong>访问内存的次数大大增加</strong>，程序运行的时间增加。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets5/截屏2023-03-23 15.29.10.png"
                      alt="截屏2023-03-23 15.29.10" style="zoom:35%;" 
                >

<blockquote>
<p><strong>了解计算机存储相关原理并非多余或超纲。</strong>一方面，几乎所有信息类专业都要求掌握计算机组成原理 &#x2F; 计算机硬件基础 &#x2F; 计算机体系结构等科目；另一方面，多年来数据结构的大作业都是基于<strong>词频统计</strong>的，并且会根据程序运行时间进行排名，提前了解连续存储和链式存储的特点，对同学们选择解题方法有很大帮助。</p>
</blockquote>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>answers</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第四期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%9B%9B%E6%9C%9F/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/IMG_0892.jpg"
                      alt="IMG_0892" style="zoom:40%;" 
                >

<h2 id="容易忽视的-bug"><a href="#容易忽视的-bug" class="headerlink" title="容易忽视的 bug"></a>容易忽视的 bug</h2><h3 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span>* wordlist[LEN];</span><br><span class="line">  <span class="type">char</span> temp[MAXSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, temp)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(temp, wordlist[i])) &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, flag ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上代码想要实现这样的功能：每当输入一个单词时，在现有单词表<code>wordlist</code>里查找其是否已存在。若查找成功，则输出<code>YES</code>，否则输出<code>No</code>。</p>
<p>细心的同学很快能发现问题：这段代码只是让<code>flag</code>初始值为 0，只要有一次查找成功之后，<code>flag</code>的值会一直 1，不会改变。因此在此之后，无论输入什么样的单词，都会输出<code>YES</code>！</p>
<p>一种正确改法是，<strong>让<code>flag</code>获得“新的开始”。即每次进入<code>while</code>循环后，进入<code>for</code>循环之前，都执行一步<code>flag = 0;</code>，</strong>让其在每一次查找的初值都为 0，便成功 de 出了 bug。</p>
<h3 id="scanf函数返回值"><a href="#scanf函数返回值" class="headerlink" title="scanf函数返回值"></a><code>scanf</code>函数返回值</h3><p>在与同学们的交流中，我们发现同学们对于<code>scanf</code>函数的返回值不太清楚，下面举一个例子</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input: %d\n&quot;</span>, <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb=%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们直接给出程序的输入和输出结果：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">  3 4</span><br><span class="line"><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">output</span>&gt;</span></span><br><span class="line">  input: 2</span><br><span class="line">  a = 3</span><br><span class="line">  b = 4</span><br><span class="line"><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>我们再多给出一些输入输出样例：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">  3 hello</span><br><span class="line"><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">output</span>&gt;</span></span><br><span class="line">  input: 1</span><br><span class="line">  a = 3</span><br><span class="line">  b = 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>通过上述例子我们发现：</p>
<ul>
<li><p><code>scanf</code>函数的返回值<strong>并不是输入的数据，而是其具体输入的有效数据的个数</strong>（这个太容易忽略了！）；</p>
</li>
<li><p>若<code>scanf</code>函数中输入了非法的值（如第二个样例），则不会改变那一个数据的原始值，且返回值（输入的有效数据个数）不会算上此次非法输入。</p>
</li>
</ul>
<p>因此，当遇到第二次作业第五道编程题（小型图书管理系统）时，不能采取如下做法：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op)) != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为，无论你输入的是操作 1、2、3还是0，<code>scanf</code>函数的返回值都为 1。所以我们推荐如下写法：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op) != EOF) &#123;</span><br><span class="line">  <span class="keyword">if</span> (op == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="一些字符判断函数的返回值"><a href="#一些字符判断函数的返回值" class="headerlink" title="一些字符判断函数的返回值"></a>一些字符判断函数的返回值</h3><p>很多同学喜欢使用<strong>声明</strong>（啥是声明啥是定义？还记得吗？）在<code>&lt;ctype.h&gt;</code>中的库函数，例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isupper</span><span class="params">(<span class="type">char</span> c)</span>;  <span class="comment">// 判断一个字符c是否为大写字母</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isdigit</span><span class="params">(<span class="type">char</span> c)</span>;  <span class="comment">// 判断一个字符c是否为十进制数字字符0～9</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isalpha</span><span class="params">(<span class="type">char</span> c)</span>;  <span class="comment">// 判断一个字符c是否为字母</span></span><br><span class="line"><span class="comment">//类似的函数还有很多……</span></span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，在大多数编译环境中，这些函数的返回值类似于<code>strcmp</code>函数，只有<strong>零和非零值</strong>（不确定）两种情况，所以形如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(a,b) == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样的写法是有巨大隐患的。</p>
<p>事实上，**<code>if</code>语句条件不成立当且仅当括号中的表达式值为<code>0</code>或<code>&#39;\0&#39;</code>或<code>NULL</code>，所以，任何其他非零值都会进入<code>if</code>分支。<strong>以<code>&lt;ctype.h&gt;</code>库函数为代表的 C 库调用，</strong>标准写法**是</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上述代码会在我们脑海中直观地翻译为<strong>“如果是数字，怎么怎么样；否则怎么怎么样”</strong>，这种写法不是<strong>更贴近自然语言的语义</strong>吗？这一个小小的细节，足以充分体现<strong>【函数命名规范】和【代码书写规范】的重要性</strong>。</p>
<h2 id="数据结构引入"><a href="#数据结构引入" class="headerlink" title="数据结构引入"></a>数据结构引入</h2><p>过去几周我们复习了诸多知识点，也学习了若干新内容，这是为后续课程做铺垫。<strong>再次简要列举必会知识点，请自行查缺补漏，后续如果出现下列基本知识的迷惑，我们的回复将包括但不限于「自己百度一下」「自己 <a href="csdn.net">csdn</a>一下」「看猪脚说」「看程设课件」等。</strong></p>
<ul>
<li>基本的递归函数的使用<ul>
<li>全排列等题目确实较难，但求解斐波那契数列你得会</li>
</ul>
</li>
<li>一维数组<ul>
<li><strong>初始化</strong></li>
<li>数组名的含义</li>
<li>数组作为函数参数</li>
</ul>
</li>
<li>字符串<ul>
<li>字符数组和字符串常量的区别</li>
<li>字符串读取，<code>scanf</code>和<code>gets</code>和<code>fgets</code>等的区别<strong>（以后再出现逐个字符构造字符串忘加<code>&#39;\0&#39;</code>的问题统一回复自己 de）</strong></li>
<li>字符数组初始化</li>
<li>字符串处理函数<code>strstr</code> <code>strcmp</code> <code>strcpy</code> <code>strncpy</code> <code>strcat</code> <code>strncat</code> <code>strlen</code> <code>strchr</code>等的功能、参数类型与顺序、返回值类型与含义</li>
<li><code>char</code>与<code>int</code>的联系和区别</li>
</ul>
</li>
<li>文件操作<ul>
<li>打开文件</li>
<li>关闭文件</li>
<li>读文件：单个字符 &#x2F; 一行 &#x2F; 按指定数据类型</li>
<li>写文件：单个字符 &#x2F; 一行 &#x2F; 按指定数据类型</li>
</ul>
</li>
<li><code>&lt;ctype.h&gt;</code><ul>
<li>判断是否为字母</li>
<li>判断是否为大写</li>
<li>判断是否为小写</li>
<li>判断是否为数字</li>
<li>判断是否为数字或字母（<code>isalnum</code>）</li>
<li>判断是否为空白字符（<code>iswhite</code>）</li>
<li>判断是否为标点符号（<code>ispunct</code>）</li>
<li>转成大写</li>
<li>转成小写</li>
</ul>
</li>
<li>二维数组<ul>
<li>定义与初始化</li>
<li><strong>作为函数参数</strong></li>
<li>遍历方式</li>
<li>指向行的指针（数组指针）</li>
<li>指向列的指针（基本类型指针）</li>
</ul>
</li>
<li><strong>指针</strong><ul>
<li>指针的定义与初始化，什么是<code>NULL</code></li>
<li>不同类型的指针的区别和联系</li>
<li>取地址（什么是地址），解引用</li>
<li>字符指针和字符数组的区别和联系</li>
<li>什么是<code>void*</code></li>
<li>指针的<code>++</code> <code>--</code>和加减运算</li>
<li>给指针赋值的含义</li>
<li>数组名和指针的区别与联系</li>
<li>函数参数的值传递</li>
<li>指针数组，管理字符串常量的指针数组</li>
<li>数组指针和函数指针（不要求熟练掌握）</li>
<li><code>main</code>函数的命令行参数</li>
</ul>
</li>
<li><strong>结构体</strong><ul>
<li>结构体的声明</li>
<li>结构体变量或数组的定义与初始化</li>
<li>结构体成员的访问</li>
<li>结构体的赋值</li>
<li>指向结构体的指针及通过指针访问成员</li>
<li>类型别名的声明及其与<code>#define</code>的区别和优劣</li>
<li>自引用结构的概念（后续继续深入学习）</li>
</ul>
</li>
<li><code>qsort</code>函数<strong>（以后不要用冒泡了！）</strong><ul>
<li>包含在哪个头文件？</li>
<li>有几个参数？顺序？含义？</li>
<li><code>cmp</code>函数怎么编写？<ul>
<li>基本类型数组的升序 &#x2F; 降序（<code>double</code>类型的比较要注意什么？）</li>
<li>二维字符数组字典序</li>
<li>二维基本类型数组多关键字</li>
<li>结构体数组单关键字 &#x2F; 多关键字</li>
</ul>
</li>
</ul>
</li>
<li><code>sizeof</code>的使用，当参数为<ul>
<li>类型名的时候</li>
<li>变量名的时候</li>
<li>指针变量名的时候</li>
<li>数组名的时候</li>
</ul>
</li>
</ul>
<blockquote>
<p>接下来我们将要学习的是数据结构正文部分，作为数据结构，理应与工具的使用（C 语言语法、IDE 的配置等）脱钩，而专注于理论知识和编程实现本身。所以希望同学们尽早排除干扰项，这样，课程本身的学习也会更加轻松。</p>
</blockquote>
<h3 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h3><p>我们不谈文邹邹的东西，<del>虽然选择题可能会考</del>。如果诸位手上有《离散数学（第三版）》，不妨翻到后面“图”和“树”的章节，看看书中是怎么定义的，<del>虽然这些内容离散 1 不教</del>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 17.42.41.png"
                      alt="截屏2023-03-17 17.42.41" style="zoom:33%;" 
                >

<hr>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 17.43.04.png"
                      alt="截屏2023-03-17 17.43.04" style="zoom:33%;" 
                >

<hr>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 17.43.32.png"
                      alt="截屏2023-03-17 17.43.32" style="zoom:33%;" 
                >

<hr>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 17.43.44.png"
                      alt="截屏2023-03-17 17.43.44" style="zoom:33%;" 
                >

<hr>
<p>我们注意到，未来我们将学习的一系列数据结构，都是通过<strong>自然语言和数学符号</strong>定义的，这和 C 语言有什么关系呢？首先，想必大家已经大致了解了“链表长啥样”“树长啥样”“图长啥样”，在此基础上，我们可以说，各个类型的数据结构，只是一种<strong>逻辑上的定义</strong>，是人们<strong>在纸面上画出来的东西</strong>、是通过数学方式总结的东西。这里，我们用“东西”当作宾语，似乎显得有点抽象了。且听我们逐细言来。</p>
<h3 id="硬件与物理"><a href="#硬件与物理" class="headerlink" title="硬件与物理"></a>硬件与物理</h3><p><strong>计算机不是魔法，是由硬件组成的</strong>，比如电线、二极管、塑料等。所以大家应该意识到，你的每一次操作（点击鼠标、摁下键盘、开启网页、执行int a &#x3D; 0;），归根结底，是某些电流的流动、某些开关的开闭、高低电压的转换，甚至可以细化到电子在你看不到的地方跃迁……</p>
<p>不管怎么说，作为一个纯物理的系统，计算机需要极其复杂的设计。这种设计给我们两点启发：其一，有赖于高性能的硬件，计算机可以用于快速处理海量的数据，效率远高于人；其二，给定一台计算机，其体系结构已经定死，其能够支持的功能必然有限。<strong>事实上，这个问题的妙处就在于：我们手里只有有限的资源，但我们利用想象力，可以解决一切问题。</strong></p>
<p><strong>计算机为我们提供了内存、硬盘（磁盘）等物理设备存放数据。</strong>当程序中定义了一个接一个的变量，它们大概率<strong>会被放在一起</strong>；当程序中定义了一个数组，<strong>内存提供一片连续的空间存放</strong>；另外，我们有<strong>指针</strong>这种工具，可以<strong>间接地引用某一片内存空间</strong>。前两者对应<strong>连续存储方式</strong>，这不难理解；而后者为我们提供了一种新的思路</p>
<ul>
<li>对于每一项数据，我们为其增加一个成员 —— <strong>用于记录地址的成员</strong> —— 将其打包成一个<strong>数据包</strong>。</li>
<li>每次新增了数据需要存放，我们<strong>在内存中申请一片空间</strong>用于存储。</li>
<li>新增的数据包的地址，会被<strong>先前已经存在</strong>的数据包中的那个记录地址的成员记录下来，以便<strong>通过已经存在的数据包，访问到新的数据包</strong>。</li>
</ul>
<p>当然对应到 C 语言中，新增的那个成员就是指针，打包过程即声明<code>struct</code>，申请空间通过<code>malloc</code>，后续操作涉及指针的赋值等。于是，不同于连续存储，一种<strong>链式存储</strong>的方式诞生了。我们只需要记录下某一些节点的位置，<strong>通过其中的指针成员不断向后访问</strong>，即可以找遍所有节点。由于指针想指谁就可以指谁，因此这些节点之间的结构可能有以下几种</p>
<ul>
<li>第一个节点指向第二个，第二个节点指向第三个，……。这种链式结构，即为<strong>链表</strong>。</li>
<li>从一个根出发，不断向后分叉。这种分叉结构，即为<strong>树</strong>。</li>
<li>乱指来指去。这种乱七八糟结构，即为<strong>图</strong>。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets4/截屏2023-03-17 21.21.16.png"
                      alt="截屏2023-03-17 21.21.16" style="zoom:40%;" 
                >

<h3 id="So-What？"><a href="#So-What？" class="headerlink" title="So What？"></a>So What？</h3><p>上一小节我们从物理硬件的支持和编程语言提供的手段，描述了一种新的存储方式。我们可以进行如下思考</p>
<ul>
<li>比起刚才提及的链式存储，<strong>数组这种连续存储方式似乎更加浅显易懂</strong>；而<strong>链式存储似乎更加灵活</strong>，因为我们可以自由地排放数据的先后顺序（前提是指针不出错）。</li>
<li>某些情况下，这<strong>两种存储方式可以相互转换</strong>。例如，链表的一个接一个的存储方式，和数组也很像 —— 反之同理 —— 区别在于<strong>数组的每一个元素在内存中真的连续存放，而链表的元素离散地存放，我们只能通过指针一个接一个地访问。</strong>再比如，图的这种一个节点可以随意和其他节点连在一起的模式，似乎用数组也能做到 —— <strong>给每个点编号，然后把相邻的节点的编号都存入一个数组里</strong>。</li>
<li><strong>这些不同的结构，可以用于实际问题中的仿真。</strong>数组 &#x2F; 链表的结构像是在<strong>排队</strong>，能不能用来模拟生活中进进出出的排队问题（如航班的离港序列、银行排队与服务）呢？图能够仿真生活中管道的铺设、道路的布局等，能不能用来<strong>求最短的路径、最少的工程用料</strong>？我们发现，<strong>不同的结构都具备了描述现实世界的强大潜能</strong>。</li>
<li>上述的各种结构与计算机的运行原理密不可分。试想，同为<strong>线性结构</strong>的数组和链表，想在中间插入一个新数据，前者需要把该位置之后的所有元素，<strong>都往后挪一个位置</strong>，然后把新元素插进去；而对于后者，需要为新数据申请一片空间，然后修改一些指针的值，<strong>使得一些指向关系发生变化，从而在逻辑意义上实现了“插入”</strong>。<ul>
<li>数组插入写起来比较容易，但是需要计算机搬运很多个元素，<strong>看起来有点浪费时间</strong>。</li>
<li>链表插入有点抽象，但是实际上只需要修个几个指针的值，快速便捷；但是如果要查找一个数据，我们必须从链表的头开始，<strong>一个接一个地往后通过指针访问每个节点</strong>，这种操作好像也很麻烦。另外，<strong>对于链表，我们也就不能用<code>qsort</code>等进行排序了。</strong></li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前两节我们说了两件事：其一，计算机作为工具，<strong>为我们提供了</strong>存放数据的不同方式、不同结构、不同逻辑；其二，这些不同的方式似乎<strong>各有特点，各有优劣</strong>。以上所讨论的，都是数据结构相关的内容，所以我们在最早的时候，将数据结构描述为一样“东西”，确有其道理。所以，数据结构可以理解成以下几部分内容</p>
<ul>
<li>海量的、相互之间有关联的数据，在计算机中应<strong>如何组织</strong>（线性的排排队还是分叉结构还是其他）</li>
<li>确立了组织方式，<strong>基本的数据操作</strong>（插入、删除、查找、排序）应该如何编程，有无更加高效的写法</li>
<li>作为描述现实世界的工具，能否利用数据结构<strong>模拟实际问题</strong>（管道铺设、最短路径）</li>
<li>数据结构本身也是数学研究的对象，能否基于数学原理、利用编程工具，<strong>解决一些数学问题</strong>（利用树实现表达式的计算？有点玄乎。。。）</li>
</ul>
<p>由于本周没有太多新知识，因此写了这样一篇文字作为接下来学习的 introduction。<strong>如果你能看到这里，那么也祝愿你在数据结构的学习中取得收获与进步～</strong></p>
<h2 id="第三次作业补充练习"><a href="#第三次作业补充练习" class="headerlink" title="第三次作业补充练习"></a>第三次作业补充练习</h2><p>1、<a class="link"   href="http://akoj.online/problem/103" >干员整理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这是适合现阶段练习结构体用法的一道非常综合的题目，由北航 AK 宝典制作小组提供，初次登录网站需要注册，建议账号为自己的学号。</p>
<p>2、<a class="link"   href="http://akoj.online/problem/16" >字符串之海 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这道题可以作为第三次作业第五题（词频统计）的补充练习，很适合大家熟悉链表的使用。</p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第六期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%85%AD%E6%9C%9F/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/IMG_67F8A8A691D4-1.jpeg"
                      alt="IMG_67F8A8A691D4-1" style="zoom:25%;" 
                >

<h2 id="容易忽视的-bug"><a href="#容易忽视的-bug" class="headerlink" title="容易忽视的 bug"></a>容易忽视的 bug</h2><h3 id="判断空指针与访问空指针"><a href="#判断空指针与访问空指针" class="headerlink" title="判断空指针与访问空指针"></a>判断空指针与访问空指针</h3><p>在给大家 debug 的时候，我们发现了一个普遍存在、且大多数同学喜欢写但是其实是错误的写法，并且这个写法往往导致了程序报<code>SIGSEGV</code>或运行时间过长的错误，请看如下代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span></span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// in main:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span> =</span> <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;x != <span class="number">0</span> &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么这段代码是如何访问到空指针的呢？这其中的关键就在<code>while</code>的判断里。</p>
<p>如果在某次循环后，<code>p</code>已经是空指针，逻辑上来说，<code>while</code>条件逻辑值为假，不会再进入循环。但程序执行时，两个条件都要进行判断，<strong>所以当<code>p</code>为空指针时，依然需要首先执行<code>p-&gt;x != 0</code>的判断，才能进一步判断是否进入循环</strong>，由此，程序便访问到了空指针。</p>
<p>改进方法很简单，只需要在<code>while</code>条件里只保留<code>p != NULL</code>，而把其余所有判断移到<code>while</code>循环内部进行：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;x != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此，上述例子告诉我们，在进行链表循环遍历时，<strong>不能将空指针判断与其他需要访问结构体成员的相关判断放到一起</strong>，在循环判断里只保留空指针判断，而其他涉及结构体成员的判断放到循环内部一开始执行。<strong>这也是我们一直强调的事情：请把你代码的业务逻辑和在数据结构上的基础操作分离。</strong></p>
<h3 id="循环链表的遍历输出"><a href="#循环链表的遍历输出" class="headerlink" title="循环链表的遍历输出"></a>循环链表的遍历输出</h3><p>很多同学使用如下方法进行一个循环链表的遍历输出：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (p = <span class="built_in">list</span>; p-&gt;next != <span class="built_in">list</span>; p = p-&gt;next)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="comment">/* args */</span>);</span><br></pre></td></tr></table></figure></div>

<p>该代码错误原因很明显，即<strong>当<code>p</code>为<code>list</code>的前一个节点时，就不会再进入<code>for</code>循环了，因此少打印了一个节点</strong>。修改方式当然可以是，在跳出<code>for</code>循环后，再对当前的<code>p</code>节点进行一次打印，但未免稍显繁杂，因此可以采取如下方式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">p = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="comment">/* args */</span>);</span><br><span class="line">  p = p-&gt;next;</span><br><span class="line">&#125; <span class="keyword">while</span> (p != <span class="built_in">list</span>);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 链表的规范化操作</span><br><span class="line"></span><br><span class="line">&gt; 这部分主要针对课件中链表的基本操作，请掌握不牢的同学再次自查，**千万不要出现基本操作出错的情况！** 此外我们给大家提几点使用链表的建议。</span><br><span class="line">&gt;</span><br><span class="line">&gt; - **少用`typedef`。**很多同学代码中出现大量的标识符，如`node` `_node` `Node` `PNode` `Nodeptr`等，这很可能导致某个地方将复合数据类型和它的指针类型相混淆，造成不必要的麻烦；另一方面，作为并不是很系统的一个程序，这么自定义类型别名会给看你代码的人带来困扰。</span><br><span class="line">&gt; - **规范命名**。数据域中的变量名应当与实际情况相符合，如`char book_name[64];` `long stu_id;` `int wait_time;`等，切忌`a` `b` `c` `x` `y` `z`（除非这个结构体就是表示某种特定的数学符号，如坐标`(x, y)`或图的边`&lt;u,v&gt;`）；**指针域应当统一写`next`和`prev`**。</span><br><span class="line">&gt; - **不要用全局变量，尤其是`head`头指针。**</span><br><span class="line"></span><br><span class="line">### 统一口径</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;/images/assets6/截屏2023-03-29 08.53.08.png&quot; alt=&quot;截屏2023-03-29 08.53.08&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">我们以上图所示的**单向链表**为例。假设我们的链表的节点声明如下**（什么是声明、什么是定义？）**</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct node &#123;</span><br><span class="line">    int val;           // 这是个没有意义的名字！实际使用时最好不要这么写，这里只是举个小例子</span><br><span class="line">    struct node *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>遵循不用全局变量的原则，<strong>我们把一切变量都定义在<code>main</code>中</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// call functions</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当然，作为局部变量的<code>head</code>，如果直接传入各个函数，并不能修改其值，<strong>正如同在<code>main</code>中调用<code>void f(int i) &#123; i = 100; &#125;</code>并不能修改<code>main</code>中<code>int</code>变量的值</strong>。所以，我们统一传入**<code>struct node</code>的二级指针<strong>作为参数，函数调用时统一写</strong><code>&amp;head</code>**。这里假定函数都没有返回值。</p>
<h3 id="链表的初始化"><a href="#链表的初始化" class="headerlink" title="链表的初始化"></a>链表的初始化</h3><p>链表的初始化需要做的事情是将<code>head</code>指针设置成<code>NULL</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.00.09.png"
                      alt="截屏2023-03-29 09.00.09" style="zoom:50%;" 
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initlist</span><span class="params">(<span class="keyword">struct</span> node **phead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 功能：初始化链表</span></span><br><span class="line">    *phead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链表的插入"><a href="#链表的插入" class="headerlink" title="链表的插入"></a>链表的插入</h3><p>链表的插入需要做三件事</p>
<ul>
<li>通过<code>malloc</code>申请一个新节点并设置数据。</li>
<li>假设我们要在节点<code>p</code>的后面插入，则需要将新节点的指针指向<code>p</code>的后一个节点。</li>
<li>将<code>p</code>的指针指向新节点。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.03.54.png"
                      alt="截屏2023-03-29 09.03.54" style="zoom:30%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.04.06.png"
                      alt="截屏2023-03-29 09.04.06" style="zoom:30%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.04.18.png"
                      alt="截屏2023-03-29 09.04.18" style="zoom:30%;" 
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertlist</span><span class="params">(<span class="keyword">struct</span> node **phead, <span class="keyword">struct</span> node *p, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在节点 p 后插入新节点，其数据为 val</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">    <span class="comment">// ------ 创建新节点 ------</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">q</span> =</span> (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">    	<span class="comment">/* 这里其实应该加入错误判断的代码，如果 malloc 失败，则 q 为 NULL</span></span><br><span class="line"><span class="comment">    	   当然我们写的小程序一般不会有问题，除非你开了【某些杀毒软件】</span></span><br><span class="line"><span class="comment">    	   if (q == NULL) &#123;</span></span><br><span class="line"><span class="comment">    	       perror(&quot;malloc error&quot;);</span></span><br><span class="line"><span class="comment">    	         // 这个函数声明在 &lt;stdio.h&gt; 中</span></span><br><span class="line"><span class="comment">    	         // 能够在标准错误(屏幕)上输出 malloc error: xxx</span></span><br><span class="line"><span class="comment">    	         // xxx 为此函数解析的错误信息</span></span><br><span class="line"><span class="comment">    	         // 当然你也可以写 `fprintf(stderr, &quot;malloc error\n&quot;);`</span></span><br><span class="line"><span class="comment">    	         // 或 `printf(&quot;malloc error\n&quot;);`</span></span><br><span class="line"><span class="comment">    	       exit(1); // 或 `return;`，前者直接结束程序，后者只是返回 main</span></span><br><span class="line"><span class="comment">    	   &#125;</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">    q-&gt;val = val;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// -----------------------</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;       <span class="comment">// 如果链表为空</span></span><br><span class="line">        head = q;             <span class="comment">// 头节点就是新节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;   <span class="comment">// 如果在头节点之前插入</span></span><br><span class="line">        q-&gt;next = head;       <span class="comment">// 新节点的下一个节点就是原来的头节点</span></span><br><span class="line">        head = q;             <span class="comment">// 头节点改为新节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">    &#125;</span><br><span class="line">    *phead = head;            <span class="comment">// 更新 main 中的 head 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们对三种不同的插入进行讨论。参数中的<code>p</code>表示我们要在哪个节点后插入，其中，当<code>head</code>为<code>NULL</code>时，链表必然为空，则直接给头节点赋值即可；如果链表非空，而插入的位置<code>p</code>为空，则说明要在头节点之前插入 —— 因为这里的参数<code>p</code>，必然是通过调用<strong>某个查找函数</strong>得到的，那个查找函数遍历链表，应当有如下的功能</p>
<ul>
<li>找到链表中符合条件的节点，则返回该节点的指针。</li>
<li>未找到符合条件的节点<ul>
<li>如果这是<strong>无序链表</strong>，就返回<strong>尾节点</strong>的指针，便于在尾后插入。</li>
<li>如果这是<strong>有序链表</strong>（假设从小到大），如果我们要找的比表中任何一个数都要小，则返回<code>NULL</code>，表示<strong>未来应该插在链表的头</strong>；如果我们要找的比表中任何一个数都要大，则返回<strong>尾节点</strong>的指针，表示<strong>未来应该插在尾后</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>上述说明或许稍显复杂，我们可以这么想：<code>p</code>标识我们要插入的位置，<strong>在链表的中间插入或在尾后插入，操作是相同的</strong>，所以<code>p</code>只要是一个节点的指针即可；<strong>只有在头节点前插入是特殊的，此时<code>p</code>应该为特殊值<code>NULL</code>。</strong></p>
</blockquote>
<h3 id="链表的删除"><a href="#链表的删除" class="headerlink" title="链表的删除"></a>链表的删除</h3><p>链表的删除需要做三件事</p>
<ul>
<li>找到需要删除的节点及其前序节点。</li>
<li>将前序节点的指针指向需要删除节点的下一个节点。</li>
<li>释放要删除的节点。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.28.32.png"
                      alt="截屏2023-03-29 09.28.32" style="zoom:30%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.28.42.png"
                      alt="截屏2023-03-29 09.28.42" style="zoom:30%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-29 09.28.53.png"
                      alt="截屏2023-03-29 09.28.53" style="zoom:30%;" 
                >

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deletelist</span><span class="params">(<span class="keyword">struct</span> node **phead, <span class="keyword">struct</span> node *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 删除节点 p</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">q</span> =</span> head, *r = <span class="literal">NULL</span>;    <span class="comment">// q 从头开始遍历，r 为 q 的前一个节点</span></span><br><span class="line">    <span class="keyword">for</span> ( ; q != p; r = q, q = q-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// for 循环结束后，q 指向 p，r 指向 q 的前一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">NULL</span>) &#123;        <span class="comment">// 如果删的是头节点</span></span><br><span class="line">        head = q-&gt;next;     <span class="comment">// 改变头节点</span></span><br><span class="line">        <span class="built_in">free</span>(q);            <span class="comment">// 释放原来的头节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r-&gt;next = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    *phead = head;          <span class="comment">// 更新 main 中的 head</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链表的遍历"><a href="#链表的遍历" class="headerlink" title="链表的遍历"></a>链表的遍历</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">traverselist</span><span class="params">(<span class="keyword">struct</span> node *head, <span class="type">void</span> (*visit)(<span class="keyword">struct</span> node *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遍历链表中的每一个节点，对于每一个节点，调用函数 visit 进行访问</span></span><br><span class="line">    <span class="comment">// 第一个参数 head 即头节点，由于遍历并不会修改 head，所以不用传二级指针</span></span><br><span class="line">    <span class="comment">// 第二个参数为一个函数指针，表示访问方式</span></span><br><span class="line">    <span class="comment">//     - 这个函数的返回值是 void 类型</span></span><br><span class="line">    <span class="comment">//     - 这个函数需要接收一个 struct node * 类型的参数</span></span><br><span class="line">    <span class="comment">// 假设我们有</span></span><br><span class="line">    <span class="comment">//    void visit_1(struct node *p) &#123; printf(&quot;p-&gt;val: %d\n&quot;, p-&gt;val); &#125;</span></span><br><span class="line">    <span class="comment">// 和</span></span><br><span class="line">    <span class="comment">//    void visit_2(struct node *p) &#123; printf(&quot;(p-&gt;val)^2: %d\n&quot;, </span></span><br><span class="line">    <span class="comment">//                                             (p-&gt;val) * (p-&gt;val)); &#125;</span></span><br><span class="line">    <span class="comment">// 则可以在 main 中通过不同访问方式、打印不同信息</span></span><br><span class="line">    <span class="comment">//    traverselist(head, visit_1); traverselist(head, visit_2);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> node *p = head; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">            visit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链表的销毁"><a href="#链表的销毁" class="headerlink" title="链表的销毁"></a>链表的销毁</h3><p>销毁链表即<code>free</code>链表的每一个节点，<strong>只写<code>free(head);</code>是必然不可行的</strong>，除非链表中只剩下一个头节点。另一方面，一旦当前节点被<code>free</code>，则无法找到下一个节点，所以，销毁链表需要从最后一个节点开始。然而，找到了最后一个节点，其前一个节点又得从头遍历才能找到，所以，这里我们通过<strong>递归</strong>实现。<strong>具体的原理请画草图分析，这里不再赘述。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destroylist</span><span class="params">(<span class="keyword">struct</span> node **phead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 销毁链表，在 main 中应调用此函数</span></span><br><span class="line">    <span class="comment">// 其具体递归实现放在 recursive_free 中</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">    recursive_free(head);</span><br><span class="line">    *phead = <span class="literal">NULL</span>;  <span class="comment">// !! 将 main 中的 head 改为 NULL，防止销毁后再访问 !!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">recursive_free</span><span class="params">(<span class="keyword">struct</span> node *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放 p 及其后的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;        <span class="comment">// 如果 p 后面还有节点</span></span><br><span class="line">        recursive_free(p-&gt;next);  <span class="comment">// 释放 p 后面的所有节点</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">free</span>(p);                      <span class="comment">// 释放 p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>关于<code>free</code>函数</strong></p>
<p>我们摘要了手册中关于<code>free</code>函数的一些内容：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">  free(void *ptr);</span><br><span class="line"></span><br><span class="line">The free() function frees allocations that were created via the preceding allocation functions.[allocation: (内存)分配；preceding: 上述的]</span><br><span class="line"></span><br><span class="line">The free() function deallocates the memory allocation pointed to by ptr. If ptr is a NULL pointer, no operation is performed. [deallocates: 释放、回收、解除分配]</span><br></pre></td></tr></table></figure></div>

<p>这里，“前面提及的内存分配函数”指的是包括<code>malloc</code>在内的以<code>calloc</code> <code>valloc</code> <code>realloc</code>为代表的 C 库内存分配函数，有兴趣的同学可以自己 <strong>STFW（Search the Friendly&#x2F;F**king Web）</strong>一下。<strong>申请来的空间需要释放，这就是<code>free</code>的功能，该空间通过指针<code>ptr</code>指出。</strong>这其中的注意事项包括</p>
<ul>
<li><p><code>free</code>将<code>ptr</code>所指的内存空间全部<strong>清理</strong>，<strong>但并不会改变<code>ptr</code>还指在那里的既定事实</strong>。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pi = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*pi = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;before free, *pi = %d\n&quot;</span>, *pi);</span><br><span class="line"><span class="built_in">free</span>(pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after free, *pi = %d\n&quot;</span>, *pi); <span class="comment">// 合法，不会崩溃，大概率输出不是 10 的数</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>free</code>同一片内存多次程序会崩溃。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *p = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;first free success\n&quot;</span>);  <span class="comment">// 会输出</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;second free success\n&quot;</span>); <span class="comment">// 不会输出</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>free(NULL);</code>是安全的，这种情况下无事发生。</strong></p>
</li>
<li><p>综上三点，好习惯是：<strong>写完<code>free(p);</code>立即写<code>p = NULL;</code>。</strong>一方面可以防止你在释放空间后再次访问，因为此后访问空指针<code>p</code>程序会直接崩溃而非访问到一个奇怪的值；另一方面可以防止你不小心再次<code>free</code>而导致程序崩溃，因为<code>free</code>空指针是安全的。这里的区别在于，如果你<strong>无意中访问已经被<code>free</code>的空间，并不会报错，只是会得到错误数据而你找不出 bug</strong>，所以需要程序崩溃来<strong>提醒</strong>你错误访问了；如果你忘记考虑某些特殊情况而不慎多次<code>free</code>同一片内存，为了防止崩溃并简化代码，将指针设置成<code>NULL</code>是一个不错的选择。</p>
</li>
</ul>
</blockquote>
<h2 id="链表结构的拓展"><a href="#链表结构的拓展" class="headerlink" title="链表结构的拓展"></a>链表结构的拓展</h2><p>上述链表操作的基本思路和课件中相同，无非是<strong>节点的申请</strong>、<strong>链表头的维护</strong>和<strong>指针域的改变</strong>。在编程的时候，我们无需关心自引用结构中的底层逻辑，即不需要思考地址之类的问题，而是用更加上层的视角审视代码。此犹言</p>
<ul>
<li><code>head</code> <code>p</code> <code>q</code> <code>r</code> <code>next</code>等只是标识符，它们就<strong>代表了节点</strong>，访问时统一通过<code>-&gt;</code>即可。</li>
<li><code>p = p-&gt;next</code>等操作只是<strong>“挪一下位置”</strong>，而不应该细化为地址的赋值。</li>
<li>插入删除等函数中，一切指针赋值操作，应抽象为<strong>“声明了一个指向关系”</strong>。访问一个节点，我们要让<code>p</code>“指向”它；将 A 连接上 B，我们要让 A 的<code>next</code>“指向”B。所以，<strong>使用链表时，必须画图。</strong></li>
</ul>
<h3 id="next-next"><a href="#next-next" class="headerlink" title="next  ? next !"></a><code>next </code> ? <code>next</code> !</h3><blockquote>
<p>我的<code>next</code>是你，你的<code>next</code>是他 —— 于是，我连接你，你连接他。链表的实现思路使我们第一次看到了指针的作用，仅仅在结构体中增加了<code>next</code>成员，我们就能够创造出一种崭新的线性表。</p>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-17 21.21.16.png"
                      alt="截屏2023-03-17 21.21.16" style="zoom:30%;" 
                >

<p>还记得这张图吗？我们已经实现了其中的链表，那么树和图应该怎么实现呢？</p>
<ul>
<li><code>struct node *left, *right;</code>，假设<code>struct node</code>中有两个指针成员，那么一个<code>struct node</code>就可以最多指向两个其他的<code>struct node</code>，这就对应着<strong>二叉树</strong>结构。</li>
<li><code>struct node *neighbors[10];</code>，假设<code>struct node</code>中有一个指针数组成员（其中包含了 10 个指针），那么一个<code>struct node</code>就可以最多指向十个其他的<code>struct node</code>，这就对应着<strong>图</strong>结构。</li>
</ul>
<p>可见，有了指针，我们就<strong>在节点上定义了“指向”关系</strong>，A 指向 B，当且仅当通过 A 可以访问到 B。在程序里，指针存放节点的地址，于是通过一个节点可以访问到其他节点，这就<strong>实现了“指向”关系</strong>。</p>
<p>其实，我们可以用更加抽象的语言定义这件事情。设我们有如下集合<br>$$<br>A&#x3D;{e_1, e_2, \cdots, e_n}<br>$$<br>符号<br>$$<br>&lt;a,b&gt;<br>$$<br>用来表示 $a$ 和 $b$ 有关系。注意，这里有顺序问题，即<strong>如果 $a \neq b$ ，则 $&lt;a,b&gt;$ 和 $&lt;b,a&gt;$ 是不一样的关系</strong>。在我们的语境中，**$&lt;a,b&gt;$ 可以表示通过 $a$ 可以访问到 $b$，也就是 $a$“指向” $b$**。</p>
<p>假设上述集合 $A$ 中的每个元素都是<strong>单向链表 $L$</strong> 的节点，则 $L$ 实际上就是如下的集合<br>$$<br>L&#x3D;{&lt;e_1, e_2&gt;,&lt;e_2,e_3&gt;,\cdots,&lt;e_{n-1}, e_{n}&gt;}<br>$$<br>假设上述集合 $A$ 中的每个元素都是<strong>双向链表 $L’$</strong> 的节点，则 $L’$ 实际上就是如下的集合<br>$$<br>L’&#x3D;{&lt;e_1,e_2&gt;,\cdots, &lt;e_{n-1}, e_n&gt;,&lt;e_n,e_{n-1}, \cdots,&lt;e_2,e_1&gt;}<br>$$<br>所以我们发现，<strong>链表之所以为链表，就在于其节点通过指针域描述了一种“指向”关系</strong>，至于数据域中有什么内容，是无关紧要的。换言之，我们如果对指针域进行适当的扩充、封装，配合上一系列函数，就可以实现通用链表。</p>
<h3 id="一种双向链表的构想"><a href="#一种双向链表的构想" class="headerlink" title="一种双向链表的构想"></a>一种双向链表的构想</h3><blockquote>
<p>我们发现很多同学喜欢使用双向链表，其实在作业题中并没有太大必要使用，<strong>徒增一个指针成员只会增加犯错的几率</strong>。</p>
</blockquote>
<p>我们使用链表时其实只会顺序地遍历链表，<strong>并不会逆序遍历</strong>，另外，[2.5 节](#2.5 链表的销毁)提到的链表销毁函数，也给了我们逆序遍历的思路。所以，使用指向前一个节点的指针，<strong>无非是为了在某些特定的插入删除操作中，快速地找到前一个节点，进而修改前一个节点的<code>next</code>指针</strong>。实际上，我们想要快速访问前一个节点的<code>next</code>指针，<strong>只需要拥有那个<code>next</code>成员的地址即可</strong>。换言之，<strong>这里的<code>prev</code>指针，可以不是前一个节点的指针，而是前一个节点的<code>next</code>成员的指针</strong>。</p>
<p>于是，我们可以构造一种新的链表结构。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-31 14.13.16.png"
                      alt="截屏2023-03-31 14.13.16" style="zoom:40%;" 
                >

<ul>
<li>有一个名为<code>linkedlist_t</code>的<strong>结构体</strong>，这是<strong>链表的类型</strong>，其中包含了头节点的指针和其他必要信息，用这个类型定义出的每一个变量即为一个<strong>链表对象</strong>。</li>
<li>链表的每一个<strong>节点</strong>是名为<code>listnode_t</code>的<strong>结构体</strong>，其中包含了数据域和指针域。</li>
<li>节点中的<strong>指针域</strong>是名为<code>listlink_t</code>的<strong>结构体</strong>，其中有两个成员<code>next</code>和<code>prev</code>。<code>next</code>是<code>listnode_t</code>的<strong>一级指针</strong>，<strong>指向下一个节点</strong>；<code>prev</code>是<code>listnode_t</code>的<strong>二级指针</strong>，<strong>指向上一个节点的<code>next</code>指针</strong>。</li>
</ul>
<p>如此封装双向链表的好处就在于<strong>把数据和链表的操作分离</strong>。假设我们规定节点中的数据域的类型永远是<code>listdata_t</code>类型，每次使用时，把我们需要的数据都封装进一个结构体并命名为<code>listdata_t</code>，则我们可以一直<strong>复用</strong>先前写好的、用于链表操作的函数。这是因为，如同前文所述，<strong>链表的所有逻辑组成，就是其指针之间的相互引用关系，而非节点中存放的数据</strong>，所以，我们把指针域专门提取出来并进行封装。</p>
<h2 id="面向对象的数据结构-——-链表篇"><a href="#面向对象的数据结构-——-链表篇" class="headerlink" title="面向对象的数据结构 —— 链表篇"></a>面向对象的数据结构 —— 链表篇</h2><h3 id="新类型的声明"><a href="#新类型的声明" class="headerlink" title="新类型的声明"></a>新类型的声明</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">listnode_t</span>;</span>  <span class="comment">// 这里我们先做一个前向声明，防止后续出现无法解析类型的问题</span></span><br><span class="line">                                 <span class="comment">// listnode_t 即为链表的节点类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>           <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> **<span class="title">prev</span>;</span>          <span class="comment">// 指向上一个节点的 next 的指针</span></span><br><span class="line">&#125; <span class="type">listlink_t</span>;                    <span class="comment">// listlink_t 是指针域类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>                    <span class="comment">// 链表的节点</span></span><br><span class="line">    <span class="type">listdata_t</span> data;             <span class="comment">// 数据域 —— 不用关心</span></span><br><span class="line">    <span class="type">listlink_t</span> link;             <span class="comment">// 指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">listnode_t</span> *head;            <span class="comment">// 链表头指针</span></span><br><span class="line">    <span class="type">listnode_t</span> *tail;            <span class="comment">// 链表尾指针</span></span><br><span class="line">    <span class="type">size_t</span> size;                 <span class="comment">// 链表的节点数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当然可以有更多，如最后一次修改时间、链表的创建者等</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="type">linkedlist_t</span>;                  <span class="comment">// linkedlist_t 即为链表类型，类比上次的 array_t</span></span><br></pre></td></tr></table></figure></div>

<h3 id="链表的初始化和销毁"><a href="#链表的初始化和销毁" class="headerlink" title="链表的初始化和销毁"></a>链表的初始化和销毁</h3><blockquote>
<p><strong><code>assert</code>的使用</strong></p>
<p><code>assert</code>即为<strong>“断言”</strong>，使用时，应该包含头文件<code>&lt;assert.h&gt;</code>。<code>assert</code>有一个参数，是一个<strong>条件表达式</strong>，例如<code>assert(a != b);</code>，这条语句的含义是“断言<code>a</code>不等于<code>b</code>”—— 假设<code>a</code>真的不等于<code>b</code>，<strong>断言成立，无事发生</strong>；假设<code>a</code>等于<code>b</code>，则<strong>断言不成立，代价是程序直接崩溃</strong>。所以我们书写的链表操作函数，传入<strong>链表类型的指针</strong><code>list</code>，可以先**断言<code>list</code>不是<code>NULL</code>**。如果传入了空指针，程序直接崩溃，避免后续的麻烦。</p>
<p><strong>另，以下代码注释中的调用方式全部在<code>main</code>中，并且假设在<code>main</code>的开头已经定义了<code>linkedlist_t list;</code><strong>，即一个名为<code>list</code>、类型为<code>linkedlist_t</code>的</strong>链表对象</strong>。</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_init</span><span class="params">(<span class="type">linkedlist_t</span> *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* === 初始化链表`list` ===</span></span><br><span class="line"><span class="comment">       调用方式：list_init(&amp;list);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>); <span class="comment">// 断言传入了一个非空的参数</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="literal">NULL</span>;    <span class="comment">// 初始化链表头节点为空</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;    <span class="comment">// 初始化链表尾节点为空</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">0</span>;       <span class="comment">// 初始化链表长度为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_destroy</span><span class="params">(<span class="type">linkedlist_t</span> *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* === 销毁链表`list` ===</span></span><br><span class="line"><span class="comment">       调用方式：list_destroy(&amp;list);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head != <span class="literal">NULL</span>) &#123;  <span class="comment">// 如果链表中有节点，则递归删除每一个节点</span></span><br><span class="line">        list_recursive_free(<span class="built_in">list</span>-&gt;head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="literal">NULL</span>;  <span class="comment">// 重置链表头节点为空</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;  <span class="comment">// 重置链表尾节点为空</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">-1</span>;    <span class="comment">// 重置链表长度为无效值 -1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">list_recursive_free</span><span class="params">(<span class="type">listnode_t</span> *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* === 递归删除链表节点 ===</span></span><br><span class="line"><span class="comment">       由 list_destroy 函数自动调用</span></span><br><span class="line"><span class="comment">       原理见本文第一部分</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;link.next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        list_recursive_free(node-&gt;link.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链表的头插和尾插"><a href="#链表的头插和尾插" class="headerlink" title="链表的头插和尾插"></a>链表的头插和尾插</h3><blockquote>
<p>我们可能需要一个函数来创建新节点，把数据域的指针传入这个函数，即可返回一个新节点</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">listnode_t</span> *<span class="title function_">list_newnode</span><span class="params">(<span class="type">listdata_t</span> *pdata)</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* === 创建并返回一个新节点，数据由`pdata`指明 ===</span></span><br><span class="line"><span class="comment">    调用方式：</span></span><br><span class="line"><span class="comment">       listdata_t data = &#123;1, 3.14, &#x27;c&#x27;, &quot;hello&quot;&#125;; // 假设这是数据域</span></span><br><span class="line"><span class="comment">       listnode_t *node = list_newnode(&amp;data);    // p 为指向新节点的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">listnode_t</span> *node = (<span class="type">listnode_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">listnode_t</span>));</span><br><span class="line">                                       <span class="comment">// 申请新节点的内存空间</span></span><br><span class="line"> assert(node != <span class="literal">NULL</span>);  <span class="comment">// 断言 malloc 成功(node 非空)</span></span><br><span class="line"> node-&gt;data = *pdata;   <span class="comment">// 数据赋值(结构体可以直接用等号赋值)</span></span><br><span class="line"> node-&gt;link.prev = node-&gt;link.next = <span class="literal">NULL</span>; <span class="comment">// prev 和 next 初始化为空</span></span><br><span class="line">                    <span class="comment">// 注意 prev 和 next 是 node 的成员 link 的成员</span></span><br><span class="line"> <span class="keyword">return</span> node;       <span class="comment">// 返回新节点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_insert_tail</span><span class="params">(<span class="type">linkedlist_t</span> *<span class="built_in">list</span>, <span class="type">listnode_t</span> *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* === 在链表`list`尾插入节点`node` ===</span></span><br><span class="line"><span class="comment">       (本函数可以实现链栈/队的压栈/入队)</span></span><br><span class="line"><span class="comment">       调用方式：list_insert_tail(&amp;list, list_newnode(&amp;data));</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail != <span class="literal">NULL</span>) &#123;            <span class="comment">// 如果尾节点存在(即链表非空)</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;link.next = node;    <span class="comment">// 【原来尾节点】的 next 指向 node 节点</span></span><br><span class="line">        node-&gt;link.prev = &amp;(<span class="built_in">list</span>-&gt;tail-&gt;link.next);</span><br><span class="line">                      <span class="comment">// 把【原来尾节点】的 next 的地址交给 node 节点的 prev 成员</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 如果尾节点不存在(即链表为空)</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;               <span class="comment">// 头节点指针指向 node</span></span><br><span class="line">        node-&gt;link.prev = &amp;(<span class="built_in">list</span>-&gt;head); </span><br><span class="line">                              <span class="comment">// 把【头节点指针】的地址交给 node 节点的 prev 成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = node;  <span class="comment">// 更新尾节点</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;       <span class="comment">// 更新节点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_insert_head</span><span class="params">(<span class="type">linkedlist_t</span> *<span class="built_in">list</span>, <span class="type">listnode_t</span> *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* === 在链表`list`头插入节点`node` ===</span></span><br><span class="line"><span class="comment">       (本函数可以实现链队的出队)</span></span><br><span class="line"><span class="comment">       调用方式：list_insert_head(&amp;list, list_newnode(&amp;data));</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head != <span class="literal">NULL</span>) &#123;          <span class="comment">// 如果头节点存在(即链表非空)</span></span><br><span class="line">        node-&gt;link.next = <span class="built_in">list</span>-&gt;head;  <span class="comment">// 新节点 node 的 next 指向【原头节点】</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;link.prev = &amp;(node-&gt;link.next);</span><br><span class="line">                      <span class="comment">// 【原头节点】的 prev 存放新节点 node 的 next 成员的地址</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                <span class="comment">// 如果头节点不存在(即链表为空)</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;  <span class="comment">// 维护尾节点(因为在此之前尾节点为 NULL)</span></span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;link.prev = &amp;(<span class="built_in">list</span>-&gt;head); <span class="comment">// 把【头节点指针】的地址交给 node 节点的 prev 成员</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = node;               <span class="comment">// 更新头节点指针</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;                    <span class="comment">// 更新节点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="节点的删除"><a href="#节点的删除" class="headerlink" title="节点的删除"></a>节点的删除</h3><blockquote>
<p><strong>链表的删除，需要知道前一个节点的指针，在单向链表中，这个操作需要遍历链表才能实现。</strong>在我们的双向链表中，我们可以<strong>通过<code>prev</code>成员访问到前一个节点的<code>next</code>成员，这是因为<code>prev</code>存放的正是前一个节点<code>next</code>成员的地址</strong>，从而很方便地修改其值。但是，考虑这样一种情况，如果我们删除的是<strong>尾节点</strong>，固然可以通过原来尾节点的<code>prev</code>访问到其前一个节点的<code>next</code>成员并将其置为<code>NULL</code>，然而我们<strong>还有一个链表尾指针<code>list-&gt;tail</code>需要维护</strong>，我们似乎并不能<strong>通过前一个节点的<code>next</code>成员的地址，获取前一个节点的地址</strong>……怎么办呢？</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets6/截屏2023-03-31 22.01.41.png"
                      alt="截屏2023-03-31 22.01.41" style="zoom:40%;" 
                >

<p>根据此图，我们看出，<strong>结构体内部成员按照我们声明的顺序连续存放</strong>，假如我们知道了<code>next</code>成员的地址，减去一个<strong>“偏移量”</strong>，就可以得到节点的首地址。很自然地会想到，<strong>这个偏移量或许是<code>sizeof(struct data)</code>或<code>sizeof(int) + sizeof(char) * 11</code><strong>。但不幸的是，为了实现结构体的<a class="link"   href="https://blog.csdn.net/x2528238270/article/details/120798606?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-120798606.nonecase&spm=1018.2226.3001.4187" >字节对齐 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，</strong>结构体的各个成员之间可能会被安排一些不用于存放数据的“空洞”</strong>，所以，单纯采用<code>sizeof</code>获取偏移量的方法是不可行的。</p>
<p>不过，<strong>只要各个结构体的形态一经声明，从节点首地址到<code>next</code>成员地址的这一段“差值”，必然固定</strong>，所以我们只需要直接通过<strong>指针值的相减</strong>，不就能得出偏移了多少个字节吗？不过，在进行指针相减的时候，<strong>我们应先把指针都转化为<code>void*</code>类型，才能做到真正的整数值相减</strong>；否则，有类型的指针做减法，得到的是“相差多少个该类型的元素”。</p>
<p><strong>直接给出偏移量的计算方法：<code>(size_t) &amp; (((listnode_t*)(0))-&gt;link.next)</code>。</strong></p>
<ul>
<li>我们知道，<code>NULL</code>即为保存着地址值<code>0</code>的指针，也称为空指针。既然是指针，我们可以将其强转为<strong>节点指针</strong>的类型，即<code>((listnode_t*)(0))</code>表示的含义。这一步强转，我们手中也就<strong>获取了一个从 0 地址开始往后存放的节点结构体，虽然这个结构体并不真实存在</strong>。</li>
<li>通过指针访问成员，对应<code>(((listnode_t*)(0))-&gt;link.next)</code>，这个表达式即为其<code>next</code>成员。</li>
<li>这个“虚拟结构体”地址从 0 开始，则<strong>它的</strong><code>next</code>成员的<strong>地址值</strong>，不正是<strong>“节点的<code>next</code>成员到节点首地址的偏移量”</strong>吗？所以我们取其地址，对应<code>&amp; (((listnode_t*)(0))-&gt;link.next)</code>这个表达式。</li>
<li>最后，我们把这个偏移量强转为无符号长整型<code>size_t</code>。</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_rmnode</span><span class="params">(<span class="type">linkedlist_t</span> *<span class="built_in">list</span>, <span class="type">listnode_t</span> *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* === 删除链表`list`中的节点`node` ===</span></span><br><span class="line"><span class="comment">       (如果 node 参数取 list-&gt;tail，可以实现链栈的弹栈)</span></span><br><span class="line"><span class="comment">       调用方式：</span></span><br><span class="line"><span class="comment">          // 通过某种方式得到了想要删除的节点 p</span></span><br><span class="line"><span class="comment">          list_rmnode(&amp;list, p);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="built_in">list</span>-&gt;tail) &#123; <span class="comment">// 假设要删除链表尾节点，则需要考虑维护 tail 指针的问题</span></span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> OFFSET_OF_NEXT = (<span class="type">size_t</span>) &amp; (((<span class="type">listnode_t</span>*)(<span class="number">0</span>))-&gt;link.next);</span><br><span class="line">            <span class="comment">// 根据上文所述，定义一个无符号长整型的常量(也可以写成宏)</span></span><br><span class="line">            <span class="comment">// 这个常量用来表示【节点的 next 成员的地址】和【节点的地址】间的差值(偏移量offset)</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = (<span class="type">listnode_t</span>*)((<span class="type">void</span>*)(node-&gt;link.prev) - OFFSET_OF_NEXT);</span><br><span class="line">            <span class="comment">// 维护尾节点指针</span></span><br><span class="line">            <span class="comment">// node-&gt;link.prev 是【原尾节点的前一个节点】的【next成员】的【地址】</span></span><br><span class="line">            <span class="comment">// (void*)(node-&gt;link.prev) 是使之进行整数减法运算</span></span><br><span class="line">            <span class="comment">// 减去偏移量得到【原尾节点的前一个节点】的【地址】的数值</span></span><br><span class="line">            <span class="comment">// 将这一地址的整数值强转成【节点指针listnode_t*】类型，交给list-&gt;tail</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --- 以下是任何情况下删节点都要做的操作 ---</span></span><br><span class="line">    </span><br><span class="line">    *(node-&gt;link.prev) = node-&gt;link.next;  <span class="comment">// 前一个节点的 next 指向要删除节点的下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;link.next != <span class="literal">NULL</span>) &#123;         <span class="comment">// 如果要删除节点后还有节点(即要删的不是尾节点)</span></span><br><span class="line">        *((node-&gt;link.next)-&gt;link.prev) = node-&gt;link.prev;</span><br><span class="line">                                           <span class="comment">// 后面那个节点的 prev 指向前面那个节点的 next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--; <span class="comment">// 更新节点个数</span></span><br><span class="line">    <span class="built_in">free</span>(node);   <span class="comment">// 最后才释放内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>当然，为了实现更完整的功能，你还需要编写更多函数。</p>
</blockquote>
<h2 id="宏的常见用法"><a href="#宏的常见用法" class="headerlink" title="宏的常见用法"></a>宏的常见用法</h2><blockquote>
<p>宏（macro）可以简化代码，并且减少<strong>硬编码</strong>的成分。关于硬编码的危害，这里不再赘述了。</p>
<p><strong>宏的名称应该全部大写，多个单词间用下划线分隔。</strong></p>
<p>这一部分我们仅列举使用方法，不再添加解释性的内容。</p>
</blockquote>
<h3 id="程序中频繁使用的常量的定义"><a href="#程序中频繁使用的常量的定义" class="headerlink" title="程序中频繁使用的常量的定义"></a>程序中频繁使用的常量的定义</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDGE_NUM 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERTEX_NUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 4.2 题括号匹配，你可能需要</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT_PARENTHESES   <span class="string">&#x27;(&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT_PARENTHESES  <span class="string">&#x27;)&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT_BRACE  <span class="string">&#x27;&#123;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT_BRACE <span class="string">&#x27;&#125;&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D_QUOTE <span class="string">&#x27;\&quot;&#x27;</span> <span class="comment">// D for double</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_QUOTE <span class="string">&#x27;\&#x27;  // S for single</span></span></span><br><span class="line"><span class="string"><span class="meta">// 用一些整型常数定义程序当前状态，为 flag 赋值</span></span></span><br><span class="line"><span class="string"><span class="meta">#define NORMAL 0</span></span></span><br><span class="line"><span class="string"><span class="meta">#define IN_QUOTE 1</span></span></span><br><span class="line"><span class="string"><span class="meta">#define IN_COMMENT 2</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="定义小函数"><a href="#定义小函数" class="headerlink" title="定义小函数"></a>定义小函数</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ALPHA(x) (<span class="string">&#x27;A&#x27;</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="string">&#x27;Z&#x27;</span> || <span class="string">&#x27;a&#x27;</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="string">&#x27;z&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ALNUM(x) (IS_ALPHA(x) || <span class="string">&#x27;0&#x27;</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line">      <span class="comment">// 后续定义的宏可以用到已经定义过的宏</span></span><br><span class="line">      <span class="comment">// ctype.h 的这些函数名都是小写的，可见它们并不是用简单的宏定义的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// *** 宏的参数必须全部用括号括起来，否则会出现优先级问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE_1(x) (x * x)     <span class="comment">// 错误</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE_2(x) ((x) * (x)) <span class="comment">// 正确</span></span></span><br><span class="line"><span class="comment">// printf(&quot;%d\n&quot;, SQUARE_1(5 + 5)); 会被解析成</span></span><br><span class="line"><span class="comment">// printf(&quot;%d\n&quot;, 5 + 5 * 5 + 5);</span></span><br><span class="line"><span class="comment">// printf(&quot;%d\n&quot;, SQUARE_2(5 + 5)); 会被解析成</span></span><br><span class="line"><span class="comment">// printf(&quot;%d\n&quot;, (5 + 5) * (5 + 5));</span></span><br></pre></td></tr></table></figure></div>

<h3 id="定义复杂输出格式等"><a href="#定义复杂输出格式等" class="headerlink" title="定义复杂输出格式等"></a>定义复杂输出格式等</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OUTPUT(x1, y1, x2, y2, x3, y3)                 \</span></span><br><span class="line"><span class="meta">			printf(<span class="string">&quot;A(%d, %d) B(%d, %d), C(%d, %d)&quot;</span>,    \</span></span><br><span class="line"><span class="meta">			(x1), (y1), (x2), (y2), (x3), (y3))</span></span><br><span class="line"><span class="comment">// 分多行写则行末加上反斜杠表示连接</span></span><br></pre></td></tr></table></figure></div>

<h3 id="用宏定义功能模块"><a href="#用宏定义功能模块" class="headerlink" title="用宏定义功能模块"></a>用宏定义功能模块</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，开辟一个类型为`type`大小为`size`的数组，交给指针`p`</span></span><br><span class="line"><span class="comment">// 并且将这片内存都初始化为 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_AND_INIT(p, type, size) do &#123;            \</span></span><br><span class="line"><span class="meta">       (p) = ((type)*)malloc(sizeof(type) * (size));  \</span></span><br><span class="line"><span class="meta">       memset(p, 0, sizeof(type) * (size));           \</span></span><br><span class="line"><span class="meta">   &#125; while(0)</span></span><br><span class="line"><span class="comment">// 语句外套上无用的 do-while(0) 是为了在一些特殊情况防止分号的冲突</span></span><br></pre></td></tr></table></figure></div>

<p><em>Author: Riccardo, diandian</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第七期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%B8%83%E6%9C%9F/</url>
    <content><![CDATA[<blockquote>
<p>老规矩：若针对这些题目，同学们有更好更简洁的方法，欢迎来找助教讨论，助教请喝奶茶😍😍。</p>
</blockquote>
<h2 id="连续线段"><a href="#连续线段" class="headerlink" title="连续线段"></a>连续线段</h2><p>此题使用链表和数组的解法各有优劣。有些同学在写代码时容易默认输入的点是按x坐标顺序输入的，但其实不然，因此在后续<code>for</code>循环判断时第一层变量为<code>i</code>,第二层变量为<code>j = i + 1</code>，这样就忽略了可能在该线段之前的线段中存在相连的可能性。因此一种实用的做法为先对输入的所有点进行排序，这样在后续判断时也更有逻辑。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x1;</span><br><span class="line">    <span class="type">int</span> x2;</span><br><span class="line">    <span class="type">int</span> y1;</span><br><span class="line">    <span class="type">int</span> y2;</span><br><span class="line">&#125;line[<span class="number">201</span>];<span class="comment">//所有线段的点都存储在结构体数组中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * a, <span class="type">const</span> <span class="type">void</span> * b)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">e1</span> =</span> (<span class="keyword">struct</span> node *)a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">e2</span> =</span> (<span class="keyword">struct</span> node *)b;</span><br><span class="line">    <span class="keyword">if</span>(e1-&gt;x1 &gt; e2-&gt;x1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e1-&gt;x1 &lt; e2-&gt;x1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x3=<span class="number">0</span>, y3=<span class="number">0</span>;<span class="comment">//x3和y3存储当前需要判断是否能连接的点</span></span><br><span class="line">    <span class="type">int</span> i, j, n, count[<span class="number">201</span>]=&#123;<span class="number">0</span>&#125;, ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;line[i].x1, &amp;line[i].y1, &amp;line[i].x2, &amp;line[i].y2);</span><br><span class="line">    qsort(line, n, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> node), cmp);<span class="comment">//将输入的线段按照左端点横坐标排序</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        x3 = line[i].x2;</span><br><span class="line">        y3 = line[i].y2;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(line[j].x1 == x3 &amp;&amp; line[j].y1 == y3)&#123;</span><br><span class="line">                count[i]++;</span><br><span class="line">                x3=line[j].x2;</span><br><span class="line">                y3=line[j].y2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//因为已经排好序，所以直接顺位判断是否能连接，能连接则count++</span></span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count[i]&gt;ans)&#123;</span><br><span class="line">            ans=count[i];</span><br><span class="line">            j=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//找到最大的count，该循环为经典的寻找最大值or最小值的方法</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, ans+<span class="number">1</span>, line[j].x1, line[j].y1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="空闲空间申请模拟（最佳适应）"><a href="#空闲空间申请模拟（最佳适应）" class="headerlink" title="空闲空间申请模拟（最佳适应）"></a>空闲空间申请模拟（最佳适应）</h2><p>该题的题面较长，大家一定要看清楚每一个要求，踩坑的地方包括但不限于：</p>
<p>1、找不到足够大的空闲快，则什么操作都不发生；</p>
<p>2、并不是简单地寻找到空间恰好相等的节点，而是遍历一圈找到满足要求的空间最小的节点进行操作；</p>
<p>3、在删除节点时如果使用<code>free()</code>函数，则一定要保证这个空间后续不会再被使用；</p>
<p>4、一定要注意！不能访问到空指针。形如<code>if(p-&gt;length!=0 &amp;&amp; p != NULL)</code>的形式仍是不可以的，因为<code>p</code>如果是空指针，逻辑上if条件确实不会成立，但仍存在<code>p-&gt;length!=0</code>的判断，这样就访问到了空指针。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> address;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dot[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, op, min, flag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span>, *<span class="title">q</span>, *<span class="title">r</span>, *<span class="title">r_be</span>, *<span class="title">now</span>;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;dot[<span class="number">0</span>].address, &amp;dot[<span class="number">0</span>].length);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;dot[i].address, &amp;dot[i].length);</span><br><span class="line">        dot[i<span class="number">-1</span>].next = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        dot[i<span class="number">-1</span>].next = &amp;dot[i];</span><br><span class="line">    &#125;<span class="comment">//每次输入的时候，让前一节点的next指向当前节点，因此需先输入第0个节点</span></span><br><span class="line">    now = dot[n<span class="number">-1</span>].next = &amp;dot[<span class="number">0</span>];<span class="comment">//将物理意义上的最后一个节点与第一个节点相连</span></span><br><span class="line">    q = &amp;dot[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>((<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op))!=EOF)&#123;</span><br><span class="line">        r = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        r_be = (<span class="keyword">struct</span> node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            p = now;</span><br><span class="line">            <span class="keyword">for</span>(q = p; q-&gt;next != p; q = q-&gt;next);</span><br><span class="line">            min = <span class="number">999999</span>;<span class="comment">//“新的开始”，每次进循环为min赋初值为一个较大的数</span></span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;length&gt;=op &amp;&amp; p-&gt;length &lt; min)&#123;</span><br><span class="line">                    r = p;</span><br><span class="line">                    r_be = q;</span><br><span class="line">                    min = p-&gt;length;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">while</span>(p != now);<span class="comment">//do-while循环结构可以有效循环遍历一圈，因为其先执行操作再判断</span></span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;length &gt; op)&#123;</span><br><span class="line">                    r-&gt;length -= op;</span><br><span class="line">                    now = r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;length == op)&#123;</span><br><span class="line">                    r-&gt;length = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(r-&gt;next != r)&#123;</span><br><span class="line">                        now = r-&gt;next;</span><br><span class="line">                        r_be-&gt;next = r-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        now = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;<span class="comment">//特判：如果当前只剩一个节点，则直接让这个节点为NULL</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = now;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//特判：如果当前节点已为空，相当于全部删除完，什么都不输出</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, p-&gt;address, p-&gt;length);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(p != now);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="多项式相乘"><a href="#多项式相乘" class="headerlink" title="多项式相乘"></a>多项式相乘</h2><p>本题需要注意：</p>
<p>1、链表与数组均可解决此问题，各有优劣；</p>
<p>2、注意数据范围，应用<code>long long</code>存储指数和系数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">duo</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> xi;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> zhi;</span><br><span class="line">&#125;a[<span class="number">81</span>], b[<span class="number">81</span>], ans[<span class="number">6561</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">duo</span>* <span class="title">ia</span> =</span> (<span class="keyword">struct</span> duo*)a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">duo</span>* <span class="title">ib</span> =</span> (<span class="keyword">struct</span> duo*)b;</span><br><span class="line">    <span class="keyword">if</span>((ia-&gt;zhi &lt; ib-&gt;zhi) || ((ia-&gt;zhi == ib-&gt;zhi) &amp;&amp; (ia-&gt;xi &gt; ib-&gt;xi)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="comment">//按照指数从大到小排列，若指数相同，则系数从小到大排列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>, i1, j1, k1;</span><br><span class="line">    <span class="type">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a[i].xi, &amp;a[i].zhi);</span><br><span class="line">        c1 = getchar();</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="comment">//用此种方法可以实现换行时结束读入，且\n与\r\n都可，请大家自己思考为什么</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;b[j].xi, &amp;b[j].zhi);</span><br><span class="line">        c2 = getchar();</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(c2 == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i1 = i;</span><br><span class="line">    j1 = j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; i1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; j1; j++)&#123;</span><br><span class="line">            ans[k].xi = a[i].xi * b[j].xi;</span><br><span class="line">            ans[k].zhi = a[i].zhi + b[j].zhi;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//多项式相乘法则</span></span><br><span class="line">    k1 = k;</span><br><span class="line">    qsort(ans, k1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> duo), cmp);<span class="comment">//排序，排完序后肯定会有指数相同的相邻项</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; (j &lt; k1) &amp;&amp; (i + j &lt; k1); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i+j].zhi == ans[i].zhi)&#123;</span><br><span class="line">                ans[i].xi += ans[i+j].xi;</span><br><span class="line">                ans[i+j].zhi = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;<span class="comment">//消除指数相同的项，系数全部相加</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k1 - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i].zhi != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld &quot;</span>, ans[i].xi, ans[i].zhi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld &quot;</span>, ans[k1<span class="number">-1</span>].xi, ans[k1<span class="number">-1</span>].zhi);<span class="comment">//为防止全部都为0，最后必须输出一次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="文件加密（环）"><a href="#文件加密（环）" class="headerlink" title="文件加密（环）"></a>文件加密（环）</h2><p>该题为本次作业的重重重灾区！问题主要出在：</p>
<p>1、对于输入的字符串没有预处理末尾的换行符，或者处理方式有问题，导致后面全部出错；</p>
<p>2、原密钥对应的最后一个字符的新密钥没有被赋值，导致最终密钥表缺失；</p>
<p>3、对链表的操作不熟悉，对于表头的使用、对于链表节点的插入、删除等操作出现问题；</p>
<p>4、使用野指针或访问空指针，定义局部指针时未初始化。</p>
<p>一些建议：</p>
<p>1、增加对链表的熟悉程度，插入、删除等操作可以自己总结成一个模版；</p>
<p>2、对于复杂的题目，模块化非常重要。自定义好各司其职的函数，<code>main</code>函数里保留逻辑部分；</p>
<p>3、调试方法与技巧！一定要善于使用<code>printf</code>函数进行打印调试。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">formation</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">formation</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">char</span> * b, <span class="type">char</span> * c)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i]==c[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==k)</span><br><span class="line">            c[k++]=b[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//对于输入的字符串b，删除其重复出现的字母，结果保存到c数组里</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sheet</span><span class="params">(<span class="type">char</span> * b, <span class="type">char</span> * c)</span>&#123;</span><br><span class="line">    <span class="type">char</span> re[<span class="number">95</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, j, k=<span class="number">0</span>, tmp[<span class="number">95</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    del(b,c);</span><br><span class="line">    j = (<span class="type">int</span>)<span class="built_in">strlen</span>(c);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">        tmp[c[i]-<span class="string">&#x27; &#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">95</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[i] == <span class="number">0</span>)</span><br><span class="line">            re[k++] = i + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;<span class="comment">//将剩余的且未出现过的可见字符保存到re数组里</span></span><br><span class="line">    <span class="built_in">strcat</span>(c,re);<span class="comment">//将re数组追加到c数组后，形成原密钥</span></span><br><span class="line">&#125;<span class="comment">//对于输入的字符串b，形成原密钥c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">final</span><span class="params">(<span class="type">char</span> * b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">formation</span> *<span class="title">List</span> =</span> <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>, *r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">95</span>; i++)&#123;</span><br><span class="line">        r = (<span class="keyword">struct</span> formation *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> formation));</span><br><span class="line">        r-&gt;c = b[j++];</span><br><span class="line">        <span class="keyword">if</span>(List == <span class="literal">NULL</span>)</span><br><span class="line">            List = p = r;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;link = r;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;link = List;<span class="comment">//到此为止，循环链表已经建立</span></span><br><span class="line">    r = p;</span><br><span class="line">    p = p-&gt;link;</span><br><span class="line">    k = p-&gt;c;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;link != p)&#123;</span><br><span class="line">        r-&gt;link = p-&gt;link;</span><br><span class="line">        j = p-&gt;c;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = (<span class="keyword">struct</span> formation *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> formation));<span class="comment">//free过后，记得再申请</span></span><br><span class="line">        p = r-&gt;link;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; j; i++, r=p, p=p-&gt;link);<span class="comment">//只一条for语句，注意移动次数，便寻得所需节点</span></span><br><span class="line">        b[j<span class="number">-32</span>] = p-&gt;c;<span class="comment">//建立该字符与原密钥的的字符的对应关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    b[p-&gt;c <span class="number">-32</span>] = k;<span class="comment">//最后剩下的字符的密文为原密钥的第一个字符</span></span><br><span class="line">&#125;<span class="comment">//将原密钥b进行处理，形成密钥表，依旧保存到b中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">33</span>]=&#123;<span class="number">0</span>&#125;, pre[<span class="number">95</span>]=&#123;<span class="number">0</span>&#125;, c;</span><br><span class="line">    FILE *in = fopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE *out = fopen(<span class="string">&quot;in_crpyt.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    gets(s);</span><br><span class="line">    sheet(s, pre);</span><br><span class="line">    final(pre);<span class="comment">//逻辑部分在main函数里实现，具体操作可适当封装成函数，这样调试起来也方便发现错误</span></span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(in)) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="number">32</span> &amp;&amp; c&lt;=<span class="number">126</span>)</span><br><span class="line">            fputc(pre[c<span class="number">-32</span>], out);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fputc(c, out);</span><br><span class="line">    &#125;<span class="comment">//注意不可见字符要原样输出！</span></span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="词频统计（数组或链表实现）"><a href="#词频统计（数组或链表实现）" class="headerlink" title="词频统计（数组或链表实现）"></a>词频统计（数组或链表实现）</h2><p>本题使用数组或链表都是可以做的，但个人认为数组会更简洁。需要注意的是，题目中明确说明<strong>单词仅为有字母组成的字符序列</strong>，但并没有说<strong>单词与单词之间一定由空格隔开</strong>，不能只看样例而轻下论断，因此使用<code>fscanf</code>读取单词肯定是会出问题的。</p>
<p>一些建议：当明确地需要执行排序操作时，数组比链表更为简洁。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> word[<span class="number">51</span>];</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;wordlist[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * a, <span class="type">const</span> <span class="type">void</span> *b)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">e1</span> =</span> (<span class="keyword">struct</span> node*)a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">e2</span> =</span> (<span class="keyword">struct</span> node*)b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(e1-&gt;word,e2-&gt;word);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> table[<span class="number">5120</span>]=&#123;<span class="number">0</span>&#125;, c;</span><br><span class="line">    FILE *in = fopen(<span class="string">&quot;article.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, j, k, len, total=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((c = fgetc(in)) != EOF)</span><br><span class="line">        table[i++] = c;<span class="comment">//将文件中所有字符读进一个字符串数组</span></span><br><span class="line">    len = i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isalpha</span>(table[i]))<span class="comment">//如果不是字母</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j = <span class="number">0</span>;<span class="comment">//“新的开始”，每次需要加入新的单词时，给j赋初值为0</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isalpha</span>(table[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">islower</span>(table[i]))<span class="comment">//如果是小写字母</span></span><br><span class="line">                    wordlist[total].word[j++] = table[i];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isupper</span>(table[i]))<span class="comment">//如果是大写字母</span></span><br><span class="line">                    wordlist[total].word[j++] = table[i] + <span class="number">32</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            wordlist[total].word[j] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//最后一定要加上&#x27;\0&#x27;</span></span><br><span class="line">            wordlist[total].count = <span class="number">1</span>;<span class="comment">//让该单词的出现次数为1</span></span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; total; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(wordlist[k].word,wordlist[total].word) == <span class="number">0</span>)&#123;</span><br><span class="line">                    wordlist[k].count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//立即在已有的字母表中查找，若存在，则total维持原值，且对应单词count++</span></span><br><span class="line">            <span class="keyword">if</span>(k == total)</span><br><span class="line">                total++;<span class="comment">//若该单词不存在于现有单词表中，total++，表示将其加入单词表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(wordlist, total, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> node), cmp);<span class="comment">//按照字典序排序</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; total; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, wordlist[i].word, wordlist[i].count);</span><br><span class="line">    fclose(in);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>answers</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第八期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%85%AB%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="有关期中考试的强调"><a href="#有关期中考试的强调" class="headerlink" title="有关期中考试的强调"></a>有关期中考试的强调</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>期中考试时间为4月27日晚19:00-21:00，考试时间为2小时。</strong></li>
<li>重视期中考试前的模拟考试，到时候助教会强调与提醒一些内容，请一定牢记。</li>
<li>编程题提交后可看到评测结果，如<strong>“完全正确”</strong>、<strong>“输出错误”</strong>等，但<strong>没有详细错误信息</strong>。</li>
<li>若提交后，发现并不是所有数据点都全对，并且<code>judge</code>平台显示很多<strong>warning</strong>，请一定逐条仔细查看，尽量都修改一下。有些时候，一道题的错因就在这些<strong>warning</strong>里，且一般主要问题都集中在自定义的非<code>void</code>型函数缺少返回值。</li>
<li>选填题目不确定的，就用本地IDE运行一下查看结果，如果是概念题不确定的可以暂时放一放，以编程题为主，毕竟编程题的分值很重。</li>
<li><strong>请一定带上草稿纸、笔、大一上程设教材、大一下数据结构教材！！！</strong>到时候如果需要查询<code>ASCII</code>码表等内容时，可以直接在教材附录查询，<strong>不能上网！！！不能上网！！！不能上网！！！</strong></li>
<li>对于编程题（共两道）：<ul>
<li><strong>千万不要题目没读懂就急着敲代码！！！</strong></li>
<li>在题目中，尤其是<strong>红字标注</strong>的地方或者<strong>题面自身出现的注意事项</strong>，一定要牢记，避免写代码时忘记这些易错点，导致后续排坑浪费掉很多时间（相信大家都有过因为<strong>文件名写错或者输入输出方式写错</strong>而de好几个小时bug、浪费好几个小时的时间的经历吧）。</li>
<li>建议大家读完题目之后，先简要思考一下该用什么<strong>数据结构</strong>，是数组？还是链表？链表是单向的？还是双向的？需不需要使用循环链表？</li>
<li>大家考试时可以多在草稿纸上写一写，<strong>选填题目可以在草稿纸上推一推，编程题目可以在草稿纸上画一画流程图，</strong>这样也可以缓解考场上的紧张情绪。很多时候，题目的逻辑与解题思路清楚了，写代码也就不会东一句西一句。</li>
</ul>
</li>
</ul>
<h3 id="复习要点"><a href="#复习要点" class="headerlink" title="复习要点"></a>复习要点</h3><ul>
<li>考试主要内容对应前三次作业范围，且不涉及文件输入输出，内容不多，重点在于字符串的处理以及线性表（包括数组和链表）。</li>
<li>考试题目类型为：选填共10道（每道0.5分）、编程题2道（<strong>第一题15分，第二题10分</strong>），共30分，<strong>考试得分将全额计入课程总评</strong>。</li>
<li>前三次作业的选填还有不太懂的地方抓紧时间弄懂，可以和同学讨论，也可以来问助教。</li>
<li><strong>编程题一定是重点！！</strong>上机作业里的编程题一定要理解，只有对于每一种操作熟练掌握，才能提高代码的一次性正确率。我们也为大家提供了题解，题解中封装了不少常用操作，希望大家抽时间看看。</li>
<li>老师的授课ppt也是非常重要的，上面有很多基础概念，可以帮助大家做选填题；ppt上也有一些例题的代码，其中的思路和操作也值得大家学习。</li>
<li>平时我们发的资料与老师的授课ppt都汇总在北航云盘里了，我们也在bhpan里共享给了大家，有需要自取：</li>
<li><a class="link"   href="https://bhpan.buaa.edu.cn/link/AE82D268627E33234B178D5416D2AF03" >https://bhpan.buaa.edu.cn:443/link/AE82D268627E33234B178D5416D2AF03 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h3 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h3><ul>
<li>字符串的处理问题在前三次作业中从未缺席，同时也是我们一直在上机时或者课程群里重点强调的问题，我们针对字符串容易出现的<code>bug</code>也出了好多次猪脚说，也希望引起大家的重视。</li>
<li>作业中有关字符串处理的较复杂的编程题，一定要再看看，加深理解，以便在考场上尽快解决相关问题。</li>
<li>如果有些同学在考前想要做额外的题练练手，可以参考之前助教说给出的补充习题。</li>
<li>注意<code>strcpy</code>、<code>strcat</code>等函数的使用条件（包括<strong>内存区域不能重叠、源字符串必须以<code>&#39;\0&#39;</code>结尾</strong>等），如果考试时对于一些字符串处理库函数的细节不太清楚，可查阅《C程序设计引导》的第125页（如果大家还没有把这本书扔掉的话）。</li>
<li>注意**字符串结尾一定要有终止符<code>&#39;\0&#39;</code>**，或者在处理完字符串后，自己手动在末尾加上<code>&#39;\0&#39;</code>，或者初始化将字符输出全部赋值为<code>&#39;\0&#39;</code>。</li>
<li>再次强调<code>\r\n</code>的问题，有不少同学到现在还是会在这个点上犯错，字符串读入时一定要严谨处理，**实在不行就老老实实用<code>gets()</code>**，具体可见课程群聊天记录。</li>
<li>多总结一下平时在自己身上发生的或者向助教提问时助教提醒你的问题，在考试时尽量避免犯相同的错误。</li>
</ul>
<h3 id="关于线性表"><a href="#关于线性表" class="headerlink" title="关于线性表"></a>关于线性表</h3><ul>
<li><strong>前三次作业中出现的涉及链表的编程题，大家一定要理解并掌握！！！</strong></li>
<li>链表的相关操作也是期中考试的考查重点，对于链表的基本操作可以再去复习一下。</li>
<li>不同的链表结构，例如双向链表、循环链表，它们的节点插入、删除等基本操作，在课件里也有，大家如果还有不清楚的地方，可以再把ppt的相关内容过一遍。</li>
<li>在考场上，如果不确定自己写的代码中的链表操作的正确性，不清楚应该先赋值哪个指针、后赋值哪个指针，<strong>建议在草稿纸上画图推算，通过画图来模拟链表的节点插入、删除等操作</strong>，可以使思路更清晰。</li>
<li>我们写的第三次作业题解中，第二题给出了链表操作的示例代码，里面的一些片段或许可以直接封装使用。</li>
<li>再次强调，<strong>链表操作涉及指针时，一定要注意是不是访问了空指针！！！</strong></li>
</ul>
<h3 id="常见编译器警告与错误"><a href="#常见编译器警告与错误" class="headerlink" title="常见编译器警告与错误"></a>常见编译器警告与错误</h3><ul>
<li><code>SIGSEGV</code>：指针使用错误（使用之前一定要初始化以及判断是否访问到了空指针）、栈越界（递归调用时需要注意避免无限递归的存在）、数组访问越界等原因导致。</li>
<li><code>SIGABRT</code>：对一个指针执行连续<code>free操作</code>、<code>free</code>错误的地址、堆越界等原因导致。</li>
<li><code>SIGFPE</code>：算术错误，一般是因为在运算时发生了除以0的运算。</li>
<li><code>Unused Variables</code>：这个警告无关紧要，可以忽略。</li>
<li><code>Function return with no value in non-void functions</code>：这个问题一定要避免并解决！！！</li>
<li><code>Uninitialized variables</code>：一定要改！！！</li>
</ul>
<h2 id="一个奇怪的问题"><a href="#一个奇怪的问题" class="headerlink" title="一个奇怪的问题"></a>一个奇怪的问题</h2><p>同学们在 judge 平台上提交代码的时候，有没有好奇过这个细节？</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets8/截屏2023-04-13 11.05.30.png"
                      alt="截屏2023-04-13 11.05.30" style="zoom:30%;" 
                >

<p>诚然，我们只需要提交 .c 文件即可，想必把这个文件装入文件夹，将文件夹压缩成压缩包交上去，也是可行的。但是，显然不会有人多此一举，交一个仅含有一个文件的压缩包上去。所以很明显，压缩包对应着的，应该是含有多个文件的一个<strong>项目（Project）</strong>。</p>
<p>这时候问题就来了，C 语言项目长什么样呢？或许里面有多个 .c 文件，那还应该有什么呢？我们只实操过单个源代码文件的编译运行，多份源代码文件又要注意什么呢？如果我们把一个程序拆分成多个模块，编译器又要凭借什么把它们组织在一起呢？</p>
<p>我们不妨首先尝试探索，一份 main.c 文件应该怎么<strong>从逻辑上拆分</strong>成各个子模块。</p>
<ul>
<li><p>头文件包含，这是我们调用一些函数所必须的，如<code>printf</code> <code>malloc</code>。</p>
</li>
<li><p>通过<code>#define</code>定义一些<strong>符号常量</strong>，有助于简化代码。</p>
</li>
<li><p>声明结构体、联合等<strong>自定义的复合数据类型</strong>。</p>
</li>
<li><p>声明函数原型。</p>
<blockquote>
<p>特别注意，<strong>函数原型的声明只是给编译器看的</strong>，只是为了让它识别<strong>“有这样一个函数”</strong>。编译过程<strong>顺序扫描</strong>文本，当编译器明白了有这么一个函数之后，在<code>main</code>中调用这个函数就是合法的，调用这个函数后具体怎么执行，靠的是<code>main</code>后面的函数定义，这就无需关心；不写函数原型声明而直接把函数定义在<code>main</code>前面是可行的，这样编译器在读到函数的时候不仅知道了函数的存在性，也知道了它的执行步骤，后续在<code>main</code>中调用自然是可以的，只是<strong>不写函数原型声明，直接把函数定义放在<code>main</code>前面不符合编程规范</strong>。</p>
</blockquote>
</li>
<li><p>全局变量的定义。</p>
</li>
<li><p><code>main</code>函数。这是程序执行的入口。</p>
</li>
<li><p>其他函数的实现。</p>
</li>
</ul>
<p>通过简单的思考我们可以发现，如果<strong>以函数为单位</strong>划分程序，则我们有如下两条原则</p>
<ul>
<li><strong><code>main</code>函数应该单独拎出来考虑</strong>，因为它体现着程序核心的逻辑，程序的运行从它开始、从它结束。</li>
<li><strong>其他函数应该按照功能分组</strong>，如运算类函数一组，字符串操作类函数一组，链表操作类函数一组。</li>
</ul>
<p>以往，我们把所有东西放在一个文件里，大家坦诚相见，在文件开头声明的<code>struct A</code>，可以被每一个函数知道是什么东西。试想如果按照上述的分组思路，把各个模块放进不同的文件里，<code>struct A</code>又要怎么处理呢？为了让每一个文件里的函数都知道<code>struct A</code>，难道要在每个文件的开头都声明一遍吗？</p>
<p>另一方面，我们考虑变量。局部变量，常见的有标记当前位置的<code>pos</code>，表示数据组数的<code>n</code>，用于循环的<code>i</code>和在程序的局部表示某种状态的<code>flag</code>等。事实上，这些变量的作用是<strong>服务于函数自身的实现</strong>，一个函数的局部变量和另一个函数的局部变量并无关联。全局变量则应该在程序全局共享，因为它们有可能是<strong>全局都要访问的某些核心数据结构</strong> —— 比如，在一款音乐播放软件中，歌曲的下载、收藏和历史记录等都会涉及用户账户信息，则这个信息应该处在全局的位置被共享。问题又来了，如果一个程序由多个文件组成，一个全局变量应该定义在哪里呢？</p>
<p>以上描述主要想说明，从一个源代码文件过渡到多文件的项目是有必要且可行的，但存在很多困难，主要有两点：**(1) 如何对原有代码进行拆分；(2) 如何在各个文件间共享必要的信息**。</p>
<h2 id="另一个奇怪的问题"><a href="#另一个奇怪的问题" class="headerlink" title="另一个奇怪的问题"></a>另一个奇怪的问题</h2><blockquote>
<p><strong>悬赏</strong></p>
<p>在你的计算机设备上找到<code>printf</code>函数的源代码，最先找到者请吃一学期疯狂星期四。</p>
</blockquote>
<p>当然，在找之前，不妨先看看下面的文字。</p>
<p>首先给出<code>printf</code>的函数原型。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<p>这里的<code>fmt</code>参数就是格式串，后面的<code>...</code>是 C 的语法，表示<strong>可变参数列表</strong>（以后有机会可以介绍）。我们在<code>fmt</code>中指定要输出的内容，如果是普通字符则直接输出，如果是以<code>%</code>开头的某些特殊内容，则会到后面的参数中寻找并替换，当然也支持保留小数位数、左右对齐等更细节的格式。</p>
<p>同学们心安理得地用了这么久<code>printf</code>，有没有考虑过它是怎么实现的呢？似乎只要<code>#include &lt;stdio.h&gt;</code>，就能随心所欲地调用它了。然而，正因为它被调用得如此频繁，作为一个 C 库函数，它早已被打包成<strong>共享库</strong>，存在于系统文件之中，它的具体的 C 语言代码，是不在系统之中的。</p>
<blockquote>
<p>共享库文件是一个<strong>二进制文件</strong>，其中包含着某些可运行但不可单独运行的代码。当我们编译出hello_world.exe 可执行文件并运行时，运行到<code>printf(&quot;Helllo World\n&quot;);</code>这行代码，系统会跳转去执行共享库中属于<code>printf</code>函数的代码，从而实现了库函数的调用。</p>
</blockquote>
<p>那么，编译器在编译我们的 hello_world.c 文件时，又是如何知道<code>printf</code>的存在呢？答案其实就在<code>&lt;stdio.h&gt;</code>中，这个<strong>头文件（header）</strong>里，包含了<code>printf</code>的原型声明；编译器在<strong>预处理阶段</strong>，会在<code>#include &lt;stdio.h&gt;</code>这一句<strong>预处理指令</strong>的地方，<strong>原封不动地插入<code>&lt;stdio.h&gt;</code>的全部内容</strong>，显然这些内容中包括<code>printf</code>的声明，以及其他我们未用到的函数声明。于是，我们在<code>main</code>的前面有了<code>printf</code>函数的原型，在程序中也就可以调用了。</p>
<p>以前我们提到，**<code>FILE</code>类型是一个结构体，这个结构体及其别名的声明，同样位于<code>&lt;stdio.h&gt;</code>中**，于是我们也可以在包含了这个头文件之后，使用<code>FILE</code>类型。</p>
<blockquote>
<p><code>&lt;stdio.h&gt;</code>局部</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets8/截屏2023-04-13 15.58.05.png"
                      alt="截屏2023-04-13 15.58.05" style="zoom:25%;" 
                >

<p><code>&lt;stdlib.h&gt;</code>局部</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets8/截屏2023-04-13 15.59.25.png"
                      alt="截屏2023-04-13 15.59.25" style="zoom:25%;" 
                >

<p><code>&lt;string.h&gt;</code>局部</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets8/截屏2023-04-13 15.59.49.png"
                      alt="截屏2023-04-13 15.59.49" style="zoom:25%;" 
                >
</blockquote>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h3 id="宏的定义与类型声明"><a href="#宏的定义与类型声明" class="headerlink" title="宏的定义与类型声明"></a>宏的定义与类型声明</h3><p>有了这样的观念，我们就可以尝试编写自己的头文件了。当然，如果要使用头文件，我们最好在 IDE 中先新建一个项目，这个项目一般会默认有一个 main.c，然后我们在同一个<strong>目录（即文件夹，以后统称目录）</strong>下新建一个<code>myheader.h</code>。</p>
<blockquote>
<p>实际上，<strong>头文件的后缀名是不重要的</strong>。C 的传统风格的头文件都是 .h 后缀，C++ 则另起炉灶。在 C++ 中，原有的 C 头文件基本兼容，名字都以 c 打头且没有后缀，如 <code>&lt;cstdio&gt;</code> <code>&lt;cstdlib&gt;</code> <code>&lt;cstring&gt;</code>，当然包含原有的 C 头文件也可以，因为它们都在系统之中。C++ 也有自己独有的头文件，如 <code>&lt;queue&gt;</code> <code>&lt;stack&gt;</code> <code>&lt;algorithm&gt;</code> <code>&lt;iostream&gt;</code>等。</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myheader.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">  <span class="comment">// 在自己的头文件中可以包含其他头文件</span></span><br><span class="line">  <span class="comment">// 这里我们要使用 FILE 类型，所以要包含 stdio.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 32</span></span><br><span class="line">  <span class="comment">// 在自己的头文件中可以定义宏</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">char</span> content[MAX_LEN];</span><br><span class="line">&#125; Word;</span><br><span class="line">  <span class="comment">// 在自己的头文件中可以声明自定义复合数据类型</span></span><br></pre></td></tr></table></figure></div>

<p>这样，如果我们要在 main.c 中使用<code>MAX_LEN</code>宏或<code>Word</code>类型，只需要在 main.c 开头包含<code>myheader.h</code>头文件即可：<code>#include &quot;myheader.h&quot;</code>。</p>
<blockquote>
<p>头文件名可以用<code>&lt;&gt;</code>也可以用<code>&quot;&quot;</code>括起来，区别在于：<strong>尖括号一般用于系统的头文件</strong>，在查找时会首先到系统的库中查找，找不到时才在项目目录中查找；<strong>双引号一般用于自定义头文件</strong>，会优先在当前项目中查找。</p>
</blockquote>
<h3 id="函数声明与实现"><a href="#函数声明与实现" class="headerlink" title="函数声明与实现"></a>函数声明与实现</h3><p>我们也可以<strong>在头文件中声明函数原型，在其他的源代码文件中实现该函数。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 myheader.h 中插入</span></span><br><span class="line">Word *<span class="title function_">create_word</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="comment">// 这个函数创建一个 Word 结构体并返回其指针</span></span><br><span class="line"><span class="comment">// 将其中的文件指针设置为 NULL，cnt 设置为 0</span></span><br><span class="line"><span class="comment">// 将 content 数组填满字符 c</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在项目中新建 myheader.c 源代码文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span> <span class="comment">// 我们会用到其中的 Word 类型、MAX_LEN 宏</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   <span class="comment">// 我们在实现 create_word 时会用到 malloc 函数</span></span></span><br><span class="line">Word *<span class="title function_">create_word</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    Word *p = (Word*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Word));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// malloc 出错返回 NULL</span></span><br><span class="line">    p-&gt;fp = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LEN; i++) p-&gt;content[i] = c;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 main.c 中可以测试，<strong>在项目中执行编译</strong>会把多个源代码文件联合起来编译，但只能有一个函数叫做<code>main</code>，它仍是程序的入口。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Word *word = create_word(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (word != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        word-&gt;content[MAX_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 使之变成一个字符串</span></span><br><span class="line">        <span class="keyword">if</span> (word-&gt;fp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;word-&gt;fp is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (word-&gt;cnt == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;word-&gt;cnt is 0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;word-&gt;content: %s\n&quot;</span>, word-&gt;content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>我们知道，在多数情况下，<strong>同一个变量是不能定义多次的</strong>，如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="type">int</span> a;     <span class="comment">// 全局变量 a</span></span><br><span class="line"><span class="comment">// int a;  // 再次定义全局的 a 就会出错</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// 定义局部的 a 可以，此时无法在 main 中访问全局的 a</span></span><br><span class="line">    <span class="comment">// int i;   // 再次定义局部的 i 就会出错</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++);</span><br><span class="line">      <span class="comment">// 这个 i 属于 for 循环，仅在循环内有效，这个 i 会屏蔽掉 main 的局部的 i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>头文件解决全局变量问题的思路是，<strong>在头文件中声明某个全局变量的存在，在某一个源代码文件中的全局的位置定义该全局变量，在所有用到该全局变量的源代码文件中都应先包含头文件</strong>。例如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myheader.h 中插入</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global;</span><br><span class="line"><span class="comment">// extern 关键字告诉编译器，我的程序中会有一个全局变量</span></span><br><span class="line"><span class="comment">// 它的类型是 int，名字叫 global</span></span><br><span class="line"><span class="comment">// 显然 extern 只是声明全局变量的存在，不能在此时初始化</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myheader.c 文件第一行插入</span></span><br><span class="line"><span class="type">int</span> global = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 在某一处定义了该全局变量</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c 的 main 函数中访问该全局变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;global = %d\n&quot;</span>, global);</span><br></pre></td></tr></table></figure></div>

<h3 id="静态变量和函数"><a href="#静态变量和函数" class="headerlink" title="静态变量和函数"></a>静态变量和函数</h3><p>考虑这样一个情形，现在需要开发一个银行管理系统，其中，存款、取款、查看余额等函数已经写好，实现在 bank.c 中，并且声明在 bank.h 中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bank.h</span></span><br><span class="line">“账户”结构体声明</span><br><span class="line">存款函数声明</span><br><span class="line">取款函数声明</span><br><span class="line">查看余额函数声明</span><br><span class="line">添加账户函数声明</span><br><span class="line">删除账号函数声明</span><br><span class="line"><span class="comment">// bank.c</span></span><br><span class="line">存款函数实现</span><br><span class="line">取款函数实现</span><br><span class="line">查看余额函数实现</span><br><span class="line">添加账户函数实现</span><br><span class="line">删除账号函数实现</span><br></pre></td></tr></table></figure></div>

<p>现在我们请人为我们在 main.c 中实现这个系统的图形界面，如点击某个按钮就可以查看余额等。试想，我们应该仅把 bank.h 文件交给对方，这样对方就能知道如何调用函数了。多个银行客户的信息应当存放在一个“账户”类型的结构体数组中，<strong>如果由对方在 main.c 中创建这个全局变量，则可以在 main.c 中任意地访问这个数组，直接操作银行客户的数据，这是我们不可接受的</strong>。</p>
<p>实际上，如果把这个数组当成全局变量，就必然会存在上述问题。我们希望<strong>在 bank.c 中的每一个函数内</strong>，都能访问该数组，但又<strong>不希望它被 main.c 访问</strong>，因为 main.c 只需要调用 bank.c 的函数并接收其返回值即可。这就需要 bank.c 中有一个<strong>仅属于该文件的、并且是全局性质的变量</strong>。</p>
<p><strong>用<code>static</code>关键字修饰全局变量，则这个变量的全局性仅限于某一个文件。</strong>具体来说，在上述例子中，我们可以在 bank.c 的开头定义</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> Account accounts[<span class="number">100</span>];</span><br></pre></td></tr></table></figure></div>

<p>这样，这个数组可以被 bank.c 中的每一个函数访问，但不能被其他文件的函数访问。我们可以把 bank.c 单独编译封装为一个模块，未来在 main.c 编写完毕后与之一同编译产生最终的可执行文件。<strong>main.c 请第三方人员编写，它们只需要根据头文件中的函数原型进行调用，而无法操作到客户账户的数据。</strong></p>
<blockquote>
<p><code>static</code>关键字也可以用来修饰函数，被它修饰的函数仅在本文件内有效。</p>
</blockquote>
<p>例如，我们之前实现过可变长数组的封装，其中的增删改查等函数是由用户调用的，但是，数组的生长函数应该由“增”函数自动调用，而不应该开放给用户，此时在 array.c 中就可以这么写</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">array_grow</span><span class="params">(<span class="type">array_t</span> *arr)</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_addtail</span><span class="params">(<span class="type">array_t</span> *arr, <span class="type">int</span> var)</span> &#123;</span><br><span class="line">    <span class="comment">// call array_grow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>再比如，我们要用栈实现一个计算器并封装，我们希望调用方式是</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;result: %d\n&quot;</span>, calculate(<span class="string">&quot;3 + 4 * (5 / 2) - 1&quot;</span>));</span><br></pre></td></tr></table></figure></div>

<p>则我们可以在 calculator.c 中组织</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="built_in">stack</span>[<span class="number">105</span>];</span><br><span class="line">    <span class="comment">// 静态的全局变量，仅在此文件中可以访问，main 不能直接操作它</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 静态的全局变量，仅在此文件中可以访问，main 不能直接操作它</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123; </span><br><span class="line">    <span class="comment">/* 计算表达式 s 的结果 */</span> </span><br><span class="line">    <span class="comment">// 这个函数是给用户调用的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">char</span> op)</span> &#123;</span><br><span class="line">    <span class="comment">/* 判断运算符优先级*/</span></span><br><span class="line">    <span class="comment">// 仅在本文件内有效，由 calculate 调用，以下四个函数同理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a - b; &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a * b; &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a / b; &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h3><p><strong>声明重复多次是可以的，但是定义则不可以。</strong>很多情况下，一个头文件会在一个项目的多个文件中被重复包含多次，这很可能产生错误。事实上，考虑到<code>#include</code>的展开文本的本质，我们只希望<strong>头文件的内容在项目中仅被展开一次</strong>，这就需要用到<strong>头文件保护符</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _NAME_H_ <span class="comment">// 如果未定义标识符 _NAME_H_</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NAME_H_ <span class="comment">// 则定义标识符 _NAME_H_</span></span></span><br><span class="line"><span class="comment">// 头文件正文</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>           <span class="comment">// 结束上述 if 判断</span></span></span><br><span class="line"><span class="comment">/* 三条预处理指令的逻辑:</span></span><br><span class="line"><span class="comment">  if not define xx &#123;</span></span><br><span class="line"><span class="comment">      define xx</span></span><br><span class="line"><span class="comment">      extend contents</span></span><br><span class="line"><span class="comment">  &#125; */</span></span><br></pre></td></tr></table></figure></div>

<p>首先说明，这里的<code>_NAME_H_</code>只是惯用的写法，例如在<code>&lt;string.h&gt;</code>中就会用到<code>_STRING_H_</code>这个标识符。以上三条指令的直接翻译已经注释，当我们在项目中重复包含一个头文件时，<strong>预处理阶段</strong>第一次碰到这个头文件，发现<code>_NAME_H_</code>是<strong>未定义</strong>的（显然这么个奇奇怪怪的符号不太可能在之前被就你<code>#define</code>过），则判断条件成立，执行第二句<code>#define</code>语句，也就定义了这个符号，随后展开了头文件正文，结束条件判断。此后如果再碰到需要包含这个头文件的地方，会先判断<code>_NAME_H_</code>是否定义，结果是已经定义过了，则直接跳到<code>#endif</code>处，而不会再展开了。</p>
<p><strong>头文件保护符加在头文件的头尾，是推荐使用的例行编码习惯。</strong></p>
<h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><blockquote>
<p>实现一个银行存款和查看余额模拟。项目中有 test.c(测试)，bank.c，bank.h 三个文件。</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bank.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BANK_H_                <span class="comment">// 头文件保护符，这是例行写法</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BANK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ID_LENGTH 10  <span class="comment">// 定义账户 ID 号最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CNT_MAX 100   <span class="comment">// 定义最多有 100 个账户</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>         <span class="comment">// 声明账户类型</span></span><br><span class="line">    <span class="type">char</span> id[ID_LENGTH];  <span class="comment">// 账户 ID 号</span></span><br><span class="line">    <span class="type">int</span> balance;         <span class="comment">// 账户余额</span></span><br><span class="line">&#125; Account;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_account</span><span class="params">(<span class="type">char</span> *id)</span>;     <span class="comment">// 添加新账户</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *id, <span class="type">int</span> money)</span>; <span class="comment">// 往账户 id 中存款 money</span></span><br><span class="line">Account <span class="title function_">get_idx</span><span class="params">(<span class="type">int</span> idx)</span>;       <span class="comment">// 获取下标为 idx 的账户</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_num</span><span class="params">()</span>;                  <span class="comment">// 获取账户数量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bank.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bank.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// 要用到 strcmp 查找账户</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Account accounts[CNT_MAX]; <span class="comment">// 静态的 Account 数组，仅本文件访问</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;               <span class="comment">// 账户数量计数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_account</span><span class="params">(<span class="type">char</span> *id)</span> &#123;      <span class="comment">// 在数组尾部添加元素</span></span><br><span class="line">    <span class="built_in">strcpy</span>(accounts[cnt].id, id);</span><br><span class="line">    accounts[cnt].balance = <span class="number">0</span>;    <span class="comment">// 初始化余额为 0</span></span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *id, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(id, accounts[i].id) == <span class="number">0</span>) &#123; <span class="comment">// 找到账户</span></span><br><span class="line">            accounts[i].balance += money;      <span class="comment">// 存款</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Account <span class="title function_">get_idx</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> accounts[idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_num</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bank.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 【注意】main 中不能直接访问 bank.c 的那个 accounts</span></span><br><span class="line">    <span class="comment">//  请不要忽视这个权限问题，这是具有非凡意义的一个特性</span></span><br><span class="line">    </span><br><span class="line">    add_account(<span class="string">&quot;0001&quot;</span>);</span><br><span class="line">    add_account(<span class="string">&quot;0002&quot;</span>);</span><br><span class="line">    add_account(<span class="string">&quot;0003&quot;</span>);</span><br><span class="line">    save(<span class="string">&quot;0001&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    save(<span class="string">&quot;0001&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">    save(<span class="string">&quot;0003&quot;</span>, <span class="number">4500</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; get_num(); i++) &#123;</span><br><span class="line">        Account a = get_idx(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s] balance: %d\n&quot;</span>, a.id, a.balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>mid-test</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第九期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%B9%9D%E6%9C%9F/</url>
    <content><![CDATA[<blockquote>
<p>老规矩：若针对这些题目，同学们有更好更简洁的方法，欢迎来找助教讨论，助教请喝奶茶😍😍。</p>
</blockquote>
<p>题外话：同学们对前面的题解没有多大反应啊。也不知道有问题的同学看懂了没有。我们欢迎大家随时与我们讨论。事实上，进入栈和队列以及后续学习之后，编程题的思维难度并不大，只要弄清楚细节问题，其本质上都是相关数据结构的基本操作。</p>
<h2 id="栈操作（栈-基本题）"><a href="#栈操作（栈-基本题）" class="headerlink" title="栈操作（栈-基本题）"></a>栈操作（栈-基本题）</h2><p>本题是非常基础的栈操作题，主要目的是让大家熟悉栈的操作。基本的出栈、入栈操作可以封装成函数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 101</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zhan</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> pointer;</span><br><span class="line">&#125;stem;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pushzhan</span><span class="params">(<span class="keyword">struct</span> zhan *s, <span class="type">int</span> digit)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;pointer == MAXSIZE)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//如果栈满，则输出error</span></span><br><span class="line">    s-&gt;pointer++;</span><br><span class="line">    s-&gt;num[s-&gt;pointer]=digit;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//入栈操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quitzhan</span><span class="params">(<span class="keyword">struct</span> zhan *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;pointer == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//若栈空</span></span><br><span class="line">    <span class="type">int</span> digit = s-&gt;num[s-&gt;pointer];</span><br><span class="line">    s-&gt;pointer--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, digit);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> op, follow;</span><br><span class="line">    stem.pointer=<span class="number">-1</span>;<span class="comment">//初始化栈顶</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">0</span>)</span><br><span class="line">            quitzhan(&amp;stem);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;follow);</span><br><span class="line">            pushzhan(&amp;stem, follow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="C程序括号匹配检查"><a href="#C程序括号匹配检查" class="headerlink" title="C程序括号匹配检查"></a>C程序括号匹配检查</h2><ul>
<li><p>这道题其实是很基本的出、入栈操作练习题，难度不大，但要考虑的细节非常多，另外注意转义字符。</p>
<ul>
<li>不处理括号：<ul>
<li>字符常量：<code>&#39;(&#39;</code></li>
<li>字符串常量：<code>&quot;( in string&quot;</code></li>
<li>单行注释：<code>// ( in single-line comment</code></li>
<li>多行注释：<code>/* ( in multi-line comment */</code></li>
</ul>
</li>
<li>错误优先级：<ul>
<li><code>&#123;&#125;</code>不能在<code>()</code>中</li>
<li>右括号无匹配的左括号</li>
<li>最后剩余为匹配的左括号</li>
</ul>
</li>
<li>其他细节问题：<ul>
<li>保存括号的同时需要保存括号所在行数，或者使用<code>count</code>变量，每读一行<code>count++</code>，当读到第一个不匹配的括号时，直接跳出所有循环（因为该题中不匹配括号只有一个）进行输出，题解代码采取后一种思路。且需要注意：就算是多行注释或空行内容，行数也是要对应增加的</li>
<li>应该使用一种方式（如另定义一个数组）存储所有括号，以便在全部匹配时进行输出</li>
</ul>
</li>
</ul>
</li>
<li><p>解释一下参考代码中的几个变量：</p>
<ul>
<li><code>isErr</code>：是否错误（已判断出不匹配的字符）</li>
<li><code>isStr1</code>：是否在字符串中</li>
<li><code>isStr2</code>：是否在字符中</li>
<li><code>isCmnt1</code>：是否在单行注释中</li>
<li><code>isCmnt2</code>：是否在多行注释中</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> line;</span><br><span class="line">&#125;st[<span class="number">210</span>];<span class="comment">//括号栈</span></span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *in = fopen(<span class="string">&quot;example.c&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">tmp</span>;</span></span><br><span class="line">    <span class="type">char</span> s[<span class="number">201</span>]=&#123;<span class="number">0</span>&#125;, save[<span class="number">201</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//save数组记录已匹配的括号，用于最后输出</span></span><br><span class="line">    <span class="type">int</span> i, j, k=<span class="number">0</span>, count=<span class="number">0</span>, isErr=<span class="number">0</span>, isStr1=<span class="number">0</span>, isStr2=<span class="number">0</span>, isCmnt1=<span class="number">0</span>, isCmnt2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fgets(s,<span class="number">200</span>,in)!=<span class="literal">NULL</span> &amp;&amp; !isErr)&#123;<span class="comment">//当前没有判断到未匹配符号时，才继续读入</span></span><br><span class="line">        count++;<span class="comment">//成功读入后，count再执行++操作</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; s[j]!=<span class="string">&#x27;\0&#x27;</span> &amp;&amp; !isErr; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isStr1 &amp;&amp; s[j] != <span class="string">&#x27;\&quot;&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//如果在字符串或字符串常量中则跳过当前字符</span></span><br><span class="line">            <span class="keyword">if</span>(isStr2 &amp;&amp; s[j] != <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//如果在字符或字符常量中则跳过当前字符</span></span><br><span class="line">            <span class="keyword">if</span>(isCmnt1)&#123;</span><br><span class="line">                isCmnt1 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//如果是单行注释则跳过本行</span></span><br><span class="line">            <span class="keyword">if</span>(isCmnt2 &amp;&amp; (s[j] != <span class="string">&#x27;*&#x27;</span> || s[j+<span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//如果在多行注释中则跳过当前字符</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                isCmnt2 = <span class="number">0</span>;</span><br><span class="line">            tmp.ch = s[j];</span><br><span class="line">            tmp.line = count;</span><br><span class="line">            <span class="keyword">switch</span> (s[j])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    save[k++] = s[j];</span><br><span class="line">                    st[++top] = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//左括号直接入栈</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    save[k++] = s[j];</span><br><span class="line">                    <span class="keyword">if</span> (top &lt; <span class="number">0</span> || st[top].ch != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        st[++top] = tmp;</span><br><span class="line">                        isErr = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="comment">//由于每一对左、右小括号、左、右大括号已经弹出，因此右括号之前若还有除左括号之外的括号，则该右括号不匹配</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        top--;<span class="comment">//右括号与左括号匹配成功，则右括号不入栈，同时弹出左括号</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                    save[k++] = s[j];</span><br><span class="line">                    <span class="keyword">if</span> (st[top].ch == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        isErr = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="comment">//大括号不能出现在小括号中</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        st[++top] = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    save[k++] = s[j];</span><br><span class="line">                    <span class="keyword">if</span> (top &lt; <span class="number">0</span> || st[top].ch != <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                        st[++top] = tmp;</span><br><span class="line">                        isErr = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        top--;<span class="comment">//匹配成功，消除左、右大括号</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\&quot;&#x27;</span>:</span><br><span class="line">                    isStr1 ^= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>:</span><br><span class="line">                    isStr2 ^= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//使用按位异或运算判断是否是成对的单引号或双引号</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> (s[j+<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                        isCmnt1 = <span class="number">1</span>;<span class="comment">//单行注释</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (s[j+<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                        isCmnt2 = <span class="number">1</span>;<span class="comment">//多行注释</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top &gt;= <span class="number">0</span>)<span class="comment">//栈顶即为未匹配字符</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;without maching \&#x27;%c\&#x27; at line %d&quot;</span>, st[top].ch, st[top].line);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, save[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="计算器（表达式计算-后缀表达式实现，结果为浮点）"><a href="#计算器（表达式计算-后缀表达式实现，结果为浮点）" class="headerlink" title="计算器（表达式计算-后缀表达式实现，结果为浮点）"></a>计算器（表达式计算-后缀表达式实现，结果为浮点）</h2><ul>
<li>中缀表达式转后缀表达式的模版题，这里直接给出一个模版，已封装成<code>Change(char s[])</code>函数</li>
<li>注意运算符优先级的问题，一定要认真学习转后缀的思想和方法</li>
<li>本题还可以将括号中的内容看作子表达式，采用递归的方法求值，且该递归思想常用于后缀转中缀</li>
<li>注意本题为浮点数运算，定义数据类型的时候一定要写对</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> top=<span class="number">-1</span>;</span><br><span class="line"><span class="type">double</span> num[<span class="number">201</span>], ans[<span class="number">201</span>];</span><br><span class="line"><span class="type">char</span> op[<span class="number">201</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Change</span><span class="params">(<span class="type">char</span> s[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j=<span class="number">0</span>, stacktop=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>;)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">            num[j] = num[j] * <span class="number">10</span> + s[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="built_in">stack</span>[++stacktop] = s[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stacktop &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>[stacktop] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    op[j++] = <span class="built_in">stack</span>[stacktop--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>[++stacktop] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stacktop &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>[stacktop]==<span class="string">&#x27;(&#x27;</span>||<span class="built_in">stack</span>[stacktop]==<span class="string">&#x27;+&#x27;</span>||<span class="built_in">stack</span>[stacktop]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    op[j++] = <span class="built_in">stack</span>[stacktop--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>[++stacktop] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">stack</span>[stacktop] != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                op[j++] = <span class="built_in">stack</span>[stacktop--];</span><br><span class="line">            stacktop--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stacktop&gt;<span class="number">-1</span>)</span><br><span class="line">        op[j++] = <span class="built_in">stack</span>[stacktop--];</span><br><span class="line">&#125;<span class="comment">//将一个中缀表达式s数组转化成后缀表达式；</span></span><br><span class="line"> <span class="comment">//数字存储在num中，运算符存储在op中，且按顺序存储，例如 1+2= 的存储方式为：</span></span><br><span class="line"> <span class="comment">//num[0]=1, num[1]=&#x27;2&#x27;, op[2]=&#x27;+&#x27;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> x[<span class="number">201</span>]=&#123;<span class="number">0</span>&#125;, s[<span class="number">201</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(x);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; x[i] != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; x[i] != <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">            s[j++] = x[i];</span><br><span class="line">    &#125;<span class="comment">//消除x数组中的空格，存储与s数组中</span></span><br><span class="line">    s[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    Change(s);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            top++;</span><br><span class="line">            ans[top] = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[i] != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(op[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    ans[top<span class="number">-1</span>] = ans[top<span class="number">-1</span>] + ans[top];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    ans[top<span class="number">-1</span>] = ans[top<span class="number">-1</span>] - ans[top];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    ans[top<span class="number">-1</span>] = ans[top<span class="number">-1</span>] * ans[top];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    ans[top<span class="number">-1</span>] = ans[top<span class="number">-1</span>] / ans[top];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[top] = <span class="number">0</span>;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num[i] == <span class="number">0</span> &amp;&amp; op[i] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="comment">//基于出、入栈思想对后缀表达式进行运算</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, ans[top]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="文本编辑操作模拟（简）"><a href="#文本编辑操作模拟（简）" class="headerlink" title="文本编辑操作模拟（简）"></a>文本编辑操作模拟（简）</h2><p><strong>重大灾难区</strong>，<del>助教看到这题就想吐</del>，主要错误集中在：</p>
<ul>
<li><p>最最最重要的！字符串操作不注意结束符<code>&#39;\0&#39;</code>，使用字符串处理库函数不知道使用规则</p>
<p>  <del>（究竟多难忘～眼中的对方～是火山呢还是一座宝藏～）——歌曲《最最重要》</del></p>
<p>  <del>一键查询助教精神状态</del></p>
</li>
<li><p>在插入和删除函数里定义了局部数组然后返回。局部数组是不可以作为函数的返回值的！！！如果要返回一个字符数组，则需使用<code>malloc</code>动态分配一块空间，这块空间可作为函数返回值</p>
</li>
<li><p>部分同学在插入和删除操作时，将记录操作子串的字符数组改变了。那么在执行撤销操作的时候，自然会出问题，推荐做法为将每一次操作的结果都保存在结构体数组中</p>
</li>
<li><p>需要注意，如果多次输入操作3（即撤销操作），需要判断是否已经没有操作可以撤销（此时应该什么都不变），因此此题最好还是使用栈实现，当栈为空时，什么操作都不执行即可</p>
</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 515</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zhan</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="type">char</span> str[MAXSIZE];</span><br><span class="line">    <span class="type">char</span> final[MAXSIZE];</span><br><span class="line">&#125;oper[MAXSIZE];<span class="comment">//str数组为操作时输入的字符串，final数组为当前操作完成后，应储存的总字符串；</span></span><br><span class="line">               <span class="comment">//oper数组中每一个元素都对应一次操作，无论是插入还是删除，只有撤销时才退栈</span></span><br><span class="line"><span class="type">int</span> Top=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_oper</span><span class="params">(<span class="type">int</span> pos, <span class="type">char</span> str[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="built_in">strcpy</span>(oper[Top].final, oper[Top<span class="number">-1</span>].final);</span><br><span class="line">    <span class="built_in">strcpy</span>(oper[Top].final+pos, str);</span><br><span class="line">    <span class="built_in">strcpy</span>(oper[Top].final+pos+len, oper[Top<span class="number">-1</span>].final+pos);<span class="comment">//请理解通过strcpy函数实现插入</span></span><br><span class="line">&#125;<span class="comment">//插入操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_oper</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    len = <span class="built_in">strlen</span>(oper[Top<span class="number">-1</span>].final);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len-pos)</span><br><span class="line">        n = len-pos;<span class="comment">//若需要删除的个数大于之后字符的总个数，则全部删完即可</span></span><br><span class="line">    <span class="built_in">strcpy</span>(oper[Top].final, oper[Top<span class="number">-1</span>].final);</span><br><span class="line">    <span class="built_in">strcpy</span>(oper[Top].final+pos, oper[Top<span class="number">-1</span>].final+pos+n);<span class="comment">//请理解通过strcpy函数实现删除</span></span><br><span class="line">    oper[Top].final[len-n] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//一定要注意&#x27;\0&#x27;的处理</span></span><br><span class="line">&#125;<span class="comment">//删除操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">return_insert_oper</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    len = <span class="built_in">strlen</span>(oper[Top+<span class="number">1</span>].final);</span><br><span class="line">    <span class="built_in">strcpy</span>(oper[Top].final, oper[Top+<span class="number">1</span>].final);</span><br><span class="line">    <span class="built_in">strcpy</span>(oper[Top].final+pos, oper[Top+<span class="number">1</span>].final+pos+n);</span><br><span class="line">    oper[Top].final[len-n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;<span class="comment">//撤销插入操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">return_delete_oper</span><span class="params">(<span class="type">int</span> pos, <span class="type">char</span> str[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="built_in">strcpy</span>(oper[Top].final, oper[Top+<span class="number">1</span>].final);</span><br><span class="line">    <span class="built_in">strcpy</span>(oper[Top].final+pos, str);</span><br><span class="line">    <span class="built_in">strcpy</span>(oper[Top].final+pos+len, oper[Top+<span class="number">1</span>].final+pos);</span><br><span class="line">&#125;<span class="comment">//撤销删除操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[MAXSIZE]=&#123;<span class="number">0</span>&#125;, str1[MAXSIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, n, op1, pos1, n1, len1;</span><br><span class="line">    fgets(s, <span class="number">515</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        Top++;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s&quot;</span>, &amp;oper[Top].op, &amp;oper[Top].pos, oper[Top].str);</span><br><span class="line">    &#125;<span class="comment">//将已经执行过的操作存储在结构体中</span></span><br><span class="line">    <span class="built_in">strcpy</span>(oper[Top].final, s);<span class="comment">//此时栈顶操作完后，储存的总字符串即为s数组</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(str1, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));<span class="comment">//一定要初始化！</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op1);</span><br><span class="line">        <span class="keyword">if</span>(op1 == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(oper[Top].final);<span class="comment">//直接输出栈顶储存的总字符串，即为最终字符串</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op1 == <span class="number">1</span>)&#123;</span><br><span class="line">            Top++;<span class="comment">//除了撤销的操作，都入栈</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>, &amp;pos1, str1);</span><br><span class="line">            insert_oper(pos1, str1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op1 == <span class="number">2</span>)&#123;</span><br><span class="line">            Top++;<span class="comment">//除了撤销的操作，都入栈</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;pos1, &amp;n1);</span><br><span class="line">            delete_oper(pos1, n1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op1 == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Top == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//若撤销之前本身没有任何操作，则什么都不用执行，直接continue</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(Top &gt; n)<span class="comment">//此时已存在现有操作，则直接退栈</span></span><br><span class="line">                Top--;<span class="comment">//执行撤销操作时，退栈</span></span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//当没有任何现有操作而执行撤销时，则需逆向已有操作处理</span></span><br><span class="line">                <span class="keyword">if</span>(oper[Top].op == <span class="number">1</span>)&#123;</span><br><span class="line">                    Top--;</span><br><span class="line">                    len1 = <span class="built_in">strlen</span>(oper[Top+<span class="number">1</span>].str);</span><br><span class="line">                    return_insert_oper(oper[Top+<span class="number">1</span>].pos, len1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(oper[Top].op == <span class="number">2</span>)&#123;</span><br><span class="line">                    Top--;</span><br><span class="line">                    return_delete_oper(oper[Top+<span class="number">1</span>].pos, oper[Top+<span class="number">1</span>].str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="银行排队模拟（生产者-消费者模拟）"><a href="#银行排队模拟（生产者-消费者模拟）" class="headerlink" title="银行排队模拟（生产者-消费者模拟）"></a>银行排队模拟（生产者-消费者模拟）</h2><p>这道题确实非常考验大家的理解能力，以及对细节的把握程度，以及对队列的掌握情况。</p>
<p>解决复杂的题目，实质上是一个翻译过程，即将题目表述和每一处细节翻译成代码，因此建议大家画流程图。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Users/diandian/Documents/助教/周报:讲解/第九次/表白信.png"
                      alt="表白信" style="zoom:67%;" 
                >

<p>上面这张图非常完整地体现了该题的整个流程，如果还有不清楚的同学可以结合这张图想一想。易错点为：</p>
<ul>
<li><p>在没有新客户来的时候，是不需要增加窗口的；在没有人接受服务的时候，是不需要减少窗口的</p>
</li>
<li><p>在减少窗口时，只考虑当前减少窗口的逻辑，而不需要考虑减少后的结果，否则将陷入死循环。例如当前有三个窗口，一共有25个人，<code>25 / 3 &gt; 7</code>，这时需要增加窗口，<strong>但增加窗口后又考虑平均人数小于7而减少窗口是不必要的</strong></p>
</li>
<li><p>所有客户全部到来后，之后的所有周期都是没有客户到来的，因此这些后续周期不能增加窗口；也有可能某些周期的所有窗口都正在服务复杂业务，导致没有新的客户接受服务，则此时是不需要减少窗口的</p>
</li>
<li><p>一个客户，不论他的业务类型需要被服务多少个周期，他的等待周期的计数在他接受服务的那一刻起就停止了，也就意味着，当前队列的等待人数是不包括正在接受服务的客户的</p>
</li>
<li><p>举一个例子，假设最后一个周期到来了5位客户，此时算上这5位客户，还在等待的人一共有38位。显然需要开设5个窗口。假设这些窗口都服务的是简单业务，则在当前周期结束后，等待的人数还有33人，此时应减少一个窗口，还剩下4个窗口。所以说，有些同学简单通过<code>33 / 4 &gt; 7</code>来判断此时应该开5个窗口是错误的</p>
</li>
<li><p>另外，这道题对于窗口的增减确实比较繁琐，大家在编写代码时涉及到窗口增减的操作时，一定要注意是总开放窗口还是可用窗口。对于结构体来说，可以代表人，也可以代表窗口。</p>
</li>
<li><pre><code class="C">  #include &lt;stdio.h&gt;
  struct Node&#123;
      int timein;//入队时间
      int timeout;//出对时间
      int type;//业务类型
  &#125;people[801];
  int judge, front=0, rear=-1, window=3, win_able=3;
  void print(int i)&#123;
      int j;
      judge=0;//judge变量用于判断当前周期是否有客户接受服务
      for(j=0;j&lt;win_able;j++)&#123;
          judge=1;//若有客户接受服务，则置为1
          if(rear+1==front)
              break;
          people[front++].timeout=i;//一旦客户接受服务，则等待时间的计数已经停止，至于他需要被服务多久，是不算进等待时间里的
          printf(&quot;%d : %d\n&quot;, front, i-people[front-1].timein);
      &#125;//只有可用的窗口可以去服务用户
      win_able=window;
      for(j=0;j&lt;front;j++)&#123;
          if(people[j].type&gt;0)
              people[j].type--;
      &#125;//过了一个周期，所有业务类型--
      for(j=0;j&lt;front;j++)&#123;
          if(people[j].type&gt;0)&#123;
              win_able--;
              if(win_able==0)
                  break;//可用窗口为0，则不用再--了
          &#125;
      &#125;//从最开始到现在为止接受过服务的人，有多少人类型不为0，则代表有多少个窗口是不可用的
  &#125;
  int main() &#123;
      int i, j, k=0, n, num[51]=&#123;0&#125;, flag[51]=&#123;0&#125;;
      scanf(&quot;%d&quot;, &amp;n);
      for(i=0;i&lt;n;i++)&#123;
          scanf(&quot;%d&quot;, &amp;num[i]);
          if(num[i]==0)
              flag[i]=1;
      &#125;
      for(i=0;i&lt;n;i++)&#123;
          for(j=0;j&lt;num[i];j++)
              scanf(&quot;%d&quot;, &amp;people[k++].type);
      &#125;//先完成全部的输入数据的存储
      for(j=0;flag[j];j++);//找到第一个有客户到来的周期
      for(i=j;i&lt;n;i++)&#123;
          for(k=0;k&lt;num[i];k++)
              people[++rear].timein=i;//此客户的入队时间一定与当前大循环的循环变量值相同
          while(((rear-front+1)/window&gt;=7)&amp;&amp;(window&lt;5)&amp;&amp;(!flag[i]))&#123;
              window++;
              win_able++;
          &#125;//判断是否需要开设新窗口，开设新窗口时，可用窗口也跟着变多，但不能超过5个
          print(i);
          while(((rear-front+1)/window&lt;7)&amp;&amp;(window&gt;3)&amp;&amp;judge)&#123;
              window--;
              win_able--;
          &#125;//判断是否需要关闭窗口，但不能关闭已有窗口，即不能小于3个
      &#125;//对每一个时间周期单独处理
      while(front&lt;rear+1)&#123;
          print(i);
          while(((rear-front+1)/window&lt;7)&amp;&amp;(window&gt;3)&amp;&amp;judge)&#123;
              window--;
              win_able--;
          &#125;
          i++;
      &#125;//有客户到来的时间周期结束，还有在队列中的人，再进行出队操作
      return 0;
  &#125;
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 函数调用关系</span><br><span class="line"></span><br><span class="line">~~本题为2020级期末考试真题~~</span><br><span class="line"></span><br><span class="line">本题难度并不大，主要坑点在题面中也已经用红字标注。</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">struct function&#123;</span><br><span class="line">    char name[21];</span><br><span class="line">    char division[11][21];</span><br><span class="line">    int count;//该主函数下调用的函数的个数</span><br><span class="line">&#125;information[101];//主函数全部保存在结构体中，在结构体的division数组中，保存在该主函数下的调用函数</span><br><span class="line">int top=-1, total=0;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int i, j, op;</span><br><span class="line">    char stack[201][21]=&#123;0&#125;, temp[21]=&#123;0&#125;;</span><br><span class="line">    for(i=0;i&lt;101;i++)</span><br><span class="line">        information[i].count=0;//初始化所有主函数的count为0</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;op);</span><br><span class="line">        if(op==8)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;, temp);</span><br><span class="line">            for(i=0;i&lt;total;i++)&#123;</span><br><span class="line">                if(strcmp(information[i].name,temp)==0)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i==total)</span><br><span class="line">                strcpy(information[total++].name,temp);//保存每一个非重复出现的函数</span><br><span class="line">            if(top&gt;=0)&#123;</span><br><span class="line">                for(i=0;i&lt;total;i++)&#123;</span><br><span class="line">                    if(strcmp(information[i].name,stack[top])==0)</span><br><span class="line">                        break;</span><br><span class="line">                &#125;//查看当前位于栈顶的函数在information数组中的具体位置</span><br><span class="line">                for(j=0;j&lt;information[i].count;j++)&#123;</span><br><span class="line">                    if(strcmp(information[i].division[j],temp)==0)</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(j==information[i].count)&#123;</span><br><span class="line">                    strcpy(information[i].division[j],temp);</span><br><span class="line">                    information[i].count++;</span><br><span class="line">                &#125;//查看当前输入的函数在栈顶函数中的存在性，若不存在，则将其加入栈顶函数的分函数</span><br><span class="line">            &#125;</span><br><span class="line">            strcpy(stack[++top],temp);//将当前输入的函数入栈</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            top--;//退栈</span><br><span class="line">        if(top==-1)</span><br><span class="line">            break;//栈空则退出循环</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;total;i++)&#123;</span><br><span class="line">        if(information[i].count&gt;0)&#123;</span><br><span class="line">            printf(&quot;%s:&quot;, information[i].name);//输出含有分函数的主函数</span><br><span class="line">            for(j=0;j&lt;information[i].count-1;j++)</span><br><span class="line">                printf(&quot;%s,&quot;, information[i].division[j]);//按调用顺序输出分函数</span><br><span class="line">            printf(&quot;%s\n&quot;, information[i].division[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</code></pre>
</li>
</ul>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>answers</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第十期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%8D%81%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="sizeof和strlen"><a href="#sizeof和strlen" class="headerlink" title="sizeof和strlen"></a><code>sizeof</code>和<code>strlen</code></h2><blockquote>
<p>约定，假设我们有数组<code>char buf[512];</code>，如果我们用数组名给一个指针赋值，如<code>char *p = buf;</code>，则称<strong>用指针<code>p</code>管理数组<code>buf</code><strong>。显然，<code>*p</code>，<code>p[2]</code>，<code>*(p + 10)</code>，<code>p--</code>， <code>*p++</code>，<code>(*p)++</code>等操作都是允许的。当然，特别要注意的是，<code>buf++</code>这一操作是不允许的，因为</strong>数组名是一个常量</strong>。</p>
</blockquote>
<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><p><code>sizeof</code>是一个<strong>运算符</strong>，而<code>strlen</code>是一个 C 库函数。前者获取运算对象的字节数，后者返回字符串的长度。</p>
<ul>
<li><p>**<code>sizeof(数组名)</code>**返回数组总字节数。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">10</span>];    <span class="comment">// sizeof(c) = 10 × 1 = 10</span></span><br><span class="line"><span class="type">double</span> d[<span class="number">20</span>];  <span class="comment">// sizeof(d) = 20 × 8 = 160</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>strlen</code>的参数是<strong>字符串首地址</strong>，返回字符串的长度。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;hello&quot;</span>; <span class="comment">// strlen(buf) = 5</span></span><br><span class="line"><span class="type">char</span> *p = buf;        <span class="comment">// strlen(p) = 5，因为 p 存的也是字符串首地址</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>**<code>sizeof(指针变量)</code>**的值是固定的。32 位机器为 4，64 位机器为 8。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 32 位机器上</span></span><br><span class="line"><span class="type">char</span> *pc;   <span class="comment">// 字符指针，size 为 4</span></span><br><span class="line"><span class="type">int</span> *pi;    <span class="comment">// 整型指针，size 为 4</span></span><br><span class="line"><span class="type">double</span> *pd; <span class="comment">// 双精度浮点型指针，size 为 4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="type">char</span> c; <span class="type">long</span> l; <span class="type">int</span> arr[<span class="number">10</span>];&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">pn</span>;</span>   <span class="comment">// 结构体指针，size 为 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*pa)[<span class="number">100</span>];    <span class="comment">// 数组指针，size 为 4</span></span><br><span class="line"><span class="type">void</span> (*pf)(<span class="type">int</span> i, <span class="keyword">struct</span> node *p, <span class="type">char</span> c);</span><br><span class="line">                   <span class="comment">// 函数指针，size 为 4</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>综上，特别注意</strong></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = buf;</span><br><span class="line"><span class="keyword">sizeof</span>(buf);  <span class="comment">// 512</span></span><br><span class="line"><span class="keyword">sizeof</span>(p);    <span class="comment">// 4 or 8</span></span><br><span class="line"><span class="built_in">strlen</span>(buf);  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">strlen</span>(p);    <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="结构体的size"><a href="#结构体的size" class="headerlink" title="结构体的size"></a>结构体的<code>size</code></h3><blockquote>
<p>以 32 位机器为例。</p>
</blockquote>
<p><strong>结构体的成员按照声明的顺序排布。</strong>例如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ----------------------</span></span><br><span class="line"><span class="comment">  |         int        | 4 字节 \</span></span><br><span class="line"><span class="comment">  ----------------------         8 字节 sizeof(struct node) == 8</span></span><br><span class="line"><span class="comment">  |         ptr        | 4 字节 /</span></span><br><span class="line"><span class="comment">  ----------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p>但是，一般情况下结构体的<code>size</code>并不等于其各个成员的<code>size</code>之和，这是因为，为了满足<code>size</code>的 <strong>4 字节对齐（即总<code>size</code>是 4 的整倍数）</strong>，系统可能会空出一些不用的字节。例如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">short</span> s; <span class="comment">// 2 字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ----------------------</span></span><br><span class="line"><span class="comment">  |        char        |  1 字节</span></span><br><span class="line"><span class="comment">  ----------------------</span></span><br><span class="line"><span class="comment">  |        空白         |  补 3 字节</span></span><br><span class="line"><span class="comment">  ---------------------------------&gt; 4 字节</span></span><br><span class="line"><span class="comment">  |        int         |  4 字节</span></span><br><span class="line"><span class="comment">  ---------------------------------&gt; 8 字节</span></span><br><span class="line"><span class="comment">  |       short        |  2 字节</span></span><br><span class="line"><span class="comment">  ----------------------</span></span><br><span class="line"><span class="comment">  |        空白         |  补 2 字节</span></span><br><span class="line"><span class="comment">  ---------------------------------&gt; 12 字节</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p>如果声明成员的顺序不同，可能会出现其他情况，如</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">short</span> s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ----------------------</span></span><br><span class="line"><span class="comment">  |        char        |  1 字节</span></span><br><span class="line"><span class="comment">  ----------------------</span></span><br><span class="line"><span class="comment">  |        short       |  2 字节</span></span><br><span class="line"><span class="comment">  ----------------------</span></span><br><span class="line"><span class="comment">  |        空白         |  补 1 字节</span></span><br><span class="line"><span class="comment">  ---------------------------------&gt; 4 字节</span></span><br><span class="line"><span class="comment">  |        int         |  4 字节</span></span><br><span class="line"><span class="comment">  ---------------------------------&gt; 8 字节</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p>当然，获取结构体的<code>size</code>只需要通过<code>sizeof</code>即可，以上内容属于补充性的说明。</p>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><code>malloc</code></h3><p><code>malloc</code>的参数是欲分配空间的<strong>字节数</strong>，它返回一个<strong>通用指针</strong>，具体要怎么利用这片内存，由编程者自己决定（强转成指向谁的指针）。<strong>务必理解以下代码</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 32 位机器，以下代码都在 main 中</span></span><br><span class="line"><span class="type">void</span> *p = <span class="built_in">malloc</span>(<span class="number">8</span>);  <span class="comment">// 分配 8 个字节的内存，首地址交给 p</span></span><br><span class="line"><span class="type">char</span> *pc = (<span class="type">char</span>*)p;  <span class="comment">// 用字符指针管理这片内存(能装 8 个字符)</span></span><br><span class="line">pc[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>; pc[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>; pc[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>; pc[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                      <span class="comment">// 构造了字符串 &quot;abc&quot;</span></span><br><span class="line"><span class="type">int</span> *pi = (<span class="type">int</span>*)p;      <span class="comment">// 再用整型指针管理这片内存(能装 2 个整数)</span></span><br><span class="line">pi[<span class="number">0</span>] = <span class="number">-1</span>; pi[<span class="number">1</span>] = <span class="number">10</span>; <span class="comment">// 进行了合法的赋值</span></span><br><span class="line"><span class="type">double</span> *pd = (<span class="type">double</span>*)p; <span class="comment">// 最后用浮点型指针管理这片内存(能装 1 个双精度浮点数)</span></span><br><span class="line">*pd = <span class="number">3.14</span>; <span class="comment">// 用指针形式访问</span></span><br><span class="line">pd[<span class="number">0</span>] *= <span class="number">2</span>; <span class="comment">// 用数组形式访问</span></span><br><span class="line"><span class="comment">// 注意以上操作是连续的，有了一片可访问的内存，我想怎么用就怎么用</span></span><br></pre></td></tr></table></figure></div>

<h2 id="树的理论知识汇总"><a href="#树的理论知识汇总" class="headerlink" title="树的理论知识汇总"></a>树的理论知识汇总</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><blockquote>
<p><strong>树是一种特殊的图。</strong>但我们还没有给出图的定义，因此可形象理解：给若干顶点，在它们间连若干条边（可以是 0 条），即得到一张图。边上有箭头规定边的方向的图，称为<strong>有向图</strong>；否则称<strong>无向图</strong>。给定一张无向图，如果任意两个顶点间都有一条或多条边把它们连在一起，则称无向图是<strong>连通的</strong>。</p>
<p>注意，以下内容并不完全严谨但适用于本课程。</p>
</blockquote>
<ul>
<li>连通且无圈的无向图称为树。</li>
<li>设树 $T$ 有 $n$ 个顶点，$m$ 条边，则 $m &#x3D; n - 1$。$总度数 &#x3D; 2m&#x3D;2(n-1)$。</li>
<li>设 $T$ 是无向图，则以下几种说法等价<ul>
<li>$T$ 是树。</li>
<li>$T$ 连通且无圈。</li>
<li>$T$ 的每一对顶点间有唯一的一条路径将它们连接。</li>
<li>$T$ 连通且“边数 &#x3D; 顶点数 - 1”。</li>
<li>$T$ 无圈且“边数 &#x3D; 顶点数 - 1”。</li>
</ul>
</li>
<li>若树 $T$ 的每个顶点的度都小于或等于 $2$，且已经规定好了左右次序，则称 $T$ 为二叉树。</li>
<li>若二叉树 $T$ 每一层的节点数都达到最大值，则称 $T$ 为满二叉树。</li>
<li>若二叉树 $T$ 扣除最后一层的节点成为满二叉树，且最后一层节点严格从左到右排列，则称 $T$ 为完全二叉树。</li>
</ul>
<h3 id="常用结论"><a href="#常用结论" class="headerlink" title="常用结论"></a>常用结论</h3><h4 id="非空二叉树的性质"><a href="#非空二叉树的性质" class="headerlink" title="非空二叉树的性质"></a>非空二叉树的性质</h4><ul>
<li>第 $i$ 层最多有 $2^{i-1}$ 个节点。</li>
<li>若深度为 $h$，则最多有 $2^h-1$ 个节点。</li>
<li>设叶子节点有 $n_0$ 个，度为 $2$ 的节点有 $n_2$ 个，则 $n_0 &#x3D; n_2 + 1$。</li>
</ul>
<h4 id="满二叉树的性质"><a href="#满二叉树的性质" class="headerlink" title="满二叉树的性质"></a>满二叉树的性质</h4><ul>
<li>第 $i$ 层有 $2^{i-1}$ 个节点。</li>
<li>深度为 $h$ 的满二叉树有 $2^{h}-1$ 个节点，其中叶子节点有 $2^{h-1}$ 个。</li>
<li>具有 $n$ 个节点的满二叉树的深度为 $\text{log}_2(n+1)$。</li>
</ul>
<h4 id="完全二叉树的性质"><a href="#完全二叉树的性质" class="headerlink" title="完全二叉树的性质"></a>完全二叉树的性质</h4><ul>
<li>具有 $n$ 个节点的完全二叉树的深度为 $\lfloor \text{log}_2n\rfloor + 1$。</li>
<li>深度为 $h$ 的完全二叉树至少有 $2^{h-1}$ 个节点。</li>
<li>对具有 $n$ 个节点的完全二叉树按层次从上到下、每层从左到右从 $1$ 开始编号，则编号为 $i$ 的节点具有性质<ul>
<li>$i &#x3D; 1$ 表示根节点；</li>
<li>$i &gt; 1$ 时，该点的父节点编号为 $\lfloor i\ &#x2F;\ 2\rfloor$；</li>
<li>若 $2i&gt;n$，则该节点无左孩子，否则左孩子的编号为 $2i$；</li>
<li>若 $2i+1&gt;n$，则该节点无右孩子，否则右孩子的编号为 $2i+1$。</li>
</ul>
</li>
<li>对具有 $n$ 个节点的完全二叉树按层次从上到下、每层从左到右从 $0$ 开始编号，则编号为 $i$ 的节点具有性质<ul>
<li>$i &#x3D; 0$ 表示根节点；</li>
<li>$i &gt; 0$ 时，该点的父节点编号为 $\lfloor (i-1)\ &#x2F;\ 2\rfloor$；</li>
<li>若 $2i+1\geq n$，则该节点无左孩子，否则左孩子的编号为 $2i+1$；</li>
<li>若 $2i+2\geq n$，则该节点无右孩子，否则右孩子的编号为 $2i+2$。</li>
</ul>
</li>
</ul>
<h2 id="Huffman-编码的一些问题"><a href="#Huffman-编码的一些问题" class="headerlink" title="Huffman 编码的一些问题"></a>Huffman 编码的一些问题</h2><blockquote>
<p>此题在做之前一定要仔细看题面，题面已经给出了所有思路与逻辑，原有代码已经定义好的结构体等变量不能自己再重定义，只能严格按照原有代码补充所需步骤。</p>
</blockquote>
<h3 id="为什么用char不行"><a href="#为什么用char不行" class="headerlink" title="为什么用char不行"></a>为什么用<code>char</code>不行</h3><p>对于该题的实验步骤 4，在题面中给出的代码片段（如下）中，</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> hc;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>变量<code>hc</code>的类型是<code>char</code>，如果不特殊处理，则会导致<code>fputc(hc, obj)</code>与<code>printf(&quot;%x&quot;, hc)</code>的输出结果错误。</p>
<p>原因是在输出时，输出函数<code>fputc()</code>与<code>printf()</code>会先将<code>hc</code>由<code>char</code>类型转换为<code>int</code>类型，所以当<code>hc</code>的最高位为1时，会转化成一个负数，从而得到错误的输出。</p>
<ul>
<li>为什么会将<code>hc</code>由<code>char</code>转换为<code>int</code>类型呢？<ul>
<li><code>fputc()</code>函数原型中，第一个参数为<code>int</code>类型，即在输出时会进行隐式类型转换</li>
<li><code>printf()</code>函数的可变长参数表中，并不会实际接收到<code>char</code>类型的参数（与该函数的具体实现方式有关）</li>
</ul>
</li>
</ul>
<p>解决方案：将<code>hc</code>定义为<code>unsigned char</code>类型，或者在输出时先进行强制类型转换，旨在不让其被识别为负数。</p>
<h3 id="二进制模式和文本模式"><a href="#二进制模式和文本模式" class="headerlink" title="二进制模式和文本模式"></a>二进制模式和文本模式</h3><p>文件读写一般采用二进制模式或文本模式。</p>
<ul>
<li>二进制模式<ul>
<li><code>&quot;wb&quot;</code>、<code>&quot;rb&quot;</code></li>
<li>读写文件时不进行任何预处理，会原封不动得到原有数据</li>
</ul>
</li>
<li>文本模式<ul>
<li><code>&quot;w&quot;</code>、<code>&quot;r&quot;</code></li>
<li>读写文件时会先经过预处理，因此得到的数据和原有数据存在差别。比如在windows系统下，会进行<code>\r\n</code>与<code>\n</code>的转换（所以读到这儿的同学不妨想一想，大作业究竟怎么读入更方便）</li>
<li>目前遇到的上机题目中，大家只需要用文本模式读写文件即可</li>
</ul>
</li>
</ul>
<p>对于编程题第 6 题（选做题）的解压功能，如果使用文本模式<code>&quot;r&quot;</code>来读入，在读到十六进制字节<code>0x1A</code>时，会被当作控制字符<code>SUB</code>（对应的<code>ASCII</code>码是<code>0x1A</code>）处理，产生与控制台<code>ctrl + Z</code>相同作用（结束输入），从而产生<code>bug</code>。解决方式为使用二进制模式<code>&quot;rb&quot;</code>读入。</p>
<h3 id="对一个文件多次读入"><a href="#对一个文件多次读入" class="headerlink" title="对一个文件多次读入"></a>对一个文件多次读入</h3><p>猪脚说第二期已经提到过<strong>“文件偏移量”</strong>的概念，不清楚的同学可以自行翻阅。</p>
<p>读完文件后，文件偏移量已经到了该文件的末尾，那我们怎么再次对这个文件从头开始读入呢？有这样一个函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> origin)</span>;</span><br></pre></td></tr></table></figure></div>

<p>该函数位于<code>&lt;stdio.h&gt;</code>库中，实现重定位流（数据流或者文件）上的文件内部位置指针。</p>
<p>各参数的含义为：<code>stream</code>将指向以<code>origin</code>为参考位置，偏移<code>offset</code>个字节的位置。若函数执行成功，则返回值为 0，否则为非 0 值，并设置<code>error</code>错误代码。</p>
<p>其中，<code>offset</code>为偏移量，正数表示正向偏移，负数表示负向偏移。</p>
<p>第三个参数<code>origin</code>设定文件从哪儿开始偏移，可能取值为三个宏：</p>
<ul>
<li><code>SEEK_SET</code>：文件开头</li>
<li><code>SEEK_CUR</code>：当前位置</li>
<li><code>SEEK_END</code>：文件结尾</li>
</ul>
<p>简而言之，给出以下三种合法调用：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"><span class="comment">// 将文件偏移量设置到文件头</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fseek(fp, <span class="number">100L</span>, SEEK_CUR);</span><br><span class="line"><span class="comment">// 将文件偏移量设置到当前位置后的 100 字节处</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fseek(fp, <span class="number">-100L</span>, SEEK_END);</span><br><span class="line"><span class="comment">// 将文件偏移量设置到离文件结尾 100 字节处</span></span><br></pre></td></tr></table></figure></div>

<p>这个函数很重要，在该实验题的实验步骤 4 中很可能会用到。当然，如果只是想从头开始读文件，可以先关闭文件，再重新打开。</p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第十一期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%8D%81%E4%B8%80%E6%9C%9F/</url>
    <content><![CDATA[<blockquote>
<ul>
<li><p>本期内容为补充内容。</p>
</li>
<li><p>以伪代码形式说明，规定数组下标从 1 开始。</p>
</li>
</ul>
</blockquote>
<h2 id="如何证明算法的正确性"><a href="#如何证明算法的正确性" class="headerlink" title="如何证明算法的正确性"></a>如何证明算法的正确性</h2><p>我们以插入排序算法为例，假设我们有数组<code>A = &#123;5, 2, 4, 6, 1, 3&#125;</code>，</p>
<p>此算法的伪代码如下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">INSERTION-SORT(A):</span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">2</span> -&gt; A.length</span><br><span class="line">		temp = A[j]</span><br><span class="line">		<span class="comment">// i 用于寻找 temp 应插入的位置</span></span><br><span class="line">		i = j - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> i &gt; <span class="number">0</span> &amp;&amp; A[i] &gt; temp</span><br><span class="line">			A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">			i = i - <span class="number">1</span></span><br><span class="line">		A[i + <span class="number">1</span>] = temp</span><br></pre></td></tr></table></figure></div>

<p>我们知道，在最外层<code>for</code>循环每次迭代的开始，子数组<code>A[1...j-1]</code>构成了当前已经排好的序列，这个特性也被称为<strong>循环不变式</strong>。我们可以证明这个性质将一直保持下去，直到循环结束。具体而言，我们需要证明如下三点</p>
<ul>
<li><strong>初始化：</strong>循环开始之前，该条件为真。</li>
<li><strong>保持：</strong>如果循环的某次迭代之前该条件为真，那么下次迭代之前它仍为真。</li>
<li><strong>终止：</strong>循环终止时，这个条件能够说明算法达到我们想要的目的。</li>
</ul>
<p>对于上述插入排序算法，证明如下</p>
<ul>
<li><strong>初始化：</strong>第一次循环之前，<code>j = 2</code>，子序列仅由<code>A[1]</code>单个元素构成，它是已经排好序的，故条件成立。</li>
<li><strong>保持：</strong>假设<code>A[1...j-1]</code>已经排好序，在循环体内，代码的 5 ～ 8 行将<code>A[j - 1]</code> <code>A[j - 2]</code> <code>A[j - 3]</code>等依次向右移动，直到找到了<code>A[j]</code>应该插入的位置并将其插入。此时，<strong>子序列<code>A[1...j]</code>中的元素仍然不变，但是这个序列已经排好序了</strong>，说明循环不变式的条件得以保持。</li>
<li><strong>终止：</strong>循环终止的条件是<code>j &gt; A.length</code>。由于每次循环后<code>j</code>会加 1，所以循环终止时<code>j = A.length + 1</code>。代入循环不变式，子序列<code>A[1...A.length]</code>由原来<code>A</code>中的元素组成，但是已经排好序了，**由于整个数组就是子序列<code>A[1...A.length]</code>**，所以整个数组已经排好序。故算法正确。</li>
</ul>
<p>循环不变量的思路类似于<strong>数学归纳法</strong>，当然，这里的归纳在达到数据规模 $n$ 时就终止了。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>堆（heap）</strong>是这样一棵<strong>完全二叉树</strong>，它除了根结点外，所有结点都满足性质<strong>结点值大于等于父结点的值</strong>或<strong>结点值小于等于父结点的值</strong>，这两种堆分别称<strong>最小堆</strong>和<strong>最大堆</strong>。堆必然要用<strong>数组</strong>存储，这样便于高效地编程。设数组为<code>A</code>，<code>A.length</code>表示数组元素个数，<code>A.heap-size</code>表示堆中的元素个数 —— 之所以要区分这两者，是因为在某个时刻，可能只有<code>A[1...A.heap-size]</code>这一段子序列满足堆的性质。</p>
<p>根据完全二叉树的性质，不难得出</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">PARENT(i):</span><br><span class="line">	<span class="keyword">return</span> i / <span class="number">2</span></span><br><span class="line">LEFT(i):</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * i</span><br><span class="line">RIGHT(i):</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<h3 id="维护堆的性质"><a href="#维护堆的性质" class="headerlink" title="维护堆的性质"></a>维护堆的性质</h3><p>heapify 是 heap 的动词形式，可以表示“使堆化、维护堆的性质”。我们通过调用<code>HEAPIFY(A, i)</code>，来使得<strong>以下标<code>i</code>为根结点的子树满足堆的性质</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">HEAPIFY(A, i):</span><br><span class="line">	left = LEFT(i)</span><br><span class="line">	right = RIGHT(i)</span><br><span class="line">	<span class="keyword">if</span> left &lt;= A.heap-size &amp;&amp; A[left] &gt; A[i]</span><br><span class="line">		largest = left</span><br><span class="line">	<span class="keyword">else</span> largest = i</span><br><span class="line">	<span class="keyword">if</span> right &lt;= A.heap-size &amp;&amp; A[right] &gt;= A[largest]</span><br><span class="line">		largest = right</span><br><span class="line">	<span class="keyword">if</span> largest != i</span><br><span class="line">		exchange A[i] &lt;-&gt; A[largest]</span><br><span class="line">		HEAPIFY(A, largest)</span><br></pre></td></tr></table></figure></div>

<p>在这个函数中，我们先获取了以<code>i</code>为下标的结点的左孩子和右孩子的下标，然后，找出了最大的那个结点的下标并存于<code>largest</code>。如果<code>largest</code>不是<code>i</code>，说明此时子树<code>i</code>不满足堆的性质，于是我们<strong>把那个比较大的结点和<code>i</code>对换，并递归地维护子树的性质</strong>；如果<code>largest</code>就是<code>i</code>，说明堆的性质已经满足，函数结束。</p>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">BUILD-HEAP(A):</span><br><span class="line">	A.heap-size = A.length</span><br><span class="line">	<span class="keyword">for</span> i = A.length / <span class="number">2</span> -&gt; <span class="number">1</span></span><br><span class="line">		HEAPIFY(A, i)</span><br></pre></td></tr></table></figure></div>

<p>这个函数中的<code>for</code>循环，<strong>自底向上</strong>地把数组<code>A</code>转化成一个最大堆。我们严格地证明这个过程。</p>
<p><strong>循环不变量：每一次<code>for</code>循环的开始，结点<code>i + 1</code>，<code>i + 2</code>，… ，<code>A.length</code>都是一个最大堆的根结点。</strong></p>
<ul>
<li><strong>初始化：</strong>在第一次循环前，<code>i = A.length / 2</code>，这是<strong>最后一个叶结点的父结点的下标</strong>。因此<code>i + 1</code>，… ，<code>A.length</code>都是<strong>叶结点</strong>，它们都是<strong>平凡最大堆（仅有一个结点的堆）</strong>的根结点。</li>
<li><strong>保持：</strong>结点<code>i</code>的孩子结点的下标都比<code>i</code>大，根据循环不变量，它们都是最大堆的根。调用<code>HEAPIFY</code>后，<code>i</code>也成为了最大堆的根，于是循环不变量得以保持。</li>
<li><strong>终止：</strong>循环终止时，<code>i = 0</code>。根据循环不变量，结点<code>1</code>，<code>2</code>，… ，<code>A.length</code>都是最大堆的根，特别，结点<code>1</code>就是整个堆的根。于是我们正确地构造了最大堆<code>A[1...A.length]</code>。</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">HEAP-SORT(A):</span><br><span class="line">	BUILD-HEAP(A)</span><br><span class="line">	<span class="keyword">for</span> i = A.length -&gt; <span class="number">2</span></span><br><span class="line">		exchange A[<span class="number">1</span>] &lt;-&gt; A[i]</span><br><span class="line">		A.heap-size = A.heap-size - <span class="number">1</span></span><br><span class="line">		HEAPIFY(A, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<p>我们直观地理解这个过程，首先建堆，<strong>此时<code>A[1]</code>必为数组最大元素</strong>，开始循环，将<code>A[1]</code>放到最后，则数组中最大的元素已经安置好。此后我们将堆的规模减 1 并再次<code>HEAPIFY</code>，则<strong>数组中第二大的元素来到<code>A[1]</code>的位</strong>置，再将其放到倒数第二的位置……这样我们就实现了<code>A</code>从小到大排序。</p>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>堆排序是一个优秀的算法，但<strong>实际上快速排序的性能通常优于堆排序</strong>。但是，我们进一步思考堆的构建和维护过程，在这个过程中，我们<strong>始终维护</strong>着最大（最小）的那个元素的位置。</p>
<p>假如我们要获取数组中的最大元素，往往需要遍历该数组（或排序）。但是假如数组的元素不断变化，则每一次都要进行遍历 &#x2F; 排序操作，这一操作的开销是很大的。事实上，如果我们只关心最大的那个元素是多少，利用堆的性质可以更高效地解决这个问题。</p>
<p><strong>优先队列是一种特殊的线性表，具有最高优先级的元素位于队头，优先出队。</strong>显然，利用堆可以解决这个问题。优先队列的常见操作有</p>
<ul>
<li>插入一个元素</li>
<li>获取队头元素</li>
<li>出队</li>
<li>修改某个元素的值</li>
</ul>
<p><strong>每一次操作后，我们都需要利用<code>HEAPIFY</code>的算法，使得具有最高优先级的那个元素来到队头。</strong></p>
<p>“最高优先级”问题在很多领域均有涉及，因此优先队列是非常重要的数据结构。很多编程语言都高效地封装了优先队列，以方便编程者使用。例如在 C++ 中</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>            <span class="comment">// #include &lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    <span class="comment">// 定义了能容纳 int 类型的优先队列，默认队头为最大元素</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; num) &#123;  <span class="comment">// while (scanf(&quot;%d&quot;, &amp;num) != EOF)</span></span><br><span class="line">        pq.<span class="built_in">push</span>(num);     <span class="comment">// 入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// printf(&quot;%d\n&quot;, pq.top());</span></span><br><span class="line">        pq.<span class="built_in">pop</span>();         <span class="comment">// 出队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>当然，对于我们自定义的复合数据结构，我们还需要自己声明一套比较规则进行排序。</p>
<p><strong>请思考：<code>qsort</code>函数的<code>cmp</code>是怎么实现的？什么是函数指针？我们自己写的排序函数能多加一个<code>cmp</code>参数以便自定义任何规则的排序吗？</strong></p>
</blockquote>
<p><em>Author: Riccardo, diandian</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第十二期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%8D%81%E4%BA%8C%E6%9C%9F/</url>
    <content><![CDATA[<p>不知道大家做完第五次作业有什么感受。其实说句实在话，第五次作业是整个七套作业中最简单的一次，<del>猪脚两小时做完所有必做题</del>，因为对于树的前、中、后序遍历以及<code>BFS</code>、<code>DFS</code>操作全部都可以直接套用模版或者封装成函数，只需要在一道题之内写出正确的代码片段，其它题目直接<code>Ctrl+c</code>、<code>Ctrl+v</code>就行，并且词频统计和表达式计算都是之前做过的题目所以整体来讲不会太花时间。</p>
<p>另外，大家也可以针对词频统计和表达式计算这两道题，综合对比一下各种数据结构解题的优劣与可拓展性。</p>
<h2 id="树叶节点遍历（树-基础题）"><a href="#树叶节点遍历（树-基础题）" class="headerlink" title="树叶节点遍历（树-基础题）"></a>树叶节点遍历（树-基础题）</h2><p>这道题几乎没有坑点，考察大家对于树的相关概念和基本操作。最好的方式是按部就班地将每一个重要操作封装成函数，在<code>main</code>函数里直接按照逻辑进行调用，这样也可以为后续题目节省时间。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;Basic_tree;</span><br><span class="line">Basic_tree *<span class="title function_">insert</span><span class="params">(Basic_tree *root, <span class="type">int</span> x, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    high++;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        root = (Basic_tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Basic_tree)); <span class="comment">// 一定要记得malloc</span></span><br><span class="line">        root-&gt;num = x;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>; <span class="comment">// 因为递归涉及非空判断，所以这个地方一定要初始化！</span></span><br><span class="line">        root-&gt;height = high;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;num)</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, x, high);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;right = insert(root-&gt;right, x, high); <span class="comment">// 递归调用即可</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125; <span class="comment">// 插入操作，可直接当作模版使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trade</span><span class="params">(Basic_tree *a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a-&gt;left == <span class="literal">NULL</span> &amp;&amp; a-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a-&gt;num, a-&gt;height); <span class="comment">// 前序遍历即可实现输出从左到右的叶节点</span></span><br><span class="line">    trade(a-&gt;left);</span><br><span class="line">    trade(a-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n, x;</span><br><span class="line">    Basic_tree *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        root = insert(root, x, <span class="number">0</span>); <span class="comment">// 每输入一个数就添加到树中</span></span><br><span class="line">    &#125;</span><br><span class="line">    trade(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="词频统计（树实现）"><a href="#词频统计（树实现）" class="headerlink" title="词频统计（树实现）"></a>词频统计（树实现）</h2><p>这道题的插入操作可以直接套用第一题写好的<code>insert</code>函数，再对建立好的树进行中序遍历即可符合题意要求输出，而中序遍历代码块只需要在第一题的前序遍历代码块上稍作顺序上的修改即可。</p>
<p>另外，不要以为这道题和之前的题目一样，它多了一个操作。<strong>程序应首先输出二叉排序树中根节点、根节点的右节点及根节点的右节点的右节点上的单词（个数不足则按实际个数输出），这一步如果在代码里没有判断的模块，很容易访问到空指针哦～</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 101</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">char</span> word[MAXSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;Basic_tree;</span><br><span class="line">Basic_tree *<span class="title function_">insert</span><span class="params">(Basic_tree *root, <span class="type">char</span> x[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        root = (Basic_tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Basic_tree));</span><br><span class="line">        <span class="built_in">strcpy</span>(root-&gt;word,x);</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(x,root-&gt;word) &lt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(x,root-&gt;word) &gt; <span class="number">0</span>)</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;count++; <span class="comment">// 利用递归操作插入到合适位置</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(FILE *fp, <span class="type">char</span> w[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(!(<span class="built_in">isalpha</span>(c=fgetc(fp))))&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==EOF)</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="comment">// 跳过文件最开始的非字母字符</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        w[i++] = <span class="built_in">tolower</span>(c);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">isalpha</span>(c=fgetc(fp)));</span><br><span class="line">    w[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trade</span><span class="params">(Basic_tree *a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    trade(a-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, a-&gt;word, a-&gt;count);</span><br><span class="line">    trade(a-&gt;right);</span><br><span class="line">&#125; <span class="comment">// 中序遍历输出即可实现按照字典序输出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> wordtemp[MAXSIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    Basic_tree *root=<span class="literal">NULL</span>;</span><br><span class="line">    FILE *in = fopen(<span class="string">&quot;article.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(get(in,wordtemp) != EOF)</span><br><span class="line">        root = insert(root,wordtemp); <span class="comment">// 建树</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, root-&gt;word);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, root-&gt;word, root-&gt;right-&gt;word);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %s %s\n&quot;</span>, root-&gt;word, root-&gt;right-&gt;word, root-&gt;right-&gt;right-&gt;word);</span><br><span class="line">    trade(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="计算器（表达式计算-表达式树实现）"><a href="#计算器（表达式计算-表达式树实现）" class="headerlink" title="计算器（表达式计算-表达式树实现）"></a>计算器（表达式计算-表达式树实现）</h2><p>该题的实现思路与具体步骤已经在题面中告诉大家了。其中中缀转后缀表达式的操作可以直接使用第四次作业题解中给出的<code>Change(char s[])</code>函数，而建立树的过程可以直接跟着题面描述走，最后对树进行后续遍历即可得到表达式的值，后续遍历操作直接在第一题的前序遍历代码块上稍作顺序上的修改即可，所以做起来其实是很快的。</p>
<p><strong>一定要看题目是浮点数运算还是整型运算！！！</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> num[<span class="number">201</span>], ans[<span class="number">201</span>], top=<span class="number">-1</span>, top1=<span class="number">-1</span>;</span><br><span class="line"><span class="type">char</span> op[<span class="number">201</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;Tree;</span><br><span class="line">Tree savetree[<span class="number">1000</span>];</span><br><span class="line">Tree *treestack[<span class="number">1000</span>]; <span class="comment">// 树的指针栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Change</span><span class="params">(<span class="type">char</span> s[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j=<span class="number">0</span>, stacktop=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[<span class="number">201</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;s[i]!=<span class="string">&#x27;\0&#x27;</span>;)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">            num[j] = num[j]*<span class="number">10</span> + s[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="built_in">stack</span>[++stacktop]=s[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>||s[i]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stacktop&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>[stacktop]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    op[j++]=<span class="built_in">stack</span>[stacktop--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>[++stacktop]=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;*&#x27;</span>||s[i]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stacktop&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>[stacktop]==<span class="string">&#x27;(&#x27;</span>||<span class="built_in">stack</span>[stacktop]==<span class="string">&#x27;+&#x27;</span>||<span class="built_in">stack</span>[stacktop]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    op[j++]=<span class="built_in">stack</span>[stacktop--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>[++stacktop]=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">stack</span>[stacktop]!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                op[j++]=<span class="built_in">stack</span>[stacktop--];</span><br><span class="line">            stacktop--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stacktop&gt;<span class="number">-1</span>)</span><br><span class="line">        op[j++]=<span class="built_in">stack</span>[stacktop--];</span><br><span class="line">&#125; <span class="comment">// 中缀转后缀表达式的即用模版</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trade</span><span class="params">(Tree *a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    trade(a-&gt;left);</span><br><span class="line">    trade(a-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;op != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(a-&gt;op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                a-&gt;num = a-&gt;left-&gt;num + a-&gt;right-&gt;num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                a-&gt;num = a-&gt;left-&gt;num - a-&gt;right-&gt;num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                a-&gt;num = a-&gt;left-&gt;num * a-&gt;right-&gt;num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                a-&gt;num = a-&gt;left-&gt;num / a-&gt;right-&gt;num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 在运算符的节点存储当前运算的值，最后根节点所存储的值即为表达式结果</span></span><br><span class="line">&#125; <span class="comment">// 对表达式树进行后续遍历</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> x[<span class="number">201</span>], s[<span class="number">201</span>];</span><br><span class="line">    gets(x);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;x[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i]!=<span class="string">&#x27; &#x27;</span>&amp;&amp;x[i]!=<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">            s[j++]=x[i];</span><br><span class="line">    &#125; <span class="comment">// 删除空格</span></span><br><span class="line">    s[j]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    Change(s);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            top++;</span><br><span class="line">            top1++;</span><br><span class="line">            savetree[top1].num=num[i];</span><br><span class="line">            savetree[top1].left=savetree[top1].right=<span class="literal">NULL</span>;</span><br><span class="line">            treestack[top]=&amp;savetree[top1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[i]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">            top1++;</span><br><span class="line">            savetree[top1].op=op[i];</span><br><span class="line">            savetree[top1].left=treestack[top<span class="number">-1</span>];</span><br><span class="line">            savetree[top1].right=treestack[top];</span><br><span class="line">            top--;</span><br><span class="line">            treestack[top]=&amp;savetree[top1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num[i]==<span class="number">0</span>&amp;&amp;op[i]==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="comment">// 按照题面描述建立表达式树</span></span><br><span class="line">    <span class="keyword">if</span>(treestack[<span class="number">0</span>]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(treestack[<span class="number">0</span>]-&gt;op!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, treestack[<span class="number">0</span>]-&gt;op);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, treestack[<span class="number">0</span>]-&gt;num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(treestack[<span class="number">0</span>]-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(treestack[<span class="number">0</span>]-&gt;left-&gt;op!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, treestack[<span class="number">0</span>]-&gt;left-&gt;op);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, treestack[<span class="number">0</span>]-&gt;left-&gt;num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(treestack[<span class="number">0</span>]-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(treestack[<span class="number">0</span>]-&gt;right-&gt;op!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, treestack[<span class="number">0</span>]-&gt;right-&gt;op);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, treestack[<span class="number">0</span>]-&gt;right-&gt;num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    trade(treestack[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, treestack[<span class="number">0</span>]-&gt;num); <span class="comment">// 根节点所储存的值就是最终运算结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="服务优化"><a href="#服务优化" class="headerlink" title="服务优化"></a>服务优化</h2><p><del>这道题为2020级期末考试真题，并且是最后一题</del></p>
<p>该题一种简单做法是：某节点的编号直接对应到结构体树的数组下标里去，机场流量再另外开一个结构体存储，最后输出的时候建立映射关系即可。从上到下、从左到右的顺序可以利用BFS遍历实现，老师上课也讲过了，用队列实现即可。</p>
<p>需要注意的一点是，根节点的分支也不一定就是3个，一些同学会在这个细节上出错。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">latter</span>[3];</span></span><br><span class="line">&#125;Tree, *Treeptr;</span><br><span class="line">Tree airport_branch[<span class="number">5000</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AirNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="type">int</span> flow;</span><br><span class="line">&#125;airport_record[<span class="number">5000</span>];</span><br><span class="line"><span class="type">int</span> after[<span class="number">5000</span>], gatenumber=<span class="number">0</span>; <span class="comment">// after数组存储原本从上到下、从左到右顺序所得节点的编号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * a, <span class="type">const</span> <span class="type">void</span> * b)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AirNode</span> *<span class="title">e1</span> =</span> (<span class="keyword">struct</span> AirNode*)a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AirNode</span> *<span class="title">e2</span> =</span> (<span class="keyword">struct</span> AirNode*)b;</span><br><span class="line">    <span class="keyword">if</span>(e1-&gt;flow != e2-&gt;flow)</span><br><span class="line">        <span class="keyword">return</span> e2-&gt;flow - e1-&gt;flow;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> e1-&gt;name - e2-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">order</span><span class="params">(Treeptr t)</span>&#123;</span><br><span class="line">    Treeptr <span class="built_in">queue</span>[<span class="number">5000</span>], p;</span><br><span class="line">    <span class="type">int</span> front=<span class="number">0</span>, rear=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>[<span class="number">0</span>] = t;</span><br><span class="line">    <span class="keyword">while</span>(front&lt;=rear)&#123;</span><br><span class="line">        p=<span class="built_in">queue</span>[front++];</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;latter[<span class="number">0</span>]==<span class="literal">NULL</span>&amp;&amp;p-&gt;latter[<span class="number">1</span>]==<span class="literal">NULL</span>&amp;&amp;p-&gt;latter[<span class="number">2</span>]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            after[gatenumber++] = p-&gt;name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;latter[<span class="number">0</span>]!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">queue</span>[++rear]=p-&gt;latter[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;latter[<span class="number">1</span>]!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">queue</span>[++rear]=p-&gt;latter[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;latter[<span class="number">2</span>]!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">queue</span>[++rear]=p-&gt;latter[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 根据题意，此题需采取BFS遍历</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, r, s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(r==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            airport_branch[r].name=r;</span><br><span class="line">            i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s);</span><br><span class="line">                <span class="keyword">if</span>(s==<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    airport_branch[r].latter[i]=(Tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">                    airport_branch[s].name=s;</span><br><span class="line">                    airport_branch[r].latter[i++]=&amp;airport_branch[s];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 至此，登机口节点树已全部建立好</span></span><br><span class="line">    order(&amp;airport_branch[<span class="number">100</span>]); <span class="comment">// 树根节点编号为100，则直接从该位置开始BFS遍历</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;gatenumber;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;airport_record[i].name, &amp;airport_record[i].flow);</span><br><span class="line">    qsort(airport_record,gatenumber,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> AirNode),comp);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;gatenumber;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;%d\n&quot;</span>, airport_record[i].name, after[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="实验：树的构造与遍历"><a href="#实验：树的构造与遍历" class="headerlink" title="实验：树的构造与遍历"></a>实验：树的构造与遍历</h2><p>这道题没什么好说的，其实是一道比较无聊（指题面太长了，但真正需要大家实现的功能比较少）但又有点有趣（指可以通过这道题学习一种文本文件压缩方法）的题，具体步骤和功能题面上说的很清楚了，这里就不作赘述，直接上代码。</p>
<p>坑点包括第二个步骤不能一味的使用<code>qsort</code>函数，因为算法提示的第二个排序步骤并不是按照节点的字符大小排序的，而是“加入到其后”，而如果不处理字符大小的话，<code>qsort</code>函数对于权重相同的节点，其处理完后的顺序是完全随机的。部分同学在这个地方没有注意到细节。</p>
<p>另外，步骤四中关于<code>char</code>和<code>unsigned char</code>已在猪脚说中阐述。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> &#123;</span>                    <span class="comment">//Huffman树结构</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> weight;                    <span class="comment">//树节点权重，叶节点为字符和它的出现次数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">left</span>,*<span class="title">right</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="type">int</span> Ccount[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;        <span class="comment">//存放每个字符的出现次数，如Ccount[i]表示ASCII值为i的字符出现次数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">Root</span>=</span><span class="literal">NULL</span>;         <span class="comment">//Huffman树的根节点</span></span><br><span class="line"><span class="type">char</span> HCode[<span class="number">128</span>][MAXSIZE]=&#123;&#123;<span class="number">0</span>&#125;&#125;; <span class="comment">//字符的Huffman编码</span></span><br><span class="line">                                <span class="comment">//如HCode[&#x27;a&#x27;]为字符a的Huffman编码（字符串形式）</span></span><br><span class="line"><span class="type">int</span> Step=<span class="number">0</span>;                        <span class="comment">//实验步骤</span></span><br><span class="line">FILE *Src, *Obj;</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">statCount</span><span class="params">()</span>;             <span class="comment">//步骤1：统计文件中字符频率</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createHTree</span><span class="params">()</span>;           <span class="comment">//步骤2：创建一个Huffman树，根节点为Root</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">makeHCode</span><span class="params">()</span>;             <span class="comment">//步骤3：根据Huffman树生成Huffman编码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">atoHZIP</span><span class="params">()</span>;               <span class="comment">//步骤4：根据Huffman编码将指定ASCII码文本文件转换成Huffman码文件</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">()</span>;                    <span class="comment">//输出步骤1的结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="keyword">struct</span> tnode *p)</span>;     <span class="comment">//输出步骤2的结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print3</span><span class="params">()</span>;                    <span class="comment">//输出步骤3的结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print4</span><span class="params">()</span>;                    <span class="comment">//输出步骤4的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((Src=fopen(<span class="string">&quot;input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s open failed!\n&quot;</span>, <span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((Obj=fopen(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s open failed!\n&quot;</span>, <span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Step);                    <span class="comment">//输入当前实验步骤</span></span><br><span class="line">    </span><br><span class="line">    statCount();                        <span class="comment">//实验步骤1：统计文件中字符出现次数（频率）</span></span><br><span class="line">    (Step==<span class="number">1</span>) ? print1(): <span class="number">1</span>;             <span class="comment">//输出实验步骤1结果</span></span><br><span class="line">    createHTree();                        <span class="comment">//实验步骤2：依据字符频率生成相应的Huffman树</span></span><br><span class="line">    (Step==<span class="number">2</span>) ? print2(Root): <span class="number">2</span>;         <span class="comment">//输出实验步骤2结果</span></span><br><span class="line">    makeHCode();                 <span class="comment">//实验步骤3：依据Root为树的根的Huffman树生成相应Huffman编码</span></span><br><span class="line">    (Step==<span class="number">3</span>) ? print3(): <span class="number">3</span>;             <span class="comment">//输出实验步骤3结果</span></span><br><span class="line">    (Step&gt;=<span class="number">4</span>) ? atoHZIP(),print4(): <span class="number">4</span>;<span class="comment">//实验步骤4：据Huffman编码生成压缩文件并输出实验步骤4结果</span></span><br><span class="line"></span><br><span class="line">    fclose(Src);</span><br><span class="line">    fclose(Obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【实验步骤1】开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">statCount</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c=fgetc(Src))!= EOF)</span><br><span class="line">        Ccount[c]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【实验步骤1】结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【实验步骤2】开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createHTree</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> *<span class="title">treestack</span>[1001];</span></span><br><span class="line">    <span class="type">int</span> top=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    Ccount[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">128</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Ccount[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            top++;</span><br><span class="line">            p = (<span class="keyword">struct</span> tnode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tnode));</span><br><span class="line">            p-&gt;c = i;</span><br><span class="line">            p-&gt;weight = Ccount[i];</span><br><span class="line">            p-&gt;left = p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">            treestack[top]=p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;top;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;top-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(treestack[j]-&gt;weight &lt; treestack[j+<span class="number">1</span>]-&gt;weight)&#123;</span><br><span class="line">                tmp = treestack[j];</span><br><span class="line">                treestack[j]=treestack[j+<span class="number">1</span>];</span><br><span class="line">                treestack[j+<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(treestack[j]-&gt;weight == treestack[j+<span class="number">1</span>]-&gt;weight)&#123;</span><br><span class="line">                <span class="keyword">if</span>(treestack[j]-&gt;c &lt; treestack[j+<span class="number">1</span>]-&gt;c)&#123;</span><br><span class="line">                    tmp = treestack[j];</span><br><span class="line">                    treestack[j]=treestack[j+<span class="number">1</span>];</span><br><span class="line">                    treestack[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top)&#123;</span><br><span class="line">        p = (<span class="keyword">struct</span> tnode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tnode));</span><br><span class="line">        p-&gt;weight = treestack[top]-&gt;weight + treestack[top<span class="number">-1</span>]-&gt;weight;</span><br><span class="line">        p-&gt;left = treestack[top];</span><br><span class="line">        p-&gt;right = treestack[top<span class="number">-1</span>];</span><br><span class="line">        top--;</span><br><span class="line">        treestack[top] = p;</span><br><span class="line">        tmp = treestack[top];</span><br><span class="line">        <span class="keyword">for</span>(i=top<span class="number">-1</span>;treestack[i]-&gt;weight&lt;=treestack[top]-&gt;weight&amp;&amp;i&gt;=<span class="number">0</span>;i--);</span><br><span class="line">        <span class="keyword">for</span>(j=top<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">            treestack[j+<span class="number">1</span>]=treestack[j];</span><br><span class="line">        treestack[i+<span class="number">1</span>]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    Root = treestack[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【实验步骤2】结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【实验步骤3】开始</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visitHtree</span><span class="params">(<span class="keyword">struct</span> tnode *p, <span class="type">char</span> code, <span class="type">int</span> level, <span class="type">char</span> Huffman[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">visitHtree</span><span class="params">(<span class="keyword">struct</span> tnode *p, <span class="type">char</span> code, <span class="type">int</span> level, <span class="type">char</span> Huffman[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level!=<span class="number">0</span>)</span><br><span class="line">        Huffman[level<span class="number">-1</span>] = code;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;left==<span class="literal">NULL</span>&amp;&amp;p-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        Huffman[level] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(HCode[p-&gt;c], Huffman);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        visitHtree(p-&gt;left, <span class="string">&#x27;0&#x27;</span>, level+<span class="number">1</span>, Huffman);</span><br><span class="line">        visitHtree(p-&gt;right, <span class="string">&#x27;1&#x27;</span>, level+<span class="number">1</span>, Huffman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">makeHCode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> Huffman[MAXSIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    visitHtree(Root, <span class="string">&#x27;0&#x27;</span>, <span class="number">0</span>, Huffman);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【实验步骤3】结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【实验步骤4】开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">atoHZIP</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pc,hc=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    fseek(Src,<span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        c=fgetc(Src);</span><br><span class="line">        <span class="keyword">if</span>(c==EOF)</span><br><span class="line">            c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(pc=HCode[c];*pc!=<span class="string">&#x27;\0&#x27;</span>;pc++)&#123;</span><br><span class="line">            hc = (hc &lt;&lt; <span class="number">1</span>) | (*pc - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">8</span>)&#123;</span><br><span class="line">                fputc(hc,Obj);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,hc);</span><br><span class="line">                i=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i++&lt;<span class="number">8</span>)</span><br><span class="line">                hc = (hc &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            fputc(hc,Obj);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,hc);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;<span class="keyword">while</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【实验步骤4】结束</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NUL:1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">128</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(Ccount[i] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c:%d\n&quot;</span>, i, Ccount[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="keyword">struct</span> tnode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((p-&gt;left==<span class="literal">NULL</span>)&amp;&amp;(p-&gt;right==<span class="literal">NULL</span>))</span><br><span class="line">            <span class="keyword">switch</span>(p-&gt;c)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;NUL &quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:  <span class="built_in">printf</span>(<span class="string">&quot;SP &quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>: <span class="built_in">printf</span>(<span class="string">&quot;TAB &quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:  <span class="built_in">printf</span>(<span class="string">&quot;CR &quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,p-&gt;c); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        print2(p-&gt;left);</span><br><span class="line">        print2(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">128</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(HCode[i][<span class="number">0</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;NUL:&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:  <span class="built_in">printf</span>(<span class="string">&quot;SP:&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>: <span class="built_in">printf</span>(<span class="string">&quot;TAB:&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:  <span class="built_in">printf</span>(<span class="string">&quot;CR:&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;%c:&quot;</span>,i); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,HCode[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> in_size, out_size;</span><br><span class="line">    </span><br><span class="line">    fseek(Src,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    fseek(Obj,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    in_size = ftell(Src);</span><br><span class="line">    out_size = ftell(Obj);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n原文件大小：%ldB\n&quot;</span>,in_size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;压缩后文件大小：%ldB\n&quot;</span>,out_size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;压缩率：%.2f%%\n&quot;</span>,(<span class="type">float</span>)(in_size-out_size)*<span class="number">100</span>/in_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>非常感谢这位小伙伴看到了这里，那么就不吝啬地给出一道补充思考题吧！（有好的方法可以和猪脚探讨探讨，猪脚v你50😍）</p>
</blockquote>
<p>在本次作业中，同学们学习了利用树结构将中缀表达式转化为后缀表达式，很明显，后缀表达式树的节点中是不包含左、右括号的。那么如果给你一个后缀表达式，你能把它转化成<strong>包含最少括号的中缀表达式</strong>（即若删除任意一对括号，都不能再转化为原来的后缀表达式）吗？</p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>answers</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第十三期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%8D%81%E4%B8%89%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="大作业相关问题"><a href="#大作业相关问题" class="headerlink" title="大作业相关问题"></a>大作业相关问题</h2><h3 id="常见问题-基本注意事项"><a href="#常见问题-基本注意事项" class="headerlink" title="常见问题 &amp; 基本注意事项"></a>常见问题 &amp; 基本注意事项</h3><ul>
<li>文件的读入：推荐大家使用以下方式读取<code>hashvalue.txt</code>的内容：</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> Hash[<span class="number">10001</span>][<span class="number">130</span>];</span><br><span class="line">FILE *fph;</span><br><span class="line">fph = fopen(<span class="string">&quot;hashvalue.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">  <span class="built_in">fscanf</span>(fph, <span class="string">&quot;%s&quot;</span>, Hash[i]);</span><br><span class="line">  Hash[i][N] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果大家在本地运行时样例输出完全正确（包括键盘输出和<code>result.txt</code>的输出），而提交小数据点时输出错误，不妨把读入<code>article</code>与<code>sample</code>的模式也改为<code>&quot;rb&quot;</code>，如果发现输出结果出现变化，<strong>大概率是因为你对于<code>\r\n</code>的处理不够仔细</strong>（大多是因为你对换行符进行了形如<code>if (c == &#39;\n&#39;)</code>的特判）。</p>
<p>一种建议的修改方式即为将读入模式改为<code>&quot;rb&quot;</code>，这样就可以原封不动地得到<code>txt</code>文件中的所有数据。此时，你就可以将<code>\r</code>与<code>\n</code>看作独立的两个字符，分别进行特判即可。</p>
<ul>
<li>换页<strong>符只出现在文章与文章之间，最后一篇文章是没有<code>\f</code>的</strong>，有些同学把“读到换页符”这一条件作为读完一篇文章的标志，那么就需要检查最后一篇文章有没有被读入；</li>
<li><strong>换页符<code>\f</code>紧跟着的那一行不一定就是下一篇文章的标识号</strong>，有可能隔着很多空行，因此不能在读到<code>\f</code>后直接执行<code>fgets()</code>并把读到的内容作为文章标识号。以下代码作为正确读取文章标题的参考：</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;\f&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isspace</span>(c = fgetc(fp)))</span><br><span class="line">      ; <span class="comment">// 读到非空白字符为止，说明已经跳过所有空行</span></span><br><span class="line">  ungetc(c, fp); <span class="comment">// 将此时读进来的非空白字符 c 退回到 fp 指向的文件流中</span></span><br><span class="line">  fgets(<span class="comment">/* ... */</span>); <span class="comment">// 按行读入即为文章标识号</span></span><br><span class="line">  <span class="comment">// 删除读进来的换行符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>题目中没有任何一句话表明文章标识号的形式一定是<code>XX-XXXX</code>的数字形式</strong>，事实上任意字符串都可以是文章的标识号（包括空格，因此也请不要使用<code>fscanf()</code>等读不进来空格的函数），因此不要自作主张在输出时直接写成<code>printf(&quot;1-%d&quot;, count);</code>的形式；</li>
<li>用<code>fgetc()</code>读入字符时，请一定要用<code>int</code>型的变量存储：</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span> (c = fgetc(fp)) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>数组的大小要仔细考量，保证读入的数据不会越界。相关数据范围参考课程群中给出的消息；</li>
<li>检查数组存储下标的一致性。</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="优化-I-O"><a href="#优化-I-O" class="headerlink" title="优化 I&#x2F;O"></a>优化 I&#x2F;O</h4><ul>
<li><code>printf</code>、<code>scanf</code>改成<code>getchar</code>、<code>putchar</code>快读快写；</li>
<li>先使用<code>fread</code>将文件内容整个读进内存，再对内存进行后续操作；</li>
<li>尽可能减少重复读入，比如不要连续读多遍文件。</li>
</ul>
<h4 id="减少遍历次数"><a href="#减少遍历次数" class="headerlink" title="减少遍历次数"></a>减少遍历次数</h4><ul>
<li>不要写出如下形式的代码</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (c = fgetc(fp)) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)&#123; <span class="comment">// 不要出现</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="built_in">memset</span>(<span class="comment">/* ... */</span>); <span class="comment">// 不要出现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为<code>strlen</code>与<code>memset</code>的原理就是对整个数组进行<code>for</code>循环，再把这样的函数放入循环里，时间复杂度一下就上去了。<strong>当然论效率<code>memset</code>还是相对较高的，在必要的初始化、“新的开始”之处，不要因为缺省了一些操作而导致错误。</strong></p>
<h4 id="压榨性能"><a href="#压榨性能" class="headerlink" title="压榨性能"></a>压榨性能</h4><ul>
<li><p><strong>存储结构</strong></p>
<ul>
<li>顺序存储（数组）？链式存储（指针）？</li>
<li>一般情况下，访问数组的效率明显高于通过指针的间接访问</li>
</ul>
</li>
<li><p><strong>查找方式</strong></p>
<ul>
<li>二叉查找树？<code>bsearch</code>函数？<code>trie</code>树？</li>
<li>如果使用<code>trie</code>树，请思考在建立树时是否一定需要把单词一起存储进去（浪费大量时间）？</li>
</ul>
</li>
<li><p>将逻辑简单的函数改写为宏，可以<strong>减少函数调用</strong>的时间，例如<code>isalpha</code>、<code>tolower</code>等；</p>
</li>
<li><p><strong>尽量少调用 C 库函数</strong>，一般建议只需使用<code>stdio.h</code>与<code>stdlib.h</code>即可；</p>
</li>
<li><p><strong>合理封装功能模块</strong>，例如把“获取一个单词”写成函数，它会被调用非常多次，则开销巨大；把“读取 article 并完成词频统计”封装成一个函数，在逻辑上较为清晰，且开销较小（当然只有一个<code>main</code>理论上最高效，但<strong>不建议写成一坨</strong>）；</p>
</li>
<li><p>频繁访问的变量可以声明为<code>register</code>，“建议”编译器将这个变量存储在寄存器中，提供更高速的访问；</p>
<blockquote>
<p>注意，这种类型的变量<strong>只能是局部变量，并且通常用于循环变量</strong>，如在<code>main</code>的开头写<code>register int i = 0;</code>或者<code>for</code>循环的括号中写<code>for (register int j = 0; j &lt; n; j++)</code>，<strong>切勿滥用！</strong></p>
</blockquote>
</li>
<li><p>其他：<strong>内嵌汇编</strong><code>asm(...)</code>、<strong>内联函数</strong><code>inline</code>、<strong>编译优化</strong>（昵称“开火车”）<code>#pregma GCC optimize(&quot;O3&quot;)</code>等方法（想要把时间压缩到极致的同学，建议了解一下汇编语言）。</p>
</li>
</ul>
<h3 id="时间度量"><a href="#时间度量" class="headerlink" title="时间度量"></a>时间度量</h3><ul>
<li><p>可以使用本地操作系统的库以进行高精度的时间测量。（上网搜索：C 语言，时间，<code>&lt;time.h&gt;</code>等）</p>
</li>
<li><p>使用 Visual Studio 自带的时间分析工具，可参考<a class="link"   href="https://blog.csdn.net/tfb760/article/details/96900098" >https://blog.csdn.net/tfb760/article/details/96900098 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>可针对性地对某个函数、某个语句进行优化。</p>
</li>
</ul>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><blockquote>
<p>这部分在本课程用处不大，但在以后很有用。</p>
</blockquote>
<blockquote>
<p>你想过吗，<code>qsort</code>函数的那个<code>cmp</code>到底是什么呢？</p>
</blockquote>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>我们有如下的观点</p>
<ul>
<li>指针变量是一种<strong>特殊的整型变量</strong>，用于存放地址值，<strong>地址就是一个整数</strong></li>
<li>通过指针可以<strong>间接访问</strong>一个普通变量、一个结构体、一个数组等</li>
<li>地址和内存息息相关，地址就是某个内存中的存储单元的编号</li>
<li><strong>数组名就是指针</strong></li>
</ul>
<p>现在我们再提出以下观点</p>
<ul>
<li><strong>函数也储存在内存中，函数也有“首地址”</strong></li>
<li><strong>函数名就是指针</strong>，是指向该函数的指针，称为“函数指针”</li>
<li>在函数指针后加上括号，表示对该函数的<strong>调用（call）</strong>；这里没有用<code>*</code>解引用的过程，这是 C 语言提供的便捷写法，事实上，要解引用也可以。</li>
</ul>
<p>我们通过两个例子验证上述观点。</p>
<blockquote>
<p>C 语言中，<code>%p</code>表示用<strong>十六进制输出一个地址值</strong>，指针中存放的地址值就可以用这种格式输出，当然，地址是一个整数，也可以用<code>%d</code> <code>%ld</code> <code>%lld</code> <code>%u</code>等形式输出，只是可能有 warning。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NULL: %p\n&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;a: %p\n&quot;</span>, &amp;a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一种可能的输出是</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NULL: 0x0</span><br><span class="line">&amp;a: 0x16b913578</span><br></pre></td></tr></table></figure></div>

<p>当然，“可能”指的是<code>a</code>的地址，<code>NULL</code>必然是恒定的值 0，表示一个“无效地址”。</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;main: %p\n&quot;</span>, main);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;f: %p\n&quot;</span>, f);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们用地址的格式输出<code>main</code>函数和<code>f</code>函数的地址，得到的可能结果是</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">main: 0x1004c3f30</span><br><span class="line">f: 0x1004c3f2c</span><br></pre></td></tr></table></figure></div>

<p>显然，这两个函数在内存中都是有地址的，它们（的机器代码）就存放于内存中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The number is %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	f(<span class="number">10</span>);    <span class="comment">// 函数指针加上括号实现调用</span></span><br><span class="line">	(*f)(<span class="number">20</span>); <span class="comment">// 先给函数指针解引用得到“函数”，再调用</span></span><br><span class="line">              <span class="comment">// 调用的优先级高于解引用，所以前面加了括号</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">The number is 10</span><br><span class="line">The number is 20</span><br></pre></td></tr></table></figure></div>

<p>这说明<strong>函数名就是指针，是指向该函数的指针，函数指针也可以解引用，得到对应的函数后再进行调用，但没必要。</strong></p>
<h3 id="函数指针类型"><a href="#函数指针类型" class="headerlink" title="函数指针类型"></a>函数指针类型</h3><p>通过上述两个案例，我们意识到，函数本身也是一个地址值，<strong>只要知道了函数的地址，就可以实现对该函数的调用</strong>。显然，函数名就是函数的地址；但是另一方面，地址也需要存储在一个指针变量中。</p>
<p>我们知道，<strong>指针是有类型的</strong>，指针值本身是一个整数，它指向什么类型的变量，则需要由指针的类型表示。换言之，地址值是一个整数，但是<strong>怎么解释、怎么访问</strong>那个地址处的内容，需要由指针的类型决定。</p>
<p>我们通过一个例子，探索函数指针的类型。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span> &#123;   </span><br><span class="line">    <span class="comment">// 函数 f，需要一个 int 作为参数，无返回值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i + 100 = %d\n&quot;</span>, i + <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数 sum，需要两个 double 作为参数，返回值为 double 类型</span></span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">void</span> (*ptr)(<span class="type">int</span>) = f;</span><br><span class="line">        <span class="comment">// void 是函数的返回类型</span></span><br><span class="line">        <span class="comment">// ptr 是指针变量的名字</span></span><br><span class="line">        <span class="comment">// int 是该函数所需要的参数</span></span><br><span class="line">        <span class="comment">// 定义了一个名为 ptr 的函数指针，它指向一个返回类型 void、参数为一个 int 的函数</span></span><br><span class="line">	ptr(<span class="number">20</span>);     <span class="comment">// 通过函数指针直接调用函数</span></span><br><span class="line">	(*ptr)(<span class="number">30</span>);  <span class="comment">// 解引用得到“函数”，再调用（没必要这么写）</span></span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> (*p_sum)(<span class="type">double</span>, <span class="type">double</span>) = sum;</span><br><span class="line">    <span class="comment">// 定义了一个名为 p_sum 的函数指针，它指向一个返回类型为 double、参数为两个 double 的函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ans: %.2f\n&quot;</span>, p_sum(<span class="number">3.14</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上例输出为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">i + 100 = 120</span><br><span class="line">i + 100 = 130</span><br><span class="line">ans: 5.14</span><br></pre></td></tr></table></figure></div>

<p>这个简单的例子足以明确如何定义、如何使用函数指针，<strong>归结起来，函数指针的通用格式就是</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">[函数返回值类型] (*[函数指针变量名])(函数参数列表)</span><br></pre></td></tr></table></figure></div>

<p>如此一来，我们再考察<code>qsort</code>函数，就会豁然开朗，这个函数的原型如下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base,   <span class="comment">// 数组首地址</span></span></span><br><span class="line"><span class="params">           <span class="type">size_t</span> n,     <span class="comment">// 元素个数</span></span></span><br><span class="line"><span class="params">           <span class="type">size_t</span> width, <span class="comment">// 单个元素的字节数</span></span></span><br><span class="line"><span class="params">           <span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure></div>

<p>第四个参数<code>cmp</code>就是一个函数指针，<strong>它指向一个返回值为<code>int</code>、参数为两个<code>const void *</code>的函数</strong>。显然<code>qsort</code>内部并不会把排序时元素比较的规则写死：<code>if (a[i] &lt; a[i + 1])</code>，而是通过调用<code>cmp</code>函数从而实现用户自定义规则的比较</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cmp(&amp;a[i], &amp;a[i + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 把 a[i] 放到 a[i + 1] 后面</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp(&amp;a[i], &amp;a[i + <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 把 a[i] 放到 a[i + 1] 前面</span></span><br><span class="line">&#125; <span class="comment">// 没有规定相等时谁前谁后</span></span><br></pre></td></tr></table></figure></div>

<p>以上一段只是形象说明，实际上，为了<strong>容纳任意类型的数组</strong>，<code>qsort</code>采用了**<code>void*</code>通用指针<strong>的手段，并要求传入单个元素大小<code>width</code>。事实上，内存中的<code>[base, base + width)</code>这一段空间对应数组首元素，<code>[base + width, base + 2 * width)</code>对应第二个元素，以此类推。在交换元素时，并不是简单的赋值，而是用<code>memcpy</code>、<code>memset</code>等方法</strong>修改内存**。另一方面，正因为如此，<code>cmp</code>函数的两个参数也都是通用指针，我们在实现<code>cmp</code>时必须强转类型，从而实现对某一特定类型数据的比较。</p>
<h3 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h3><p>函数指针是单个变量，一堆函数指针就是一个数组。函数指针数组在<strong>操作系统内核代码</strong>中十分常见，我们用一个简单的例子，模拟一个情形：用户不停发来请求，操作系统根据请求的不同，调用不同的<strong>处理函数（handler）</strong>，响应用户请求。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler0</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[%s]handling request 0\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">handler1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[%s]handling request 1\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">handler2</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[%s]handling request 2\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> (*handlers[<span class="number">3</span>])(<span class="type">const</span> <span class="type">char</span> *) </span><br><span class="line">	= &#123; handler0, handler1, handler2 &#125;;</span><br><span class="line"><span class="comment">// 含有三个函数指针的函数指针数组，数组名为 handlers</span></span><br><span class="line"><span class="comment">// 每一个指针都指向一个返回值为 void，需要一个 const char * 参数的函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> request;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;request);    <span class="comment">// 输入请求号</span></span><br><span class="line">		<span class="keyword">if</span> (request == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 如果是 -1 就结束</span></span><br><span class="line">		handlers[request](<span class="string">&quot;This is kernel&quot;</span>);</span><br><span class="line">           <span class="comment">// 调用对应的处理函数</span></span><br><span class="line">           <span class="comment">// handlers 是处理函数的数组</span></span><br><span class="line">           <span class="comment">// request 表示请求号，handlers[request] 表示对应的处理函数的指针</span></span><br><span class="line">           <span class="comment">// 函数指针后直接加括号，放入参数，即可调用</span></span><br><span class="line">           <span class="comment">// 当然这里如果输入大于 2 的数程序就崩溃了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="返回函数指针的函数（雾）"><a href="#返回函数指针的函数（雾）" class="headerlink" title="返回函数指针的函数（雾）"></a>返回函数指针的函数（雾）</h3><p><strong>函数指针是一种指针，是一个整数，一个函数当然可以返回一个指针，这个指针当然可以是函数指针。</strong>写着比较套娃，直接看例子，这种情况一般不会用到，但是在有的地方可能会看到。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个求圆的面积的普通函数，参数为一个 int，返回值是 double</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.14</span> * r * r; <span class="comment">// 整数遇上浮点数，都转化为浮点数计算，别忘了！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> (*return_func_ptr(<span class="type">void</span>))(<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 这是一个返回函数指针的函数</span></span><br><span class="line">    <span class="comment">// 函数名是 return_func_ptr</span></span><br><span class="line">    <span class="comment">// 函数本身不需要参数，所以参数列表写 void，也可以留空</span></span><br><span class="line">    <span class="comment">/* 函数的返回值是一个函数指针，</span></span><br><span class="line"><span class="comment">            这个函数指针指向一个返回值为 double、需要一个 int 作为参数的函数 */</span></span><br><span class="line">	<span class="keyword">return</span> solve; <span class="comment">// 函数名就是函数指针，所以返回了 solve 函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ans: %2.f\n&quot;</span>, return_func_ptr()(<span class="number">10</span>));</span><br><span class="line">    <span class="comment">// 调用 return_func_ptr 函数对应的是 `return_func_ptr()`</span></span><br><span class="line">    <span class="comment">// 调用后的返回值是一个函数指针，可以继续调用，所以后面直接跟上了 `(10)`</span></span><br><span class="line">    <span class="comment">// 如果写的是 `(*((*return_func_ptr)()))(10)` 可以吗（?）</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果你能理解这段奇怪的代码，说明你对函数指针的认识到位啦！</p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第十四期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%8D%81%E5%9B%9B%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="数据结构期末复习"><a href="#数据结构期末复习" class="headerlink" title="数据结构期末复习"></a>数据结构期末复习</h2><h3 id="复习知识点自查"><a href="#复习知识点自查" class="headerlink" title="复习知识点自查"></a>复习知识点自查</h3><blockquote>
<p><strong>考试时查看不了上机作业，因此大家一定要记得将前七次作业的网页保存为PDF格式存在本地（<code>Ctrl+P</code>）</strong></p>
</blockquote>
<h4 id="栈与队列（第四次作业）"><a href="#栈与队列（第四次作业）" class="headerlink" title="栈与队列（第四次作业）"></a>栈与队列（第四次作业）</h4><ul>
<li>数据从哪儿存入，从哪儿取出，<strong>注意选填一定要看清楚栈顶、队头、队尾在哪儿（选择题13，填空题6）</strong>；</li>
<li>中缀表达式与后缀表达式的转换（选择题6，填空题5），<strong>如果不确定可以本地运行代码得结果</strong>；</li>
<li>栈的合法输出与容量（选择题3、4、5、12，填空题2、4）；</li>
<li>栈与队列的概念、性质、应用等（选择题1、2、8、9、11）。</li>
</ul>
<h4 id="树（第五次作业）"><a href="#树（第五次作业）" class="headerlink" title="树（第五次作业）"></a>树（第五次作业）</h4><blockquote>
<p>对于选填中的计算题，如果不确定怎么算，或者想验证结果是否正确，只需要列举一棵具体的树。</p>
</blockquote>
<ul>
<li><strong>各名词术语（结点的度、树的度、叶节点、树的深度等）</strong>（选择题1、2、5，填空题2、3）；</li>
<li>二叉树的性质（选择题3、4、6，填空题1、5、7、9）；</li>
<li><strong>每年都考！！！通过给出的两个遍历序列，求二叉树的另一个遍历序列（填空题6）</strong>；</li>
<li><strong>每年都考！！！哈夫曼编码以及带权路径长度计算（选择题9、10，填空题10）</strong>。</li>
</ul>
<h4 id="查找与排序（第六次作业）"><a href="#查找与排序（第六次作业）" class="headerlink" title="查找与排序（第六次作业）"></a>查找与排序（第六次作业）</h4><ul>
<li>各种算法的查找长度、比较次数、每一趟的结果等题目，<strong>实际是考察不同算法的实现原理</strong>（选择题1、2、3、4、7、8、9、10、11、14、15，填空题1、2、5），请一定对照老师的ppt复习！！！</li>
<li><strong>每年都考！！！散列表及其冲突处理（选择题6，填空题4）</strong>。</li>
</ul>
<h4 id="图（第七次作业）"><a href="#图（第七次作业）" class="headerlink" title="图（第七次作业）"></a>图（第七次作业）</h4><ul>
<li>图的顶点、边、邻接表、邻接矩阵的关系（选择题1、2、3、4，填空题1、2、3、7）；</li>
<li><strong>每年都考！！！<code>Kruskal</code>和<code>Prim</code>算法求最小生成树（填空题5、6）</strong>；</li>
<li><strong>每年都考！！！用迪杰斯特拉算法求最短路径（填空题9）</strong>。</li>
</ul>
<h3 id="考试可能用到的函数模版"><a href="#考试可能用到的函数模版" class="headerlink" title="考试可能用到的函数模版"></a>考试可能用到的函数模版</h3><h4 id="中缀转后缀"><a href="#中缀转后缀" class="headerlink" title="中缀转后缀"></a>中缀转后缀</h4><blockquote>
<p>该模版可以帮助你验证“中缀转后缀”的选填题目结果</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 将一个不含空格的中缀表达式s数组转化成后缀表达式；</span></span><br><span class="line"><span class="comment"> 数字存储在num中，运算符存储在op中，且按总体下标顺序，</span></span><br><span class="line"><span class="comment"> 插空存储，例如 (1+2)*3= 的存储方式为：</span></span><br><span class="line"><span class="comment"> num[0]=1, num[1]=2, op[2]=&#x27;+&#x27;, num[3]=3, op[4]=&#x27;*&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">512</span>];</span><br><span class="line"><span class="type">char</span> op[<span class="number">512</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Change</span><span class="params">(<span class="type">char</span> s[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j=<span class="number">0</span>, stacktop=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>;)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">            num[j] = num[j] * <span class="number">10</span> + s[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="built_in">stack</span>[++stacktop] = s[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stacktop &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>[stacktop] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    op[j++] = <span class="built_in">stack</span>[stacktop--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>[++stacktop] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stacktop &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>[stacktop]==<span class="string">&#x27;(&#x27;</span>||<span class="built_in">stack</span>[stacktop]==<span class="string">&#x27;+&#x27;</span>||<span class="built_in">stack</span>[stacktop]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    op[j++] = <span class="built_in">stack</span>[stacktop--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>[++stacktop] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">stack</span>[stacktop] != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                op[j++] = <span class="built_in">stack</span>[stacktop--];</span><br><span class="line">            stacktop--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stacktop&gt;<span class="number">-1</span>)</span><br><span class="line">        op[j++] = <span class="built_in">stack</span>[stacktop--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="后缀转中缀"><a href="#后缀转中缀" class="headerlink" title="后缀转中缀"></a>后缀转中缀</h4><blockquote>
<p>该转化的难点在于如何添加括号。基本思路为先把后缀表达式转化为表达式树，再进行中序遍历。</p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>, *<span class="title">leftpa</span>, *<span class="title">rightpa</span>;</span></span><br><span class="line">&#125;Tree; <span class="comment">// 子节点与祖先节点都需要存储，若 a 为 b 的左节点，则 b 为 a 的右祖先</span></span><br><span class="line">Tree *numjudge;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">middle_order</span><span class="params">(Tree *t)</span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="keyword">sizeof</span>(temp));</span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        middle_order(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;op!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;op==<span class="string">&#x27;*&#x27;</span>||t-&gt;op==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left-&gt;op!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(t-&gt;left-&gt;op==<span class="string">&#x27;+&#x27;</span>||t-&gt;left-&gt;op==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, t-&gt;op);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;op==<span class="string">&#x27;*&#x27;</span>||t-&gt;op==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right-&gt;op!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;rightpa!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                numjudge=t-&gt;rightpa;</span><br><span class="line">                <span class="keyword">while</span>(numjudge-&gt;rightpa!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(numjudge-&gt;rightpa-&gt;op==<span class="string">&#x27;*&#x27;</span>||numjudge-&gt;rightpa-&gt;op==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(numjudge-&gt;op==<span class="string">&#x27;+&#x27;</span>||numjudge-&gt;op==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    numjudge=numjudge-&gt;rightpa;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t-&gt;num);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;leftpa!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                numjudge=t-&gt;leftpa;</span><br><span class="line">                <span class="keyword">while</span>(numjudge-&gt;leftpa!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(numjudge-&gt;leftpa-&gt;op==<span class="string">&#x27;*&#x27;</span>||numjudge-&gt;leftpa-&gt;op==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                    numjudge=numjudge-&gt;leftpa;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        middle_order(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 根据存储好的表达式树，输出中缀表达式</span></span><br></pre></td></tr></table></figure></div>

<h4 id="前、中、后序遍历一般写法"><a href="#前、中、后序遍历一般写法" class="headerlink" title="前、中、后序遍历一般写法"></a>前、中、后序遍历一般写法</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;Basic_tree;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trade</span><span class="params">(Tree *a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">  	Visit(a);<span class="comment">// 前序遍历放在此位置</span></span><br><span class="line">    trade(a-&gt;left);</span><br><span class="line">    Visit(a);<span class="comment">// 中序遍历放在此位置</span></span><br><span class="line">    trade(a-&gt;right);</span><br><span class="line">  	Visit(a);<span class="comment">// 后序遍历放在此位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例如，要求前序遍历输出每个节点的值，则 Visit() 函数可写为：</span></span><br><span class="line"><span class="comment">// printf(&quot;%d\n&quot;, a-&gt;num);</span></span><br></pre></td></tr></table></figure></div>

<h4 id="遵循一定规则的树节点插入"><a href="#遵循一定规则的树节点插入" class="headerlink" title="遵循一定规则的树节点插入"></a>遵循一定规则的树节点插入</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;Basic_tree;</span><br><span class="line">Basic_tree *<span class="title function_">insert</span><span class="params">(Basic_tree *root, <span class="type">int</span> x, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    high++;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        root = (Basic_tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Basic_tree)); <span class="comment">// 一定要记得malloc</span></span><br><span class="line">        root-&gt;num = x;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>; <span class="comment">// 因为递归涉及非空判断，所以这个地方一定要初始化！</span></span><br><span class="line">        root-&gt;height = high;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;num)</span><br><span class="line">        root-&gt;left = insert(root-&gt;left, x, high);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;right = insert(root-&gt;right, x, high); <span class="comment">// 递归调用即可</span></span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 一定要记得有返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该函数调用时，写法应为 <code>root = insert(root,int x,int high);</code>，即：每次更新<code>root</code>值。</p>
<h4 id="更简便的树的实现方式"><a href="#更简便的树的实现方式" class="headerlink" title="更简便的树的实现方式"></a>更简便的树的实现方式</h4><blockquote>
<p>如果你实在弄不明白指针和<code>malloc</code>，你可以考虑<strong>纯数组实现树。</strong></p>
</blockquote>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> left, right;</span><br><span class="line">&#125; tree[<span class="number">100</span>]; <span class="comment">// 假设树不超过 100 个节点</span></span><br><span class="line"><span class="comment">// 每读入一个新节点，就存入数组中</span></span><br><span class="line"><span class="comment">// left 和 right 即为左孩子和右孩子在数组中的下标</span></span><br><span class="line"><span class="comment">// 如果用指针实现，无效值应设置为 NULL；类似地，这里可以选择 -1 为无效值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 中序遍历示例</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">-1</span>) &#123;</span><br><span class="line">        traverse(tree[i].left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;num is %d\n&quot;</span>, tree[i].num);</span><br><span class="line">        traverse(tree[i].right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="其他科目复习材料"><a href="#其他科目复习材料" class="headerlink" title="其他科目复习材料"></a>其他科目复习材料</h2><ul>
<li><a class="link"   href="https://bhpan.buaa.edu.cn/link/8BA58945A64405F74375884A0AC53A76" >数分材料 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://bhpan.buaa.edu.cn/link/487129DA010A4EB055E7366C47C42640" >离散材料 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://bhpan.buaa.edu.cn/link/4C1FF6DAEDF265AB7804D0F2A88E842A" >基物材料 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://bhpan.buaa.edu.cn/link/E4D5D30CF396357025B6D4578B373843" >史纲材料 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h2 id="一些复习建议"><a href="#一些复习建议" class="headerlink" title="一些复习建议"></a>一些复习建议</h2><h4 id="数分"><a href="#数分" class="headerlink" title="数分"></a>数分</h4><ul>
<li>看了往年题你会发现这其实是相对好做的一次考试，基本把所有类型的积分考了一遍，然后就没有然后了</li>
<li>曲线积分？曲面积分？第一类？第二类？换元？不换元？直角坐标？球坐标？柱坐标？对称？不对称？请务必搞清楚<strong>各个类型的计算公式</strong></li>
<li>基本考察计算，所以请注重草稿纸画图和演算的规范和正确。当然不排除在列式计算的基础上，对题目小小地拓展，当然这种情况一般会比较简单</li>
<li>建议比较流畅地写完三到四套卷子，<strong>期间不要参考材料，注意答题和计算的规范</strong></li>
</ul>
<h4 id="离散"><a href="#离散" class="headerlink" title="离散"></a>离散</h4><ul>
<li>线下闭卷考试<strong>大量考察</strong>定义、概念和公式定理的<strong>默写</strong>，请背熟并理解！内容参考<strong>尹宝林编著的《离散数学（第三版）》</strong></li>
<li>对偶定理？完全集？文字？相反的文字？可满足不可满足？约束出现？自由变元？解释？赋值？一定要熟练背诵各种概念，不要出现模糊</li>
<li>演算性和说理性考题的类型较固定，难度较低</li>
<li>公理系统是必考且比较麻烦的一部分<ul>
<li>阅读<strong>课件</strong>，理解公理系统是在做什么</li>
<li><strong>熟练记住公理系统的内容（显然，这个也可以考默写）</strong>，然后按照课件的思路学习一些定理的推导（较复杂的量力而行）</li>
<li>集中地做若干套往年题中的公理系统部分，大概能发现考察的规律和变形的技巧</li>
</ul>
</li>
</ul>
<h4 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h4><ul>
<li>注重基本模型和公式，不要被混乱的课件、废话连篇的教材和花里胡哨的课后习题所迷惑</li>
<li><a class="link"   href="https://www.bilibili.com/video/BV1Qt411f7nh/?spm_id_from=333.999.0.0&vd_source=974c542f6be0f124d647f2e1da0fa1ab" >一个很好地介绍了各类基本知识点的网课 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>考试主要考察基本公式和推论的应用，大题部分基本上列出三五个式子求解即可，一般不会有特别复杂的模型；小题考查地更加全面，这就看大家复习地是否全面、是否真正理解了。</li>
</ul>
<hr>
<h1 id="祝大家考试顺利！"><a href="#祝大家考试顺利！" class="headerlink" title="祝大家考试顺利！"></a>祝大家考试顺利！</h1><p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>final-test</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第十五期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%8D%81%E4%BA%94%E6%9C%9F/</url>
    <content><![CDATA[<blockquote>
<p>查找与排序的算法很多，知识点比较多比较杂，第六次作业的编程题旨在考察大家对于不同算法的理解，并且感受不同算法的效率，总体来说是比较有趣的。在期末考试的选填中考察也比较多，希望同学们能够多花时间理解一下课件中每一种方法。</p>
</blockquote>
<h2 id="第六次作业编程题解"><a href="#第六次作业编程题解" class="headerlink" title="第六次作业编程题解"></a>第六次作业编程题解</h2><h3 id="单词查找（查找-基本题）"><a href="#单词查找（查找-基本题）" class="headerlink" title="单词查找（查找-基本题）"></a>单词查找（查找-基本题）</h3><p>这道题大家最容易出错的点在于<code>hash</code>查找的实现，值得注意的是题目中明确说明了**<code>hash</code>冲突的单词形成一有序链表**，因此这种方式中其实包含了链表的相关操作（如创建节点、查找等）。在和同学们交流的过程中，我们发现部分同学对于链表的操作已基本遗忘，在此还是建议大家复习一下，毕竟树与图的操作中也包含了不少链表的操作。</p>
<p>另外，有些同学把输入文件名写错了，这个是最亏的错误（太耽搁debug时间了），也在此希望同学们在考试时看清楚输入输出文件名。</p>
<p><del>最让猪脚气愤的是</del>，强调过很多遍的<code>\r\n</code>问题，很多同学还是不引起重视。非常多的同学使用<code>fgets</code>函数读入单词，结果只把字符串的最末一位置为<code>\0</code>，因此所有单词都会在原本的基础上多一个<code>\r</code>，因此当执行<code>strcmp(&quot;wins&quot;,&quot;wins\r&quot;)</code>自然会出问题，无论如何也查找不到。建议就是，如果大家不能保证自己对于换行符的处理完全没有问题，那请直接使用在读入时就会自动去掉换行符的函数（如<code>fscanf</code>等）。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NHASH 3001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MULT 37</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> inword[MAXSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Fourth, *Fourthptr;</span><br><span class="line"><span class="type">char</span> word[<span class="number">450000</span>][MAXSIZE];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">for</span>(p=str;*p!=<span class="string">&#x27;\0&#x27;</span>;p++)</span><br><span class="line">        h = MULT * h + *p;</span><br><span class="line">    <span class="keyword">return</span> h % NHASH;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">order_search</span><span class="params">(<span class="type">char</span> word[][MAXSIZE], <span class="type">char</span> keyword[], <span class="type">int</span> word_num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, judge=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;word_num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(keyword,word[i])==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1 %d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">            judge=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(keyword,word[i])&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(judge==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;word_num)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0 %d\n&quot;</span>, i+<span class="number">1</span>); <span class="comment">// 注意break后i不会++，因此实际比较次数为i+1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0 %d\n&quot;</span>, word_num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 还记得二维数组怎么进行形参传递吗</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bin_search</span><span class="params">(<span class="type">char</span> word[][MAXSIZE], <span class="type">char</span> keyword[], <span class="type">int</span> word_num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>, low=<span class="number">0</span>, high=word_num, judge=<span class="number">0</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(keyword,word[mid])==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1 %d\n&quot;</span>, count);</span><br><span class="line">            judge=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(keyword,word[mid])&gt;<span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(judge==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 %d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">index_search</span><span class="params">(<span class="type">char</span> word[][MAXSIZE], <span class="type">char</span> keyword[], <span class="type">int</span> wordlist[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> ptr = keyword[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>, judge=<span class="number">0</span>, low = wordlist[ptr], high = wordlist[ptr+<span class="number">1</span>]<span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(keyword,word[mid])==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1 %d\n&quot;</span>, count);</span><br><span class="line">            judge=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(keyword,word[mid])&gt;<span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(judge==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 %d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">search_in_hash</span><span class="params">(Fourthptr head, <span class="type">char</span> a[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>, judge=<span class="number">0</span>;</span><br><span class="line">    Fourthptr p;</span><br><span class="line">    <span class="keyword">for</span>(p=head;p!=<span class="literal">NULL</span>;p=p-&gt;next)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p-&gt;inword,a)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1 %d\n&quot;</span>, count);</span><br><span class="line">            judge=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p-&gt;inword,a)&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(judge==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 %d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Fourthptr <span class="title function_">insert_in_hash</span><span class="params">(Fourthptr head, <span class="type">char</span> a[])</span>&#123;</span><br><span class="line">    Fourthptr p, q=head, r;</span><br><span class="line">    r = (Fourthptr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Fourth));</span><br><span class="line">    <span class="built_in">strcpy</span>(r-&gt;inword,a);</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=head;p!=<span class="literal">NULL</span>&amp;&amp;(<span class="built_in">strcmp</span>(p-&gt;inword,a)&lt;<span class="number">0</span>);q=p,p=p-&gt;next);</span><br><span class="line">    <span class="keyword">if</span>(p==head)&#123;</span><br><span class="line">        r-&gt;next=head;</span><br><span class="line">        head=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;next=r;</span><br><span class="line">        r-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hash_search</span><span class="params">(<span class="type">char</span> word[][MAXSIZE], <span class="type">char</span> keyword[], <span class="type">int</span> word_num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, address;</span><br><span class="line">    Fourthptr <span class="built_in">list</span>[NHASH];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NHASH;i++)</span><br><span class="line">        <span class="built_in">list</span>[i]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;word_num;i++)&#123;</span><br><span class="line">        address = hash(word[i]);</span><br><span class="line">        <span class="built_in">list</span>[address] = insert_in_hash(<span class="built_in">list</span>[address], word[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    search_in_hash(<span class="built_in">list</span>[hash(keyword)], keyword);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *in;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, op, word_num, wordlist[<span class="number">27</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> pos, keyword[MAXSIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    in = fopen(<span class="string">&quot;dictionary3000.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>((<span class="built_in">fscanf</span>(in,<span class="string">&quot;%s&quot;</span>,word[i]))!=EOF)&#123;</span><br><span class="line">        pos = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(*word[i]&gt;=pos)&#123;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        wordlist[pos-<span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125; <span class="comment">// 请直接使用fscanf函数，在读入的时候去掉换行符，且索引表可以在读入的时候同步建立</span></span><br><span class="line">    word_num=i<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, keyword, &amp;op);</span><br><span class="line">    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            order_search(word, keyword, word_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            bin_search(word, keyword, word_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            index_search(word, keyword, wordlist);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            hash_search(word, keyword, word_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="comment">// 将各函数写好后，在main函数中根据逻辑调用即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="排座位（简）"><a href="#排座位（简）" class="headerlink" title="排座位（简）"></a>排座位（简）</h3><p>这道题大家有问题普遍都在第五个数据点。注意题目中<code>M</code>与<code>N</code>的关系，有可能<code>M</code>是会小于<code>N</code>的，因此对于题目中的操作说明一定要仔细阅读，并结合样例说明进行理解，不要在某些地方进行一些“自以为”的操作。最后，该题总共进行了两次大排序，两次排序的关键字是不一样的。</p>
<p>另外也有一个该题表述不那么清楚的地方，即第二个步骤中，<code>Q</code>值是需要不断更新的。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 21</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">excel</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> name[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> seat;</span><br><span class="line">&#125;student[<span class="number">501</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * p1, <span class="type">const</span> <span class="type">void</span> * p2)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">excel</span> *<span class="title">a</span> =</span> (<span class="keyword">struct</span> excel*)p1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">excel</span> *<span class="title">b</span> =</span> (<span class="keyword">struct</span> excel*)p2;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;seat != b-&gt;seat)</span><br><span class="line">        <span class="keyword">return</span> a-&gt;seat - b-&gt;seat;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a-&gt;number - b-&gt;number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * p1, <span class="type">const</span> <span class="type">void</span> * p2)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">excel</span> *<span class="title">a</span> =</span> (<span class="keyword">struct</span> excel*)p1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">excel</span> *<span class="title">b</span> =</span> (<span class="keyword">struct</span> excel*)p2;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;number - b-&gt;number;</span><br><span class="line">&#125; <span class="comment">// 关键字不同，则应该写两个比较函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, temp, latter, judge[<span class="number">501</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    FILE *in, *out;</span><br><span class="line">    in = fopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    out = fopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>); <span class="comment">// 记得是文件输出</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(in,<span class="string">&quot;%d %s %d&quot;</span>, &amp;student[i].number, student[i].name, &amp;student[i].seat);</span><br><span class="line">        judge[student[i].seat] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(student,n,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> excel),cmp);</span><br><span class="line">    temp=min(n,student[n<span class="number">-1</span>].seat);</span><br><span class="line">    latter = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=temp;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(judge[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            student[latter--].seat = i;</span><br><span class="line">            judge[i]=<span class="number">1</span>;</span><br><span class="line">            temp=min(n,student[latter].seat);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    latter=<span class="number">-1</span>; <span class="comment">// 后续需继续使用latter进行比较，因此置为-1</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(student[i].seat&gt;latter)</span><br><span class="line">            latter = student[i].seat;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(student,n,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> excel),cmp);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(student[j].seat==student[i].seat)&#123;</span><br><span class="line">                <span class="keyword">if</span>(student[j].number&gt;student[i].number)</span><br><span class="line">                    student[j].seat = ++latter;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    student[i].seat = ++latter;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(student,n,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> excel),comp); <span class="comment">// 注意两次排序的关键字是不同的</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">fprintf</span>(out,<span class="string">&quot;%d %s %d\n&quot;</span>,student[i].number,student[i].name,student[i].seat);</span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="整数排序（排序-基本题）"><a href="#整数排序（排序-基本题）" class="headerlink" title="整数排序（排序-基本题）"></a>整数排序（排序-基本题）</h3><p>题面中给了代码就按照题面的代码进行计算，不要自己另辟蹊径。不同的代码细节不同，具体比较次数肯定是不一样的。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 某些排序算法涉及递归，因此将cnt定义为全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, d, temp, count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        d=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[d])</span><br><span class="line">                d=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d!=i)&#123;</span><br><span class="line">            temp=a[d];</span><br><span class="line">            a[d]=a[i];</span><br><span class="line">            a[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp, flag=<span class="number">1</span>, count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>&amp;&amp;flag==<span class="number">1</span>;i--)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                temp=a[j];</span><br><span class="line">                a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>]=temp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">adjust</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> i, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j, temp;</span><br><span class="line">    temp=a[i];</span><br><span class="line">    j=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n<span class="number">-1</span>&amp;&amp;a[j]&lt;a[j+<span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=a[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        a[(j<span class="number">-1</span>)/<span class="number">2</span>]=a[j];</span><br><span class="line">        j=<span class="number">2</span>*j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[(j<span class="number">-1</span>)/<span class="number">2</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, temp;</span><br><span class="line">    <span class="keyword">for</span>(i=n/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        adjust(a,i,n);</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        temp=a[i];</span><br><span class="line">        a[i]=a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>]=temp;</span><br><span class="line">        adjust(a,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> tmp[], <span class="type">int</span> left, <span class="type">int</span> leftend, <span class="type">int</span> rightend)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=left, j=leftend+<span class="number">1</span>, q=left;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=leftend&amp;&amp;j&lt;=rightend)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">            tmp[q++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[q++]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=leftend)</span><br><span class="line">        tmp[q++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=rightend)</span><br><span class="line">        tmp[q++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=left;i&lt;=rightend;i++)</span><br><span class="line">        a[i]=tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> temp[], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> center;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        center = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mSort(a,temp,left,center);</span><br><span class="line">        mSort(a,temp,center+<span class="number">1</span>,right);</span><br><span class="line">        merge(a,temp,left,center,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *temp;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    temp=(<span class="type">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    mSort(a,temp,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp=a[i];</span><br><span class="line">    a[i]=a[j];</span><br><span class="line">    a[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, last;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        last=left;</span><br><span class="line">        <span class="keyword">for</span>(i=left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[left])</span><br><span class="line">                swap(a,++last,i);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a,left,last);</span><br><span class="line">        sort(a,left,last<span class="number">-1</span>);</span><br><span class="line">        sort(a,last+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    sort(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">102</span>]=&#123;<span class="number">0</span>&#125;, n, op, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;op);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            selectSort(a,n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            bubbleSort(a,n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            heapSort(a,n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            mergeSort(a,n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            quickSort(a,n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="comment">// 将各种函数封装好后，main函数里实现逻辑调用即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>虽说期末考试的编程题不会涉及图的相关知识，但是不代表大家可以对图不重视。图在期末的选填中占比较大（例如<code>Prim</code>算法原理、<code>Dijkstra</code>算法的具体实现等），因此把每道题的代码理解清楚了，也是一种很好的复习期末考试的方法。注意：在此次题解中，只会强调每道题的易错点，不再给出代码的详细注释。</p>
</blockquote>
<h2 id="第七次作业编程题解"><a href="#第七次作业编程题解" class="headerlink" title="第七次作业编程题解"></a>第七次作业编程题解</h2><h3 id="图遍历（图-基本题）"><a href="#图遍历（图-基本题）" class="headerlink" title="图遍历（图-基本题）"></a>图遍历（图-基本题）</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> visited[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;, judge=<span class="number">1</span>, a[<span class="number">105</span>][<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;, <span class="built_in">queue</span>[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(judge&lt;num)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, d);</span><br><span class="line">        judge++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line">    visited[d]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[d][i]==<span class="number">1</span>&amp;&amp;visited[i]==<span class="number">0</span>)</span><br><span class="line">            DFS(num,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, v;</span><br><span class="line">    <span class="built_in">queue</span>[<span class="number">1</span>] = d;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>,k=<span class="number">1</span>;j&lt;=k;)&#123;</span><br><span class="line">        v=<span class="built_in">queue</span>[j++];</span><br><span class="line">        <span class="keyword">if</span>(visited[v] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(judge &lt; num)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">            judge++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, v);</span><br><span class="line">        visited[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[v][i]==<span class="number">1</span>&amp;&amp;visited[i]==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">queue</span>[++k] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ding_num, bian_num, x, y, delete;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;ding_num, &amp;bian_num);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=bian_num;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        a[x][y]=<span class="number">1</span>;</span><br><span class="line">        a[y][x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;delete);</span><br><span class="line">    DFS(ding_num,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(visited));</span><br><span class="line">    judge=<span class="number">1</span>;</span><br><span class="line">    BFS(ding_num,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(visited));</span><br><span class="line">    judge=<span class="number">1</span>;</span><br><span class="line">    visited[delete]=<span class="number">1</span>;</span><br><span class="line">    DFS(ding_num<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(visited));</span><br><span class="line">    judge=<span class="number">1</span>;</span><br><span class="line">    visited[delete]=<span class="number">1</span>;</span><br><span class="line">    BFS(ding_num<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="独立路径数计算"><a href="#独立路径数计算" class="headerlink" title="独立路径数计算"></a>独立路径数计算</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> order;</span><br><span class="line">    <span class="type">int</span> adjvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ver</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;graph[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> visited[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;, path[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;, ding_num, bian_num, k;</span><br><span class="line"><span class="keyword">struct</span> edge *<span class="title function_">insert</span><span class="params">(<span class="keyword">struct</span> edge *<span class="built_in">list</span>, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">    p = (<span class="keyword">struct</span> edge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> edge));</span><br><span class="line">    p-&gt;order = b;</span><br><span class="line">    p-&gt;adjvex = a;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">list</span> = p;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        q-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(v==ding_num<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;pos<span class="number">-1</span>;k++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[k]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, path[k]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(p=graph[v].link;p!=<span class="literal">NULL</span>;p=p-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[p-&gt;adjvex]==<span class="number">0</span>)&#123;</span><br><span class="line">            path[pos]=p-&gt;order;</span><br><span class="line">            visited[p-&gt;adjvex]=<span class="number">1</span>;</span><br><span class="line">            DFS(p-&gt;adjvex,pos+<span class="number">1</span>);</span><br><span class="line">            visited[p-&gt;adjvex]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, ord, v1, v2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;ding_num, &amp;bian_num);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;bian_num;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;ord, &amp;v1, &amp;v2);</span><br><span class="line">        graph[v1].link=insert(graph[v1].link,v2,ord);</span><br><span class="line">        graph[v2].link=insert(graph[v2].link,v1,ord);</span><br><span class="line">    &#125;</span><br><span class="line">    visited[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    DFS(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="最少布线（图）"><a href="#最少布线（图）" class="headerlink" title="最少布线（图）"></a>最少布线（图）</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 932767</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> order;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;line[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * a, <span class="type">const</span> <span class="type">void</span> * b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cost=<span class="number">0</span>, temp[<span class="number">305</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Prim</span><span class="params">(<span class="keyword">struct</span> Node weights[][<span class="number">305</span>], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> minweight[<span class="number">305</span>], edges[<span class="number">305</span>], min, i, j, k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        minweight[i]=weights[<span class="number">0</span>][i].weight;</span><br><span class="line">        edges[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    edges[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    minweight[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        min = INFINITY;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minweight[j]!=<span class="number">0</span>&amp;&amp;minweight[j]&lt;min)&#123;</span><br><span class="line">                min = minweight[j];</span><br><span class="line">                k=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp[i<span class="number">-1</span>]=weights[edges[k]][k].order;</span><br><span class="line">        cost+=weights[edges[k]][k].weight;</span><br><span class="line">        minweight[k]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(weights[k][j].weight&lt;minweight[j])&#123;</span><br><span class="line">                minweight[j]=weights[k][j].weight;</span><br><span class="line">                edges[j]=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, ding_num, bian_num, v1, v2, id, wei;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">305</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">305</span>;j++)&#123;</span><br><span class="line">            line[i][j].weight=INFINITY;</span><br><span class="line">            line[i][j].order=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;ding_num, &amp;bian_num);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;bian_num;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;id, &amp;v1, &amp;v2, &amp;wei);</span><br><span class="line">        line[v1][v2].order=id;</span><br><span class="line">        line[v1][v2].weight=wei;</span><br><span class="line">        line[v2][v1].order=id;</span><br><span class="line">        line[v2][v1].weight=wei;</span><br><span class="line">    &#125;</span><br><span class="line">    Prim(line,ding_num);</span><br><span class="line">    qsort(temp,ding_num<span class="number">-1</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>),cmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cost);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ding_num<span class="number">-2</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, temp[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="北京地铁乘坐线路查询（202205）"><a href="#北京地铁乘坐线路查询（202205）" class="headerlink" title="北京地铁乘坐线路查询（202205）"></a>北京地铁乘坐线路查询（202205）</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCOUNT 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 32767</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> ischange;</span><br><span class="line">    <span class="type">char</span> name[MAXSIZE];</span><br><span class="line">&#125;station[MAXCOUNT];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lingjiejuzhen</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> line;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;vertex[MAXCOUNT][MAXCOUNT];</span><br><span class="line"><span class="type">int</span> spath[MAXCOUNT]=&#123;<span class="number">0</span>&#125;, stationtotal=<span class="number">0</span>, path[MAXCOUNT][MAXCOUNT];</span><br><span class="line"><span class="type">void</span> <span class="title function_">floyd</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;stationtotal;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;stationtotal;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j&amp;&amp;vertex[i][j].weight&lt;INFINITY)</span><br><span class="line">                path[i][j]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;stationtotal;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;stationtotal;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;stationtotal;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vertex[i][j].weight&gt;vertex[i][k].weight+vertex[k][j].weight)&#123;</span><br><span class="line">                    vertex[i][j].weight=vertex[i][k].weight+vertex[k][j].weight;</span><br><span class="line">                    path[i][j]=path[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    FILE *in;</span><br><span class="line">    <span class="type">int</span> i, j, k, v1, v2, judge, change, linenum, stationnum, totalline;</span><br><span class="line">    <span class="type">int</span> shi=<span class="number">0</span>, zhong=<span class="number">0</span>, count=<span class="number">1</span>, temp[MAXCOUNT]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> s[MAXSIZE]=&#123;<span class="number">0</span>&#125;, begin[MAXSIZE]=&#123;<span class="number">0</span>&#125;, end[MAXSIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, begin, end);</span><br><span class="line">    in = fopen(<span class="string">&quot;bgstations.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXCOUNT;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAXCOUNT;j++)&#123;</span><br><span class="line">            vertex[i][j].weight=INFINITY;</span><br><span class="line">            vertex[i][j].line=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(in,<span class="string">&quot;%d&quot;</span>,&amp;totalline);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;totalline;i++)&#123;</span><br><span class="line">        v1=<span class="number">-1</span>;</span><br><span class="line">        v2=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">fscanf</span>(in,<span class="string">&quot;%d %d&quot;</span>,&amp;linenum,&amp;stationnum);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;stationnum;j++)&#123;</span><br><span class="line">            judge=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">            <span class="built_in">fscanf</span>(in,<span class="string">&quot;%s %d&quot;</span>,s,&amp;change);</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;stationtotal;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(station[k].name,s)==<span class="number">0</span>)&#123;</span><br><span class="line">                    judge=<span class="number">0</span>;</span><br><span class="line">                    v1=k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(judge==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(station[stationtotal].name,s);</span><br><span class="line">                station[stationtotal].ischange=change;</span><br><span class="line">                v1=k;</span><br><span class="line">                stationtotal++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v2!=<span class="number">-1</span>)&#123;</span><br><span class="line">                vertex[v1][v2].weight=<span class="number">1</span>;</span><br><span class="line">                vertex[v2][v1].weight=<span class="number">1</span>;</span><br><span class="line">                vertex[v2][v1].line=linenum;</span><br><span class="line">                vertex[v1][v2].line=linenum;</span><br><span class="line">            &#125;</span><br><span class="line">            v2=v1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(in);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;stationtotal;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(station[i].name,begin)==<span class="number">0</span>)</span><br><span class="line">            shi=i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(station[i].name,end)==<span class="number">0</span>)</span><br><span class="line">            zhong=i;</span><br><span class="line">    &#125;</span><br><span class="line">    floyd(shi,zhong);</span><br><span class="line">    temp[<span class="number">0</span>]=zhong;</span><br><span class="line">    judge=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=zhong,j=<span class="number">0</span>;i!=shi;)&#123;</span><br><span class="line">        temp[++j] = path[shi][i];</span><br><span class="line">        i=path[shi][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=j;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(judge==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s-%d&quot;</span>, station[temp[i]].name, vertex[temp[i]][temp[i<span class="number">-1</span>]].line);</span><br><span class="line">            judge=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(vertex[temp[i+<span class="number">1</span>]][temp[i]].line==vertex[temp[i]][temp[i<span class="number">-1</span>]].line)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;(%d)-&quot;</span>, count);</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">                judge=<span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d)-%s\n&quot;</span>, count, station[temp[<span class="number">0</span>]].name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>answers</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第十六期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E5%8D%81%E5%85%AD%E6%9C%9F/</url>
    <content><![CDATA[<blockquote>
<p>2023.06.23</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>首先感谢大家一个学期来的陪伴、努力、支持和配合！</strong>作为一门信息类专业通识性质的课程，本学期的数据结构和程序设计课程可以说是画上一个圆满的句号了。</p>
<p>当然，这个句号画得并不容易：你可能因为平时作业和练习的 bug 而 de 得焦头烂额，你可能绞尽脑汁也不能理解某个算法，你可能因为考试的难度而心灰意冷。说起来，这次期末考试的难度确实比较大，考察的内容也是应用性的题目，超出了基本编程的范畴，所以不理想也正常，大可不必放在心上。老师的原话是，“考试有关的，分数有关的事情，都特别微妙”，所以大家不必为此焦虑担心。</p>
<p>不论如何，课程本身算是结束啦。现在，大家还是好好想想专业选择的问题和暑假去哪玩吧！</p>
<h2 id="猪脚说是怎么写的呢"><a href="#猪脚说是怎么写的呢" class="headerlink" title="猪脚说是怎么写的呢"></a>猪脚说是怎么写的呢</h2><p>猪脚说使用了轻量级标记语言 markdown 编写，每个文件是 .md 后缀，是一个纯文本文件，即，用记事簿也可以打开。</p>
<p>如果我们想想一篇课程报告、学习材料等的构成，无非包括以下几个方面</p>
<ul>
<li>各级标题</li>
<li>正文</li>
<li>公式</li>
<li>图表</li>
<li>代码块</li>
<li>引用性、标注性内容</li>
</ul>
<p>markdown 支持上述形式的编辑。假设你已经把所有文字写好，你只需要在其中<strong>加入 markdown 语言的一些语法标记</strong>，就可以成功导出你想要的格式的文本，这实际上避免了 word 等软件内容过于繁杂的问题，使得编辑这件事情更加简单。</p>
<p>例如</p>
<ul>
<li><p>各级标题：我们看到，<strong>在标题内容前加上若干个井号和一个空格</strong>，后面的内容就会被渲染成不同大小的标题。当然，不支持无限级的标题，六级标题已经足够。</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/IMG_3731.JPG"
                      alt="IMG_3731" style="zoom:8%;" 
                >
</li>
<li><p>序号：各级序号实际上是一系列的<strong>减号和对齐</strong>构成的。</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/IMG_3734.JPG"
                      alt="IMG_3734" style="zoom:8%;" 
                >
</li>
<li><p>代码：<strong>代码块对应三对反引号，其中前三个反引号后写上语言类型。</strong>markdown 支持很多语言，并且写法比较随意 —— 你可以写 C 或 c，可以写 c++ 或 cpp，可以写 py 或 python，可以写 sh 或 shell 等。<strong>行内代码对应一对反引号。</strong></p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/IMG_3745.JPG"
                      alt="IMG_3745" style="zoom:10%;" 
                >

  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/IMG_3742.JPG"
                      alt="IMG_3742" style="zoom:14%;" 
                >
</li>
<li><p>引用内容：通过<strong>一个右尖括号打头，直到空行结束</strong>，中间的都是引用内容。这实际只是把正文换了一种形式展现，在引用内容中同样可以插入各级标题、代码、公式、图片等内容。</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/截屏2023-06-21 16.02.38.png"
                      alt="截屏2023-06-21 16.02.38" style="zoom:25%;" 
                >

<hr>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/截屏2023-06-21 16.03.41.png"
                      alt="截屏2023-06-21 16.03.41" style="zoom:25%;" 
                >
</li>
<li><p>更多内容可以参考<a class="link"   href="https://blog.csdn.net/u014061630/article/details/81359144" >这篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这里就不再赘述啦。</p>
</li>
<li><p>公式：<strong>markdown 支持 latex 公式。</strong>其中，latex 是一种排版系统，比较复杂。latex 用于书写数学公式非常方便。我们首先明确，上标是<code>^</code>，下标是<code>_</code>，每一个<strong>公式单元</strong>都用一对<code>&#123;&#125;</code>括起来。</p>
</li>
</ul>
<p>$$<br>\Alpha\beta\sum_{i&#x3D;0}^{k}\frac{a_{i+1}^2}{2i}\int_{a_i}^{a_{i+1}}f(x_i)\text{d}x<br>$$</p>
<p>上面这一坨公式，对应的 latex 是</p>
<div class="highlight-container" data-rel="Latex"><figure class="iseeu highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\Alpha</span><span class="keyword">\beta</span></span><br><span class="line"><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=0&#125;<span class="built_in">^</span>&#123;k&#125;</span><br><span class="line"><span class="keyword">\frac</span>&#123;a<span class="built_in">_</span>&#123;i+1&#125;<span class="built_in">^</span>2&#125;&#123;2i&#125;</span><br><span class="line"><span class="keyword">\int</span><span class="built_in">_</span>&#123;a<span class="built_in">_</span>i&#125;<span class="built_in">^</span>&#123;a<span class="built_in">_</span>&#123;i+1&#125;&#125;f(x<span class="built_in">_</span>i)</span><br><span class="line"><span class="keyword">\text</span>&#123;d&#125;x</span><br></pre></td></tr></table></figure></div>

<ol>
<li>公式开头的两个希腊字母 $\Alpha$ 和 $\beta$ 对应<code>\Alpha\beta</code>，因为很显然它们并不在我们的键盘上，所以需要通过<strong>转义字符</strong>实现。特别地，如果第一个字母是大写，对应大写的希腊字母，小写对应小写的希腊字母。</li>
<li>求和号对应<code>\sum_&#123;&#125;^&#123;&#125;</code>，第一对花括号是下标，第二对花括号是上标。</li>
<li>分式对应<code>\frac&#123;&#125;&#123;&#125;</code>，第一对花括号是分子，第二对花括号是分母，这里我们看到分子同时有上下标，分别对应了<code>_&#123;i+1&#125;</code>和<code>^2</code>，其中<strong>下标是一个复杂的表达式而非单个字符，所以还需要一对花括号括起来</strong>。</li>
<li>积分（integral）对应<code>\int_&#123;&#125;^&#123;&#125;</code>，第一对花括号是积分下限，第二对花括号是积分上限。</li>
<li>在规范的公式中，积分式的那个 d 是普通文本而非斜体的，所以用了<code>\text&#123;&#125;</code>将其包括，呈现出非斜体的样式。</li>
</ol>
<p>所以我们看到，latex 数学公式无非一堆转义字符套来套去，只要记住常用的转义字符，即可方便书写。更多的符号请看<a class="link"   href="https://blog.csdn.net/YEN_CSDN/article/details/79966985" >这篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>如果要在 markdown 中插入行间或行内公式，用到的是<strong>美元符号</strong>，例如上面一段文字对应的源代码为</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/截屏2023-06-21 16.26.58.png"
                      alt="截屏2023-06-21 16.26.58" style="zoom:30%;" 
                >

<p>当然，编辑 markdown 是不需要手敲源代码的，很多软件提供了便捷的编辑方式，你需要做的只有</p>
<ul>
<li><p><strong>找一个好用的 markdown 编辑软件</strong></p>
<p>  typora 是一个很好的例子，当然正版需要充一点钱购买，支持在多个设备上使用。vscode 也有很多类似的插件，支持快捷键、实时预览效果、导出 pdf 等。</p>
</li>
<li><p><strong>熟悉快捷键</strong></p>
<p>  例如，在助教的 typora 中，一级标题对应<code>command + 1</code>，引用对应<code>command + option + Q</code>，粗体对应<code>command + B</code>，代码块对应<code>command + option + C</code>，行内代码对应<code>control + ` </code>，分点只需要输入一个<code>-</code>再敲一下空格。Windows 系统也有一套快捷键，可以很方便地编辑各类内容。一般情况下，通过常规模式编辑内容即可，也可以切换到源代码模式查看。</p>
</li>
<li><p><strong>熟悉 latex 常用公式符号</strong></p>
<p>  如果你需要书写很多公式的话，有必要记一些常用的 latex 语法。但是，markdown 的语法基本不用记忆。</p>
</li>
</ul>
<p>markdown 的语法只是规定了文本应该以什么形式呈现，但是<strong>没有规定具体的样式</strong>，如字体、字号、颜色等属性。这些东西需要通过 css 设置，关于 css 后文会介绍。一般来说，软件自带并且网上也有很多 css 样式模板，直接套用即可。</p>
<h2 id="我们还应做什么"><a href="#我们还应做什么" class="headerlink" title="我们还应做什么"></a>我们还应做什么</h2><p>一学期的 ds 学习，我们学到了一些数据结构的知识，并通过 C 语言实现了它们。作为基础性的重要知识，通过 C 语言编写数据结构能帮助我们直观理解它们的基本原理，并进一步强化 C 语言编程能力；作为不可或缺的代码组成部分，更高级的语言则为我们封装了大量高效的数据结构，供编程者便捷使用。</p>
<ul>
<li>C++ 的标准模板库（Standard Template Library，STL）提供了常见的数据结构，只需要通过<code>#include &lt;stack&gt;</code> <code>#include &lt;queue&gt;</code>等头文件包含即可使用。常见的有向量容器（可变长数组）<code>vector</code>、集合容器（内部自动排序且不含重复元素）<code>set</code>、关联容器（内部自动排序的“键-值对”集合）<code>map</code>、队列<code>queue</code>、栈<code>stack</code>、优先队列<code>priority_queue</code>等。</li>
<li>Java 提供了更加丰富的集合框架和接口，常见的有可变长数组<code>ArrayList</code>、链表<code>LinkedList</code>、自动排序集合<code>SortedSet</code>、散列表<code>Hashtable</code>、红黑树<code>TreeMap</code>、哈希桶<code>HashMap</code>等。</li>
</ul>
<blockquote>
<p>以 C++ 和 Java 为代表的面向对象语言，会在数据结构的基础上封装函数，我们可以理解成，<strong>函数也是结构体的成员</strong>。所以，假设我们有一个数据结构对象<code>a</code>，我们会看到类似<code>a.pop()</code> <code>a.push(10)</code> <code>a.find(&quot;hello&quot;)</code> <code>a.remove(-1)</code> <code>a.get(12)</code> <code>a.getFirst()</code>等语句。很显然，我们不需要自己编写各类函数了。</p>
<p>此外，面向对象语言为遍历数据结构提供了一种叫做<strong>迭代器（iterator）</strong>的东西。迭代器封装了“是否还有下一个元素”“获取当前元素”“往后挪一个位置”等函数，通过很简便的代码就可以实现遍历功能。</p>
</blockquote>
<p><strong>了解各类数据结构的概念、特性、实现思路，在编写代码时选择合适而高效的数据结构，是永恒的命题。</strong>以上一些介绍虽不包含具体知识，但足以说明，在未来，我们需要更加注重数据结构的理论，而编程语言也会提供更加简便高效的操作数据结构的手段。</p>
<p>当然，同学们不要见到这些东西就开始犯难，心想“我连作业和考试的 bug 都搞不清楚，C 语言也没学多深，为什么要讲这些东西呢？”<strong>事实上，未来你很难遇到一门课，教你一门编程语言的语法、教你怎么下载一个编程软件、怎么配置编程环境等知识了。</strong>所以，我们必须在这发生之前就告诉你，你在未来可能遇到一门课，</p>
<ul>
<li>要求你使用 C++ 的 STL 编写算法。C++ 的输入输出方式和 C 有什么不同？各个类型的模板内部封装了哪些函数？这都是你需要自学的内容，因为，算法课只负责告诉你算法的数学逻辑，而不负责具体的编程实现。</li>
<li>要求你使用 C 的进阶知识编写操作系统的代码。什么是可变参数列表？我如何自己写出来一个<code>printf</code>？什么是函数指针？如何操作一个有很多文件的 C 语言项目？这都是需要你自己研究的内容，因为，操作系统课只负责传授理论知识，而不会教你 C 语言。</li>
<li>要求你使用 Java 完成综合性编程题。Java 环境怎么配？Java 语法是是什么？Java 怎么写才规范？或许没有人告诉你答案，因为，面向对象程序设计课程讲述的是“面向对象”思想，而非 Java 语言教学。</li>
</ul>
<p>所以，大家会在猪脚说中看到我们频繁地介绍一些课程内容以外的知识、频繁地用尽可能易懂的语言介绍某些规范、某些设计、某些思想，这是有必要的。数据结构课是一门内容并不那么复杂（虽然题目比较复杂）的课程，借着这一个机会，<strong>我们尽可能为大家提供更开阔的视野</strong>。回顾一下猪脚说讲过的一些重点内容</p>
<ul>
<li>C 语言指针详解：第一期</li>
<li><code>qsort</code>、C 结构体、C 标准库文件操作：第二期</li>
<li>声明与定义、二维数组：第三期</li>
<li>数据结构之引入：第四期</li>
<li>面向对象的思想介绍、计算机的存储结构：第五期 Part II</li>
<li>新型双向链表、宏：第六期</li>
<li>C 项目与头文件：第八期</li>
<li>树的理论：第十期</li>
<li>堆：第十一期</li>
<li>函数指针：第十三期</li>
</ul>
<p><strong>接下来，我们从计算机和软件相关的角度，介绍一些同学们可以在暑假探索的东西。</strong></p>
<ul>
<li><p><strong>了解一门面向对象的编程语言</strong></p>
<ul>
<li>C++：在 C 的基础上改进，增加了引用数据类型、自动类型、类、成员函数等内容，具备面向对象基本的封装、继承、多态等特性，上手快，但是学到后面可能感觉比较复杂。<a class="link"   href="https://www.bilibili.com/video/BV1dE41167hJ" >wk 老师的网课好 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Java：纯面向对象语言，语法和 C 相近，但是初步上手可能有点复杂（一个 Hello World 程序就有点麻烦）。Java 的代码量会偏大，但是整体的逻辑会给人比较清晰的感觉。<a class="link"   href="https://www.bilibili.com/video/BV1DJ411B7cG" >wk 老师的网课好 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>配置 <strong>Linux 虚拟机</strong>，了解一些常用的 Linux 命令。进一步地，可以了解 Shell 编程。你可以参考<a class="link"   href="https://www.bilibili.com/video/BV1WY4y1H7d3" >尚硅谷的课程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>了解 <strong>C 语言 Linux 系统编程</strong>。系统编程是 C 语言的更加底层的应用，如，如何写一个程序强制关闭你的微信，如何运行多个程序并且让它们相互通信，如何用更底层、更快速的方式操作、管理文件等。系统编程能够让你进一步了解 C 的规范、了解操作系统的底层原理、了解大型代码项目的管理。<a class="link"   href="https://space.bilibili.com/337344256" >这个网课非常非常好 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>了解<strong>计算机底层、硬件方面的知识</strong>，如，一加一这个计算是怎么通过电路实现的，我们常说的内存到底是什么东西，CPU 如何工作、这和我们的程序有什么关系等。或许你可以从<a class="link"   href="https://www.bilibili.com/video/BV1Ba4y1V7GD" >这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>了解到大体的知识框架。</p>
</li>
<li><p>了解<strong>网页</strong>是怎么做出来的。简单来说，一个网页的前端包含以下三个部分</p>
<ul>
<li><p><strong>html：描述网页中元素的构成</strong>，由一对一对的标签构成，例如</p>
  <div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我来演示演示！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- 这是一级标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>这里有一个链接，点击跳转百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!-- 这是跳转链接 --&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>  这一段代码展现出来就是这个样子</p>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/截屏2023-06-21 18.16.04.png"
                      alt="截屏2023-06-21 18.16.04" style="zoom:40%;" 
                >
</li>
<li><p><strong>css：描述各类元素的样式。</strong>比如，前面我们谈到的 markdown，也是通过 css 来设置样式。例如</p>
  <div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置超链接文本的颜色 */</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#4183C4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置各级标题的位置、外边距、字体粗细、行高、鼠标悬浮形状 */</span></span><br><span class="line"><span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-tag">h3</span>,</span><br><span class="line"><span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-tag">h6</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.4</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: text;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置水平分割线的高度、边距、颜色、边框等属性 */</span></span><br><span class="line">hr &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">16px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e7e7e7</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">0</span> none;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>JavaScript：实现网页的一些控制逻辑。</strong>例如可以遍历一个图片数组展示图片、可以在用户名为空时弹出一个提醒等。</p>
</li>
</ul>
<p>  当然，初步了解即可。上述的网页三件套能够写出一个静态的网页，如果要实现动态的网页，还必须有后端的数据库和接口，这就是另一个故事了。简单了解网页前端，你就踏入了一个新的编程领域，html 这种标签描述结构的规则，和 markdown 有着异曲同工之妙；css 能够帮助你学会样式设计的技巧，是真正意义上的从零开始 diy；JavaScript 则是面向对象的，易于操作网页的一门新的编程语言。</p>
<p>  大家是信息大类的学生，一年下来，你听过、了解过下面哪些名词呢？如果结果不是那么理想，是不是有必要自己给自己充充电？</p>
<blockquote>
<p>github&#x2F;gitee 与仓库、git 与版本管理、面向对象、封装、抽象、博客 blog、操作系统 OS、CPU、内存、高速缓存、硬盘、磁盘、闪存、汇编语言、虚拟内存、总线、I&#x2F;O、预处理 -&gt; 汇编 -&gt; 编译 -&gt; 链接、文件系统、文件和目录、地址、根目录、磁盘分区、内核、vi&#x2F;vim 编辑器、程序、进程、线程、虚拟机、docker、npm、数据库、SQL&#x2F;MySQL ……</p>
</blockquote>
</li>
</ul>
<h2 id="关于提问"><a href="#关于提问" class="headerlink" title="关于提问"></a>关于提问</h2><blockquote>
<p>各位的数据结构学习也已告一段落，在此，请允许助教们稍稍吐槽一下这学期中让我们<strong>肝火upup⬆️</strong>的提问吧😋大家可以当作消遣来看一看，自己判断一下哪种提问方式更有效。</p>
</blockquote>
<p>我们在开学第一节课就强调过如何提问，并不是说一定要有一个规矩、树立一种权威，而是希望大家能以一种更高效、彼此愉悦的方式与课程助教沟通。<strong>需要说明的是，大家下学期进入新的学院后，专业课的课程助教往往是正在忙着毕业的学长学姐，亦或是研究生们。他们的时间安排可能更加紧张，也未必会像我们一样及时地解决大家的问题。</strong>很多时候，问他们问题从来都是杳无音信、从不回答。这个时候，正确地问问题是非常重要的。</p>
<p>话不多说，直接上图😋（无针对性）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/IMG_5653.jpeg"
                      alt="IMG_5653" style="zoom: 35%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/IMG_5654.jpeg"
                      alt="IMG_5654" style="zoom:35%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/IMG_5655-7490608.jpeg"
                      alt="IMG_5655" style="zoom:22%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/IMG_5656-7490608.jpeg"
                      alt="IMG_5656" style="zoom:22%;" 
                >

<p>大家不妨自己评判😋上面四张图（随机挑选）中，哪些提问是有效的，哪些提问只会让人血压飙升。</p>
<p>如果你是助教，一天都是满课，下课了还要写各种实验报告和作业，突然微信提示音一响、手机一震，看见一些同学直接发来一个<code>.c</code>文件代码，啥也不说让你帮他看，你会是什么心情捏？</p>
<p>在这里分享这些内容的目的不是为了针对各位提问题的同学，而是希望大家理解，上机题目 debug、帮看大作业本应是大家自己完成的课后作业与任务，<strong>帮助大家完成作业、平时分拿满并不是助教的义务和责任，助教的存在只是为了协助老师管理班级、批改作业、查阅考试情况</strong>，各位进入大二的学习之后，遇到的很多助教的工作方式与态度会让各位对这一点有着更深的感悟。<strong>学习是自己的事，一门课程的得分并不需要任何人施以援手。</strong></p>
<h2 id="关于时间安排与规划"><a href="#关于时间安排与规划" class="headerlink" title="关于时间安排与规划"></a>关于时间安排与规划</h2><p>总体来说，任何学院与专业的大二学年的学业任务都是非常繁重的。那么助教们是如何做到在完成自身学业任务的同时，几乎秒回大家的所有提问与 debug 需求呢？下图是 <em>diandian</em> 这学期博雅报告中的一段话</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/图像2023-6-22 22.49-7490608.jpg"
                      alt="图像2023-6-22 22.49" style="zoom:33%;" 
                >

<p><del>不难看出，哪儿有大学生不疯的啊？哪儿有大学生不疯的啊？</del></p>
<p>因此，作为过来人的我们告诉大家，进入大二之后，<strong>首先以自己的学业为重</strong>，如果感觉力不从心，请一定适当放下一些学生工作与无关紧要的社交活动。大二学期末的各种报告、大作业与实验真的会特别多，因此也建议大家不要把事情都堆在期末完成，这会严重影响你的烤漆复习。</p>
<blockquote>
<p>补充说明的是，<strong>实验（lab）</strong>是一个比较泛化的说法，物理学的各类仪器、化学的各种瓶瓶罐罐，乃至计算机软件的编程题、代码补全、理论问答，都可以算做实验。这里 <em>Riccardo</em> 也特别建议大家一定一定保存、管理好各类课件、作业、实验报告、考试题等材料。</p>
</blockquote>
<blockquote>
<p><em>diandian</em> 烤漆的 10 天里，与<strong>不少于 300 个</strong>微信好友有过聊天记录。其中少部分是各位的 debug 需求或是烤漆答疑，最多的是 2 系的各种熟与不熟的同学来问 <em>diandian</em> 学科问题、找 <em>diandian</em> 要往年题答案，真的搞得人很 b 溃。有图为证。</p>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/IMG_5660-7490608.jpeg"
                      alt="IMG_5660" style="zoom:33%;" 
                >

<p>当然，我们也乐意做大家在心情低落时的倾听者，也希望大家在后续学习中遇到不顺心的事情时，愿意相信我们，我们也愿意提供一切力所能及的帮助。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>时间真的过的很快。想起这学期刚开始时，两位助教第一次走进上机教室的慌张与急促还深深在脑海里挥之不去，转眼间就要和大家说再见了。第一次与大家见面时，我们有一个 ppt 叫做“说在前面”。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets16/截屏2023-06-22 23.07.57-7490608.png"
                      alt="截屏2023-06-22 23.07.57" style="zoom:25%;" 
                >

<p>请允许我们有一个“写在最后”。一件事情的结束，永远是另一件事情的开始。</p>
<p>送给大家几条<del>箴言</del>，里面包含了助教们学习生活体验中最最深刻的感悟。</p>
<ul>
<li><p>你需要找到一件自己喜欢的事物。</p>
</li>
<li><p>学业真的只是你自己的事情。</p>
<blockquote>
<p>不太推荐在学习上形成物理或精神上的依赖。宁可两个人在一栋楼的两个地方各干各的，有事情发个微信到走廊上说说话，也好过两个人坐在一起低效率地做事情。</p>
</blockquote>
</li>
<li><p>由友谊、同宿舍、娱乐、恋爱等带来的玩伴或伴侣，未必是你组队的首选对象。谨慎地考虑组队这件事。</p>
</li>
<li><p>你非常需要发挥自主性，你的大部分知识摄入来源于自学。</p>
</li>
</ul>
<p>祝愿大家能去到自己心仪的专业，学业有成！如果在这段时间里存在对 2 系的疑问，欢迎来找 <em>diandian</em> 聊天；如果存在对 21 系或 6 系的疑问，欢迎来找 <em>Riccardo</em> 聊天😋</p>
<blockquote>
<p>放假前十来天助教会去实践活动 &#x2F; 旅游，可能不能回复那么及时哦（小声）</p>
</blockquote>
<p>祝大家暑假愉快，能做自己想做的事情。我们 9 月份学院路见！</p>
<p>我们终会再次相遇在炽热的晚风中。</p>
<p>常联系。</p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Pr 转场预设的使用</title>
    <url>/2023/07/15/Pr-%E8%BD%AC%E5%9C%BA%E9%A2%84%E8%AE%BE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>制作精美的Vlog类视频时，Pr 自带的效果中的视频过渡（也称为转场）显然不能满足大多数用户的需求，而制作自己想要的转场时也稍显麻烦、花费时间，此文章提供一些Diandian制作的、常用的 Pr 转场。</p>
</blockquote>
<h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p>点击下方的按钮即可下载：</p>
<a class="button  center large" href='https://pan.baidu.com/s/140VdS2hk0wsp3wHQF2VBCQ?pwd=aanf' title='Pr 转场预设下载'><i class='fa-regular fa-share-from-square'></i> Pr 转场预设下载</a>

<p>该链接为百度网盘链接，文件整体只有100多M，不是很大，无需会员加速也可在短时间内下载完成。</p>
<p>点开链接会自动填充提取码，但以防万一还是给出：aanf </p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>该预设已经打包成 Pr 工程项目，方便各位在 Pr 中直接导入使用。</p>
<p>一、如下图所示，在 Pr 上方导航栏中，点击“文件”—“打开项目”。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Video clips/截屏2023-07-15 14.46.13.png"
                      alt="截屏2023-07-15 14.46.13" style="zoom:50%;" 
                >

<p>二、找到文件夹位置，打开后，点击下图中所选的项目，点击“打开”。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Video clips/截屏2023-07-15 14.47.08.png"
                      alt="截屏2023-07-15 14.47.08" style="zoom:40%;" 
                >

<p>该项目为 Pr 2022年版下保存，若在更高版本的 Pr 中使用，只需要在打开该项目后，在Pr 弹出的一个弹框中，直接点击“转换”即可。若您的 Pr 版本低于2022年版，请参照以下步骤，强行将该工程文件降版本后使用：</p>
<p>1、先将该文件的后缀重命名为<code>.zip</code>，如下图所示，点击“使用.zip”：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Video clips/截屏2023-07-15 17.00.14.png"
                      alt="截屏2023-07-15 17.00.14" style="zoom:50%;" 
                >

<p>2、将所得的<code>.zip</code>文件解压，<strong>将解压得到的文件用记事本或文本编辑打开</strong>：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Video clips/截屏2023-07-15 17.02.13.png"
                      alt="截屏2023-07-15 17.02.13" style="zoom:40%;" 
                >

<p>3、在上图中，我们找到<code>Version=&quot;40&quot;</code>这一位置，参照下方代码块，根据你的 Pr 版本，更改40为其他数值：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pr2022 —— 40</span><br><span class="line">Pr2021 —— 39</span><br><span class="line">Pr2020 —— 38</span><br><span class="line">Pr2019 —— 37</span><br><span class="line">Pr CC 2019 —— 36</span><br><span class="line">Pr CC 2018.1 —— 35</span><br><span class="line">Pr CC 2018 —— 34</span><br><span class="line">Pr CC 2017.1 —— 33</span><br><span class="line">Pr CC 2017 —— 32</span><br><span class="line">Pr CC 2015.5 —— 31</span><br><span class="line">pr CC 2015.2 —— 30</span><br></pre></td></tr></table></figure></div>

<p>4、修改完后，将此文件后缀重命名为<code>.prproj</code>，即可打开啦！</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Video clips/截屏2023-07-15 17.10.04.png"
                      alt="截屏2023-07-15 17.10.04" style="zoom:50%;" 
                >

<p>三、打开该项目后，即可在 Pr 的素材箱中看到所有项目文件包：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Video clips/截屏2023-07-15 17.15.02.png"
                      alt="截屏2023-07-15 17.15.02" style="zoom:30%;" 
                >

<p>四、我们随便点击一个项目包，例如点击<code>01.Motions</code>，即可出现下图所示画面：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Video clips/截屏2023-07-15 17.16.15.png"
                      alt="截屏2023-07-15 17.16.15" style="zoom:30%;" 
                >

<p>在该图中，V1轨道为实例视频或图片（请不要删除），你可以在该项目中直接预览转场效果。当你想要把此转场效果应用到自己的视频时，请将V2与V3轨道整体复制到你自己的项目中，如下图所示：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Video clips/截屏2023-07-15 14.55.10.png"
                      alt="截屏2023-07-15 14.55.10" style="zoom:40%;" 
                >

<p>请注意，两个特效块的交界处一定与你原项目中需要转场的两个视频块的交界处对齐。如果某个转场有不止V2与V3两个轨道，那么有多少个轨道，就请复制多少个轨道。</p>
<blockquote>
<p>至此，您已将该转场预设成功应用到您的项目中。有些转场比较复杂，如果您是Windows系统，请谨慎使用，这些转场（当然，不多）需要您开启<code>GPU渲染</code>，很多Windows系统电脑在开启该类渲染后会出现莫名其妙的错误，暂不清楚是<code>GPU渲染</code>自身的问题还是破解版软件的问题😭</p>
</blockquote>
<p><strong>接下来，请开启愉快的视频剪辑之旅吧😋</strong></p>
]]></content>
      <categories>
        <category>Video clips</category>
      </categories>
      <tags>
        <tag>Pr</tag>
      </tags>
  </entry>
  <entry>
    <title>常用图像与影视处理软件安装</title>
    <url>/2023/07/15/%E5%B8%B8%E7%94%A8%E5%9B%BE%E5%83%8F%E4%B8%8E%E5%BD%B1%E8%A7%86%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>随着自媒体时代兴起，视频剪辑与图像处理或成为每一个乐于在社交媒体上分享自身经历与感受的人的必备技能。本文将从适用领域、上手难易程度等角度介绍若干常用的图像与影视处理软件。</p>
</blockquote>
<h2 id="Adobe-全家桶"><a href="#Adobe-全家桶" class="headerlink" title="Adobe 全家桶"></a>Adobe 全家桶</h2><p>Adobe 旗下的各类型软件几乎是霸占了软件工具领域的一席之地，只要从事多媒体设计相关工作的人员，基本都会用到 Adobe 软件。</p>
<p>对于大多数用户来说，最出名的便是<code>Photoshop</code>，但其再强大，也无法胜任多媒体设计领域的全部工作，于是便有了<code>Adobe 全家桶</code>的诞生。本文主要介绍全家桶中的5款软件。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Video clips/截屏2023-07-15 15.16.54.png"
                      alt="截屏2023-07-15 15.16.54" style="zoom:40%;" 
                >

<p>当然，请允许Diandian在介绍软件之前，面向广大访客们给出Adobe 全家桶2022年款的下载方式：</p>
<div class="tabs" id="tab-first-unique-name"><ul class="nav-tabs"><li class="tab active"><a class="#first-unique-name-1">Win版</a></li><li class="tab"><a class="#first-unique-name-2">Mac版</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong><a class="link"   href="https://pan.baidu.com/s/120R2kkdxi2EhtDjDManPOg?pwd=zxnt" >https://pan.baidu.com/s/120R2kkdxi2EhtDjDManPOg?pwd=zxnt <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>   提取码：zxnt</strong></p></div><div class="tab-pane" id="first-unique-name-2"><p><strong><a class="link"   href="https://pan.baidu.com/s/1N3lD-EeuQHDn2D1UHX7APw?pwd=n8jt" >https://pan.baidu.com/s/1N3lD-EeuQHDn2D1UHX7APw?pwd=n8jt <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>   提取码：n8jt</strong></p></div></div></div>

<p>上述两个版本下的链接均为百度网盘链接，需要的uu们若自身没有百度网盘<code>SVIP</code>，可以联系我，我将视情况把百度网盘账号借给你下载使用。另外，每个链接打开后是一个Adobe 全家桶软件包，您不需要全部下载到本地，只需要选择自己需要的软件下载即可😋</p>
<p>当然，如果您执迷于正版软件，请访问Adobe 官网，至于价格嘛……</p>
<a class="button  center large" href='https://www.adobe.com/' title='Adobe官网指路'><i class='fa-regular fa-face-smile-hearts'></i> Adobe官网指路</a>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Video clips/截屏2023-07-15 15.52.15.png"
                      alt="截屏2023-07-15 15.52.15" style="zoom:30%;" 
                >

<h3 id="Photoshop"><a href="#Photoshop" class="headerlink" title="Photoshop"></a>Photoshop</h3><p>Photoshop（简称Ps）主要用于图像编辑工作，是目前图像编辑功能最强大的专业工具软件之一，主要功能为图像处理和绘图功能，主要用于平面设计、图片修复、艺术文字、后期修饰、视觉创意与图标制作UI设计等领域。</p>
<p>上手难易：较简单，几乎完全掌握该软件的使用并能自主独立处理图像可能需要1-3周学习时间。</p>
<h3 id="Adobe-Illustrator"><a href="#Adobe-Illustrator" class="headerlink" title="Adobe Illustrator"></a>Adobe Illustrator</h3><p>Adobe Illustrator（简称Ai）也用于图像编辑工作，其与 Ps 不同的是，Ps 主要以像素型数字图像编辑为主，而 Ai 是以矢量图像编辑为主，例如印刷出版、图形插画、logo等，该博客的站点logo即使用 Ai 设计。</p>
<p>Ps 处理出的图片，一经放大就会有不同程度上的模糊，这个模糊程度取决于图片本身的“基础”。而 Ai 设计出的矢量图像的好处就是，图像大小不再受限于分辨率影响，可以自由放大缩小而不失真。</p>
<p>上手难易：较简单，几乎完全掌握该软件的使用并能自主进行logo等的设计可能需要1-2周学习时间。</p>
<h3 id="LightRoom"><a href="#LightRoom" class="headerlink" title="LightRoom"></a>LightRoom</h3><p>LightRoom（简称Lr）是一款可以快速导入图片和调色处理的软件，在摄影过程中或者后期批量处理中会主要使用此软件。Diandian个人将 Lr 软件理解为 Ps 中的<code>Camera Raw 滤镜</code>的拓展延伸。该软件很大程度上弥补了 Ps 在批量处理图片效率上的不足，是摄影师的好帮手。Diandian身边认识的大多数约拍摄影师都使用此软件。</p>
<p>上手难易：较简单，几乎掌握该软件并能调出大师级色彩可能需要1周左右学习时间。</p>
<h3 id="Adobe-Premiere-Pro"><a href="#Adobe-Premiere-Pro" class="headerlink" title="Adobe Premiere Pro"></a>Adobe Premiere Pro</h3><p>Adobe Premiere Pro 是 Adobe Premiere 的升级版，两者都可简称为 Pr 。</p>
<p>该软件是最专业的非线性视频剪辑软件之一，提供了更细致更强大的视频剪辑、特效、调色、配音、字幕等常见功能，足以完成在编辑、制作等视频类工作流上遇到的所有挑战。</p>
<p>上手难易：中等，几乎掌握该软件并能独立剪辑精美视频可能需要1-2个月学习时间。</p>
<h3 id="Adobe-After-Effects"><a href="#Adobe-After-Effects" class="headerlink" title="Adobe After Effects"></a>Adobe After Effects</h3><p>Adobe After Effects（简称Ae）主要以动画编辑与炫酷特效制作工作为主，可以处理2D和3D图形的后期合成，一般用于影视片头制作、影视特效、网页动画、广告、动漫等，对电脑配置要求较高。</p>
<p>我们平时看到的很多宣传片，片头片尾是通过 Ae 合成的，中间视频内容是通过 Pr 剪辑的。</p>
<p>上手难易：较难，没有人能够说自己完全掌握该软件，但能独立使用并制作特效可能需要2-3个月学习时间。</p>
<h2 id="剪映"><a href="#剪映" class="headerlink" title="剪映"></a>剪映</h2><p>剪映是一款视频剪辑工具，带有全面的剪辑功能，有多样的滤镜和美颜效果，有丰富的曲库资源，支持在手机、电脑端上使用，是现在很多短视频平台所能用到的视频制作软件。下载地址如下：</p>
<a class="button  center large" href='https://www.capcut.cn/' title='剪映官网'><i class='fa-solid fa-video'></i> 剪映官网</a>

<p>该软件主打的是随时随地创作与剪辑效率，内含许多现成模版与视频bgm，文字设计、转场等模块均可使用软件自带模版，无需像 Pr 、Ae等软件需要自己制作，缺点是自由度较低，模版是现成的，很难融入自己的创意。</p>
<h2 id="DaVinci-Resolve"><a href="#DaVinci-Resolve" class="headerlink" title="DaVinci Resolve"></a>DaVinci Resolve</h2><p>达芬奇调色软件也是最专业的视频后期制作工具之一，它提供了丰富的色彩调整功能，可以精确调整视频的亮度、对比度、色调、饱和度等参数，以及进行色彩分级和色彩校正。其不仅包含了强大的调色功能，还集成了剪辑、特效、音频处理等多个模块，是现阶段电影、电视剧所必需使用的软件之一。下载地址如下：</p>
<a class="button  center large" href='http://www.blackmagicdesign.com/cn/support/family/davinci-resolve-and-fusion/' title='DaVinci Resolve官网下载'><i class='fa-solid fa-paint-roller'></i> DaVinci Resolve官网下载</a>

<h2 id="Arctime-Pro"><a href="#Arctime-Pro" class="headerlink" title="Arctime Pro"></a>Arctime Pro</h2><p>Arctime Pro 是一款非常好用的字幕制作软件，能够自定义拖动时间线以及调整字幕块，高效地完成字幕的创建工作，可以讲一个几百行、上几千字的文档，迅速转化成视频字幕。同时，该软件在导出字幕文件格式的选择中也能支持多种格式的输出，同时达到高品质的视频导出效果。您可以选择从Arctime直接导出带字幕的视频，也可以将该软件生成的字幕文件导入到 Pr 中，做进一步调整和后期制作。下载地址如下：</p>
<a class="button  center large" href='https://arctime.cn/' title='Arctime Pro官网'><i class='fa-solid fa-comment-text'></i> Arctime Pro官网</a>

<p>如果你的视频所需字幕类型，只是像大多数影视剧中，位于视频画面正下方的对话字幕或者解说字幕，而不需要多余特效的话，该软件是非常好的选择！</p>
<blockquote>
<p>目前Diandian所用到的软件搭配为：Ps + Pr + Ae + Au + Arctime Pro</p>
</blockquote>
]]></content>
      <categories>
        <category>Video clips</category>
      </categories>
      <tags>
        <tag>Pr</tag>
        <tag>Ps</tag>
        <tag>Ae</tag>
      </tags>
  </entry>
</search>
