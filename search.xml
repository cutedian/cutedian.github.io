<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在前面</title>
    <url>/2023/07/13/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="此文章为何存在"><a href="#此文章为何存在" class="headerlink" title="此文章为何存在"></a>此文章为何存在</h2><p>搭建个人博客不是一件容易的事，也不是仅凭着一腔孤勇就能完成的任务。值得一提的是，该博客搭建全程基于<code>macOS</code>系统。<del>整个过程中，Diandian有不下20次想砸电脑的冲动😭</del></p>
<p>当然，此文章存在的意义不是为了抱怨搭建过程，而是希望面向访问蜜罐的朋友们回答一些问题。</p>
<h3 id="搭建个人博客的初衷"><a href="#搭建个人博客的初衷" class="headerlink" title="搭建个人博客的初衷"></a>搭建个人博客的初衷</h3><p>相信很多朋友们都知道，Diandian是一个乐于分享的人。</p>
<p>从大一开始，Diandian便持续搜集各科目资料<strong>（包括但不限于往年考题、实验报告、课程讲义）</strong>，其不仅是为了日后自我复习，还是为了分享给往后许多届的同学们。</p>
<p>毕竟，大学里要学会互帮互助，才能走得长远。因此，该博客内包括但不限于以下内容并将持续更新：</p>
<div class="note-large blue"><div class="notel-title"><p>2系：电路分析</p>
</div><div class="notel-content"><p>往年题12套</p>
<p>自写答案</p>
<p>学习方法</p>
</div></div>

<div class="note-large red"><div class="notel-title"><p>2系：基础物理学（2）</p>
</div><div class="notel-content"><p>练习题+往年题25套（题过于简单，因此无需给出答案。需要者请在首页邮箱联系或在评论区dd我）</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large purple"><div class="notel-title"><p>2系：复变函数与积分变换</p>
</div><div class="notel-content"><p>往年题16套</p>
<p>自写答案（仅给出部分，需要者请dd我）</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large cyan"><div class="notel-title"><p>2系：电子电路（1）</p>
</div><div class="notel-content"><p>期中与期末题库（几乎涵盖所有考题，详见专栏）</p>
<p>自写答案</p>
<p>全套课程讲义</p>
<p>仿真实验报告与硬件实验报告</p>
</div></div>

<div class="note-large orange"><div class="notel-title"><p>2系：电磁场理论</p>
</div><div class="notel-content"><p>6套期中+8套期末</p>
<p>自写答案</p>
<p>全套课程讲义</p>
</div></div>

<div class="note-large yellow"><div class="notel-title"><p>2系：信号与系统</p>
</div><div class="notel-content"><p>8套期末+1套题库</p>
<p>全套课程讲义</p>
<p>仿真实验报告</p>
</div></div>

<div class="note-large green"><div class="notel-title"><p>2系：FPGA基础</p>
</div><div class="notel-content"><p>（由于该门课程为21级新开设，上机实验是否祖传尚不清楚😭）</p>
<p>仿真实验报告+代码打包</p>
</div></div>

<div class="note-large blue"><div class="notel-title"><p>助教资料</p>
</div><div class="notel-content"><p>数据结构与程序设计</p>
<p>复变函数与积分变换</p>
<p>信号与系统（待定）</p>
</div></div>

<div class="note-large orange"><div class="notel-title"><p>视频剪辑</p>
</div><div class="notel-content"><p>剪辑工具如何搭配</p>
<p>剪辑思路</p>
<p>Premiere（简称pr）900个转场预设（自创，无版权要求）</p>
<p>Adobe 全家桶（2022Win&#x2F;Mac版）（无需收费与解压密码）</p>
</div></div>

<h3 id="评论模块"><a href="#评论模块" class="headerlink" title="评论模块"></a>评论模块</h3><p>此博客的评论模块采取<code>Giscus</code>评论系统，该系统基于<code>GitHub Discussions</code>实现，让各位蜜罐访客们能够借助<code>GitHub</code>在文章末尾留下评论。因此，评论员需要一个<code>GitHub</code>账号，如果没有的话赶快注册一个哦～</p>
<a class="button  center large" href='https://github.com/' title='GitHub账号注册'><i class='fa-brands fa-github'></i> GitHub账号注册</a>

<p>当然，此步骤可能需要你会科学上网。在此提供一种macOS上自测有效（Windows也可）的方法</p>
<a class="button  center large" href='https://doc.miyun.app/clashx/' title='免费开启ClashX代理'><i class='fa-solid fa-face-awesome'></i> 免费开启ClashX代理</a>

<p>当然，如果各位不想通过评论区的方式与我交流联系，也可直接访问首页大字<code>Dian·Stay Curious</code>下三个图标中的<code>邮箱</code>，此按钮会引导你编辑内容发送到<code>zhongyd2004@163.com</code>。</p>
<blockquote>
<p>注意：</p>
<p><code>Giscus</code>仍处于活跃开发中，<code>GitHub</code>也还在活跃地开发<code>Discussions</code>及其<code>API</code>，因此一些<code>Giscus</code>的特性可能随时间损坏或变更。当然，Diandian将密切关注此情况。</p>
</blockquote>
<h3 id="文章编写：Typora"><a href="#文章编写：Typora" class="headerlink" title="文章编写：Typora"></a>文章编写：Typora</h3><p>该博客中所有文章均为<code>.md</code>格式（全称<code>markdown</code>），采用<code>Typora</code>软件进行编写。</p>
<p>如果你想更方便地自创与编辑<code>.md</code>格式文件，不妨用一下<code>Typora</code>软件，虽然要收费（不打折时，终身使用仅需89元），但是非常好用😋</p>
<a class="button  center large" href='https://typoraio.cn/' title='Typora软件下载'><i class='fa-solid fa-t'></i> Typora软件下载</a>

<p>当然，<code>markdown</code>语法请自己搜索学习。</p>
<h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>内容分发网络（CDN）是一种分布式系统，<strong>它将内容存储在离用户最近的服务器上</strong>，从而提高用户访问网站的速度和性能。<code>CDN</code>会将用户的请求转发到最近的服务器上，而不是将请求转发到网站的源服务器上。这样可以减少源服务器的负载，同时也可以提高用户访问网站的速度。</p>
<p>本博客基于<code>EvanNotFound</code>大佬的阿里云<code>OSS</code>采取CDN加速，以期望带给各位更顺畅的体验。</p>
<h3 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h3><p>该博客已开通友链模块，想要申请加入的请私信Diandian哦～</p>
<p>（悄悄说一声，如果能提供首页缩略图和头像图就更好啦）</p>
<h2 id="开源相关"><a href="#开源相关" class="headerlink" title="开源相关"></a>开源相关</h2><p><a class="link"   href="https://github.com/XPoet/hexo-theme-keep" >https://github.com/XPoet/hexo-theme-keep <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/volantis-x/hexo-theme-volantis" >https://github.com/volantis-x/hexo-theme-volantis <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/theme-next/hexo-theme-next" >https://github.com/theme-next/hexo-theme-next <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/jerryc127/hexo-theme-butterfly" >https://github.com/jerryc127/hexo-theme-butterfly <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://m3.material.io/" >https://m3.material.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://developer.apple.com/design/human-interface-guidelines/" >https://developer.apple.com/design/human-interface-guidelines/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://fluent2.microsoft.design/" >https://fluent2.microsoft.design/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.sketch.com/" >https://www.sketch.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://hexo.io/zh-cn/" >https://hexo.io/zh-cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://highlightjs.org/" >https://highlightjs.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/next-theme/hexo-filter-mathjax" >https://github.com/next-theme/hexo-filter-mathjax <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" >https://github.com/webappdevelp/hexo-filter-mermaid-diagrams <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/theme-next/hexo-generator-searchdb" >https://github.com/theme-next/hexo-generator-searchdb <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/hexojs/hexo-generator-feed" >https://github.com/hexojs/hexo-generator-feed <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/yanyiwu/nodejieba" >https://github.com/yanyiwu/nodejieba <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://aplayer.js.org/#/" >https://aplayer.js.org/#/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://fontawesome.com/" >https://fontawesome.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.zhheo.com/p/557c9e72.html" >https://blog.zhheo.com/p/557c9e72.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/mattboldt/typed.js/" >https://github.com/mattboldt/typed.js/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="Stay-Curious-Stay-Interesting"><a href="#Stay-Curious-Stay-Interesting" class="headerlink" title="Stay Curious, Stay Interesting"></a>Stay Curious, Stay Interesting</h2><p>在此篇博客的主页会出现<code>Dian·Stay curious</code>，侧边公告栏中出现<code>Stay curious, stay interesting.</code></p>
<p>此句是Diandian最喜欢的英语句子，源于Diandian的高中英语老师<code>Chelsea</code>。我们每次英语课前的老师问好环节，<code>Chelsea</code>会喊出前一句，我们则说出后一句😋。</p>
<p><strong>因此，让我们也在文章末尾大声地说出：“Stay curious, stay interesting!”</strong></p>
]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第一期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%B8%80%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="什么是猪脚说"><a href="#什么是猪脚说" class="headerlink" title="什么是猪脚说"></a>什么是猪脚说</h2><p>为了改善同学们的上机体验，减轻同学们的压力，集中回答编程中常见问题，继承上一辈助教的优良传统，我们<strong>为大家精心准备了猪脚说</strong>。</p>
<p>猪脚说，就是<del>猪脚</del>助教们想对大家说的话。每次上机后，我们会及时总结大家<strong>提问相对较多</strong>或<strong>比较重要</strong>的问题，在猪脚说中以详细的篇幅加以阐述，希望同学们或多或少得到一些启发。</p>
<p>猪脚说包括但不限于<strong>共性问题</strong>, <strong>coding 小技巧</strong>, <strong>课外习题</strong>。</p>
<h2 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h2><h3 id="指针详详详解"><a href="#指针详详详解" class="headerlink" title="指针详详详解"></a>指针详详详解</h3><h4 id="指针与地址"><a href="#指针与地址" class="headerlink" title="指针与地址"></a>指针与地址</h4><p>考虑如下代码，发生了什么？</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure></div>

<p>要回答这个问题，我们要从最开始的地方说起。</p>
<h5 id="你好，世界！"><a href="#你好，世界！" class="headerlink" title="你好，世界！"></a>你好，世界！</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>我们知道，数据总是存储在计算机里的。我们要打印的字符串，应该存在哪里呢？为了便于说明这个问题，我们把计算机内部存储数据的地方<strong>想象成一个大柜子，柜子有一个一个的抽屉</strong>；每个抽屉的容量是有限的，只能放得下一个字符，也就是一个<code>char</code>的内容。这里为了避免引入“字节”的概念，给出如下的大小关系：<code>4个char的大小 = 1个int的大小</code>，<code>8个char的大小 = 2个int的大小 = 1个double的大小 = 1个long long</code>的大小。</p>
<p>上述语句中的字符串，用<strong>双引号</strong>括起来，称为<strong>“字符串字面值常量”</strong>。作为字符串，它由若干字符拼接而成，后来的故事我们都知道了，在它的最后还有一个看不见的<code>&#39;\0&#39;</code>作为结束的标志；作为常量，这类字符串的内容不能被修改。</p>
<p>这样的字符串常量，储存在大柜子里的一块特定区域，称为<strong>常量区</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 15.50.21.png"
                      alt="截屏2023-02-24 15.50.21" style="zoom:40%;" 
                >

<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="type">int</span>  i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>

<p>后来我们学了变量，它们当然也装在这个大柜子里。如果这只是个有很多抽屉的柜子，那么数据的存取将变得异常困难，一个很显然的做法是，<strong>为每个抽屉编号</strong>。但另一个问题又来了，计算机自然可以通过编号访问数据；但作为编程者，我们并不知道每个变量存在哪个编号的抽屉里。于是另一个很显然的做法是，我们可以为存有变量的抽屉<strong>贴上标签</strong>，这就是<strong>标识符</strong>，例如<code>c</code>和<code>i</code>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.12.35.png"
                      alt="截屏2023-02-24 16.12.35" style="zoom:40%;" 
                >

<p><strong>特别要注意的是，<code>int</code>变量<code>i</code>占用了 4 个抽屉。</strong>有了这个模型，我们就能知道<code>int i = 10;</code>中，<code>i</code>表示的是存放了数字 10 的那 4 个抽屉的标签；它的编号是 21；从编号 21 开始之所以放了 4 个抽屉，是类型<code>int</code>决定的。</p>
<p><strong>后来我们知道了，这个编号，就是指针。指针，就是地址。</strong></p>
<h5 id="回答一下前面的问题"><a href="#回答一下前面的问题" class="headerlink" title="回答一下前面的问题"></a>回答一下前面的问题</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.22.14.png"
                      alt="截屏2023-02-24 16.22.14" style="zoom:40%;" 
                >

<ul>
<li>首先定义一个普通变量<code>a</code>，被装在 4 个抽屉里，抽屉的起始编号是 21，抽屉的内容是 10。</li>
<li>然后定义了一个指针变量<code>p</code>，<code>p</code>也需要 4 个抽屉存放<strong>（因为<code>p</code>的本质也是一个整数！！！）</strong>，<code>p</code>也有自己的编号 44，<code>p</code>的内容是存放<code>a</code>的抽屉的起始编号，即 21。</li>
<li><code>p</code>只存放了<code>a</code>的起始地址，<code>p</code>怎么知道<code>a</code>从 21 开始占了多少个抽屉呢？这由定义<code>p</code>的<code>int *</code>中的<code>int</code>决定。<strong>换言之，</strong><ul>
<li><code>char *p</code>表示<code>p</code>中存放一个整数，这个整数是一个地址，从那个地址开始的 1 个抽屉的内容是一个<code>char</code>变量，因为<code>char</code>只需要 1 个抽屉。</li>
<li><code>int *p</code>表示<code>p</code>中存放一个整数，这个整数是一个地址，从那个地址开始的 4 个抽屉的内容是一个<code>int</code>变量，因为<code>int</code>需要 4 个抽屉。</li>
<li><code>double *p</code>表示<code>p</code>中存放了一个整数，这个整数是一个地址，从那个地址开始的 8 个抽屉的内容是一个<code>double</code>变量，因为<code>double</code>需要 8 个抽屉。</li>
<li>……</li>
</ul>
</li>
</ul>
<h5 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h5><p>有了指针，在我们的程序里，要访问一个变量就有两种方法了。一方面，可以通过<strong>抽屉的标签</strong>，也就是<strong>变量名</strong>访问；另一方面，可以通过<strong>抽屉的编号 —— 指针</strong>，间接地访问。后者自然要加上**指针运算符（解引用）<code>*</code>**。</p>
<p>显然，在多数情况下，偏要用指针间接访问一个变量是毫无意义的。但在某些情况下，我们只能通过指针访问。考察下面的程序</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pass_by_value</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pass_by_pointer</span><span class="params">(<span class="type">int</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    pass_by_value(x);</span><br><span class="line">    pass_by_pointer(&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>稍有经验的同学不难看出，<code>x</code>的值不会被修改，<code>y</code>的值会被修改。为什么呢？</p>
<p><strong>C 程序的函数参数都是值传递的。</strong>这句话的意思是，一个函数的运行，自然会涉及一些变量，其中的一部分是函数参数，另一部分是函数内部定义的变量；<strong>在函数运行期间，函数需要借用一些抽屉来存放这些变量的值</strong>。对于<code>pass_by_value(x);</code>中的<code>x</code>，函数只会把**<code>x</code>的值<strong>放在自己借用的抽屉里，而不会意识到<code>x</code>是某处的一个标签；对于<code>pass_by_pointer(&amp;y);</code>中的<code>&amp;y</code>，函数只会把</strong><code>&amp;y</code>的值** —— <strong>这个值是一个普通整数，并且是一个地址</strong> —— 放在自己借用的抽屉里。两者的不同之处在于，前者真的只是传了一个普通整数；而<strong>后者传入的整数同时也是地址</strong>，我们在函数内部确实访问了这个地址的内容，从而真的修改了<code>y</code>的值。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 16.56.33.png"
                      alt="截屏2023-02-24 16.56.33" style="zoom:35%;" 
                >

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><blockquote>
<p>为了绘图简便，我们考察<code>short</code>型的数组。一个<code>short</code>变量占两个抽屉。此处我们仅考虑数组和指针的关系，数组的定义、初始化、元素访问等不再赘述。</p>
</blockquote>
<p>我们会说，<strong>数组名就是指针</strong>，这句话的意思是</p>
<ul>
<li><strong>只要知道了数组的首地址，就可以访问数组的每个元素。</strong>假设<code>p</code>存放着数组的首地址，下标从 0 开始，我们要访问下标为<code>index</code>的元素，一种写法是<code>p[index]</code> —— 相当于从数组首元素<strong>往后数</strong><code>index</code>个元素，然后访问那个元素 —— 等价于<code>*(p + index)</code>，即将<code>p</code><strong>偏移</strong>，从而使之指向欲访问的元素，然后解引用。</li>
<li>系统手里有一张表，叫做<strong>符号表</strong>。数组名是符号表中的一项，它是一个<strong>不可修改的常量</strong>，指代数组的首地址。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-24 17.30.56.png"
                      alt="截屏2023-02-24 17.30.56" style="zoom:40%;" 
                >

<p>当数组作为函数参数传递的时候，<strong>统一当成指针处理</strong>，所以以下三种函数声明等价：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *arr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arr[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arr[<span class="number">999</span>])</span>; <span class="comment">// 并不关心数组多大</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>后面两种声明会被翻译成第一种声明，也就是指针的形式。<ul>
<li>数组可以通过首地址访问，所以传入首地址是可行的。</li>
<li>通过指针，在<code>main</code>函数里定义的数组，可以在<code>func</code>中被修改，这与普通变量的值传递不同。</li>
</ul>
</li>
<li>前面说到，函数参数需要借一些抽屉临时存放。而函数能借到的抽屉是<strong>有限的</strong>，如果真的把一个长度为 999 的数组传入，则需要 999 × 4 个抽屉，这不太现实。只传入指针，则只需要 4 个抽屉即可 —— 通过指针间接访问数组。</li>
<li>此外，上一点也提醒我们，<strong>函数内部并不知道数组有多大，它只知道数组的首地址</strong>。所以对数组操作的函数，一般需要再加上一个<code>size</code>参数，保证函数中不会出现<strong>数组越界</strong>的情况。</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>在最开始的地方谈到，用双引号扩起来的字符串常量，被存放在大柜子的一块特定区域，即常量区。事实上，不仅是我们想要输出的文本信息，<strong>C 程序中任何地方</strong>出现的字符串常量，都会被存在那里。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="type">char</span> *s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br></pre></td></tr></table></figure></div>

<p>这里的<code>&quot;%d %d&quot;</code> <code>&quot;hello world&quot;</code> <code>&quot;%s\n&quot;</code>都是字符串常量，都会被预先存在常量区。另一方面，这种字符串常量的最后都默认有一个看不见的<code>&#39;\0&#39;</code>作为结束的标志，这是系统自动加上的。</p>
<p>我们想象这样的画面，每个抽屉只能装一个字符，<strong>只要我们知道了字符串的第一个字符装在哪个抽屉，然后依次往后拉开抽屉，直到拉开了存放<code>&#39;\0&#39;</code>的那个抽屉为止，我们就获得了字符串的所有内容</strong>。于是，<strong>字符串的首地址就成为了确定一个字符串唯一所需要的信息。</strong><code>char *s = &quot;hello world&quot;;</code>的那个指针<code>s</code>，做的就是这件事。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 11.57.03.png"
                      alt="截屏2023-02-25 11.57.03" style="zoom:40%;" 
                >

<p><strong>另一方面，字符串也可以存在我们自定义的数组里，但是其初始化值得考察。</strong>假设我们要存入的是<code>&quot;abc&quot;</code>。</p>
<ul>
<li><p>数组大小应该开够，因为需要有<code>&#39;\0&#39;</code>作为结束标志</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 开得足够大，并且别忘了 \0</span></span><br><span class="line"><span class="type">char</span> s[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;   <span class="comment">// 不写大小，由系统自动判断，此处 s 大小即为 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">4</span>]; s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>; s[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>; s[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span> = s[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 更加麻烦的逐一赋值，但 OK</span></span><br></pre></td></tr></table></figure></div>

  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 12.02.53.png"
                      alt="截屏2023-02-25 12.02.53" style="zoom:40%;" 
                >
</li>
<li><p>有一种<strong>便捷手段</strong>，在初始化的时候，<strong>用字符串字面值常量为字符数组赋初值</strong></p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 开大点总是保险</span></span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>;   <span class="comment">// 这么做默认 s 大小为 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严禁这么做！</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>]; <span class="comment">// 定义了一个数组，数组名是符号表中的常量</span></span><br><span class="line">s = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 给一个符号常量赋值，是绝对不行的</span></span><br></pre></td></tr></table></figure></div>

  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets1/截屏2023-02-25 12.08.20.png"
                      alt="截屏2023-02-25 12.08.20" style="zoom:40%;" 
                ></li>
</ul>
<h4 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h4><p><strong>指针是工具，是用来使用的。</strong></p>
<p>对指针的本质进行解析，为的是让大家理解其使用方式。使用指针，需要的是在脑海中形成意识“我们就是这么做的”“这么做是合理的”。对于指针的基本理解包括但不限于以下几点</p>
<ul>
<li>指针是个<strong>变量</strong>，指针是个<strong>整数</strong>。</li>
<li>取变量的地址赋值给指针，我们就说指针指向了那个变量。</li>
<li>指针“指向”，只是说指针中存了一个整数地址；<strong>要访问变量，需要一次解引用</strong>。</li>
<li><strong>数组名是一个符号</strong>，等价于数组首地址。</li>
<li>双引号扩起来的字符串是常量，只读不写。</li>
</ul>
<p>我们需要培养一些基本的意识，要知道“我可以写什么，不可以写什么”。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr; <span class="comment">// arr符号代表首地址，赋值给指针，当然可以</span></span><br><span class="line">p[<span class="number">1</span>] = <span class="number">5</span>;     <span class="comment">// 指针也可以像数组一样访问</span></span><br><span class="line">*(p + <span class="number">2</span>) = <span class="number">2</span>; <span class="comment">// 指针自己也具备了“偏移 + 解引用”操作</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *s  = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 这是指针指向字符串常量</span></span><br><span class="line"><span class="type">char</span> t[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 这是一个普通数组，并使用了便捷方式初始化</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span>;       <span class="comment">// 字符串常量不能修改！</span></span><br><span class="line">t[<span class="number">1</span>] = <span class="string">&#x27;y&#x27;</span>;       <span class="comment">// 数组当然可以修改</span></span><br></pre></td></tr></table></figure></div>

<p>最后补充的是<code>NULL</code>和<code>const</code>指针。</p>
<h5 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a><code>NULL</code></h5><p>指针是一个<strong>整型变量</strong>，它的取值无非有这么几种</p>
<ul>
<li>只定义但未初始化，是一个随机值。</li>
<li>进行初始化或赋值，“指向了其他的变量”。</li>
<li>初始化为 0。（编号为 0 的那个抽屉存了啥？）</li>
</ul>
<p><code>NULL</code>是一个宏，代表整数 0，用于指针的初始化：<code>int *p = NULL;</code> 当然也可以写 <code>int *p = 0;</code>。</p>
<p>当一个指针未初始化时，它可能指向任何地方，但是那里究竟能不能访问是未知的，这就是<strong>野指针</strong>。在有些情况下，访问了不该访问的地方，可能导致系统崩溃。人们规定，<strong>编号为 0 的那个抽屉是一个无效的抽屉，一旦访问，程序运行就强制结束了</strong>（总比系统崩溃好）。所以在将指针指向某个变量之前，初始化为 0 或<code>NULL</code>，是有必要的。</p>
<h5 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a><code>const</code>指针</h5><p>我们知道字符串常量存在常量区，但其他常量，如<code>const int</code>，还是和普通变量放在一起的。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></div>

<p>当编译器看到这两行代码，它会说：“<code>a</code>被定义为常量，你却要为<code>a</code>赋其他值，不可以！”于是报错。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line">*p = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></div>

<p>当编译器看到这两行代码，它会说：“<code>a</code>是常量，存在内存里了。<code>p</code>想要指向它，当然可以。对指针<code>p</code>解引用进行赋值，当然可以。”于是真的，一个<code>const int</code>的值通过指针被修改了。</p>
<p>所以我们有必要避免这种情况，手段就是<strong>“指向常量的指针”</strong>。前文说到，<strong>指针是统一的一种类型，就是整型</strong>。定义指针时前面的类型，只是告诉系统，“连续打开几个抽屉”。打开抽屉后，无非有两种操作：看一下里面是什么（<strong>读</strong>操作）和修改一下内容（<strong>写</strong>操作）。对于后者，如果抽屉里装的是常量，则应该避免。</p>
<p>在定义指针的最前面加上<code>const</code>修饰，如<code>const int *p = &amp;a;</code>，就定义了指向常量的指针。这么做的好处是，<code>p</code>说：“我是指针，我指向<code>a</code>，但你<strong>无法通过我</strong>修改<code>a</code>的值，<strong>你有没有其他手段修改<code>a</code>的值，与我无关。</strong>”</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a; <span class="comment">// 这是正确的，定义了指向常量的指针</span></span><br><span class="line">*p = <span class="number">100</span>;          <span class="comment">// 通过 p 无法修改 a</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *q = &amp;b; <span class="comment">// 指向常量的指针指向了普通变量</span></span><br><span class="line"><span class="type">int</span> *r = &amp;b;       <span class="comment">// 普通的指针指向了普通变量</span></span><br><span class="line">*q = <span class="number">100</span>;          <span class="comment">// 无法通过 q 修改 b 了，哪怕 b 是一个普通变量</span></span><br><span class="line">*r = <span class="number">100</span>;          <span class="comment">// 这么改当然可以</span></span><br></pre></td></tr></table></figure></div>

<p>于是我们会在大量字符串处理函数的原型中，看到参数都定义为<code>const char *p</code>类型，这就是说，字符串通过<code>p</code>传入函数，<strong>保证在函数内部，不会修改字符串的内容</strong>。这么做是严谨的。</p>
<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><h4 id="库函数功能介绍"><a href="#库函数功能介绍" class="headerlink" title="库函数功能介绍"></a>库函数功能介绍</h4><p><code>size_t</code> 为无符号整数类型，它是 <strong><code>sizeof</code></strong> 关键字的结果。</p>
<p>下列常用字符串处理函数均定义在头文件  <code>&lt;string.h&gt;</code> 中：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 把 str1 和 str2 的前 n 个字节进行比较。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 从 src 复制 n 个字符到 dest。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	复制字符 c （一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</span></span><br><span class="line"><span class="comment">	e.g.想要将一个 int 类型数组 a[50] 全部置为0:</span></span><br><span class="line"><span class="comment">		memset(a, 0, sizeof(a));</span></span><br><span class="line"><span class="comment">	等效于 for (i=0; i &lt; 50; i++) a[i] = 0;</span></span><br><span class="line"><span class="comment">	【特别注意】一般此函数仅用于全部归零，其他值不能随便设置！！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="comment">// 把 src 所指向的字符串（包括&#x27;\0&#x27;）追加到 dest 所指向的字符串的结尾（删除 dest 原来末尾的&#x27;\0&#x27;）。</span></span><br><span class="line"><span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 的字符串。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 把 src 所指向的字符串的前 n 个字符追加到 dest 所指向的字符串的结尾（删除 dest 原来末尾的&#x27;\0&#x27;）。</span></span><br><span class="line"><span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 的字符串。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="comment">	返回值为该字符串中第一次出现的字符的指针，若不包含该字符则返回 NULL 空指针。</span></span><br><span class="line"><span class="comment">	char *strrchr(const char *str, int c);</span></span><br><span class="line"><span class="comment">	在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	把 str1 所指向的字符串和 str2 所指向的字符串进行比较并返回整数。若两字符串相等，则返回零。</span></span><br><span class="line"><span class="comment">	若 str1 &lt; str2, 则返回负数; 若 str1 &gt; str2, 则返回正数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line">	<span class="comment">// 把含有&#x27;\0&#x27;结束符的字符串 src 复制到以 dest 开始的地址空间。</span></span><br><span class="line">	<span class="comment">// src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 字符串。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line">	<span class="comment">// 把字符串 src 的前 n 个字符复制到以 dest 开始的地址空间。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">// 计算字符串 str 的长度，知道空结束字符但不包括空结束字符。返回值数据类型为无符号整型。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="comment">// 在字符串 dest 中查找第一次出现字符串 src（不包含空结束字符）的位置。</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>补充练习：字符串处理函数与指针的使用。<strong>此题将在下周上机详细讲评。</strong></p>
<p>输入 n 个字符串，将每个字符串中的<code>good</code>子串全部替换为<code>perfect</code>后输出。（不用担心数据范围，写代码实现此功能即可）。</p>
<p><strong>样例输入</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">abc123</span><br><span class="line">BUAA  goodddd 123 Good</span><br><span class="line">godgoodgodgoooood goo? gooD good!</span><br></pre></td></tr></table></figure></div>

<p><strong>样例输出</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc123</span><br><span class="line">BUAA perfectddd 123 Good</span><br><span class="line">godperfectgodgoooood goo? gooD perfect!</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h4 id="读取字符串"><a href="#读取字符串" class="headerlink" title="读取字符串"></a>读取字符串</h4><p>很多同学在使用 <code>gets()</code> 函数读取字符串时，可能在 judge 平台的编译器上收到这样的提示:</p>
<p><strong>Warning: the ‘gets’ function is dangerous and should not be used.</strong></p>
<p>原因在于：**<code>gets()</code>函数不做地址越界检查！**若输入的字符串大于既定数组的长度，程序运行会出现难以预期的错误。<a class="link"   href="https://blog.csdn.net/weixin_33748818/article/details/89776085" >有兴趣的同学可以从这篇文章中作详细了解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>在此，我们建议使用如下两种方式读取字符串:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"><span class="comment">// 该函数更多被用来读取单词，而非整行字符串。它从一个非空白字符开始，读到下一个空白字符为止。</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[BUFSIZ] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">fgets(buf, BUFSIZ, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="comment">// 该函数的第二个参数代表规定从标准输入读取字符上限的数量，这也是它优于 gets() 函数的地方。</span></span><br><span class="line"><span class="comment">// 我们更推荐大家使用此种方法来读取整行字符串。</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>BUFSIZ</code>是宏定义在头文件里的常数，一般值为 512，对于大家完成上机作业已经够用了。</p>
</li>
<li><p><code>stdin</code>为标准输入，也就是键盘输入。在之后的文件输入输出时，可以修改此参数为文件指针。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong></p>
<p><code>fgets()</code> 函数会读取 <code>&#39;\n&#39;</code> 并写进数组中, 因此使用<code>strlen()</code> 函数求取数组长度时, 得到的长度比实际可见字符数多 1，其中包含了最后一个换行符。</p>
</blockquote>
<h3 id="char与int的转换"><a href="#char与int的转换" class="headerlink" title="char与int的转换"></a><code>char</code>与<code>int</code>的转换</h3><p>先来看第一次作业填空题第四题:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">invert</span><span class="params">(<span class="type">char</span> str[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>, j = <span class="built_in">strlen</span>(str)<span class="number">-1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">		k = str[i];</span><br><span class="line">		str[i] = str[j];</span><br><span class="line">		str[j] = k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不少同学都来提问: <code>k</code>不是<code>int</code>类型的变量吗，怎么能够和一个字符进行相应的运算关系？</p>
<p>需要指出的是：某个字符和它由 <strong>ASCII 码表</strong>所对应的整型值是等价的。即如果用整型值 48 赋值给某个字符，则其输出结果会是 ‘0’; 如果用字符常量 ‘0’ 赋值给某个整型变量，则其输出后为 48。</p>
<p><code>char</code>型实际上就是 0 到 127 的整型数经过 <strong>ASCII 码表</strong>映射的结果，其与<code>int</code>型的转换需要代入映射后得到对应值。</p>
<p>如果还有同学有疑问或者想要了解更多例子，不妨看下面一些代码:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) </span><br><span class="line">    <span class="comment">// do something</span></span><br></pre></td></tr></table></figure></div>

<p>上述代码为最简单的两个字符比较大小，其本质上是以相应的<strong>ASCII码表</strong>值的大小作为字符比较的标准。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">char</span> str[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line"> 			str[i] += <span class="number">32</span>; </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码可以实现把一段字符串中的大写字母全部转化为小写字母，其中倒数第三行就是字符与整型量的运算。</p>
<h2 id="第一次作业补充练习"><a href="#第一次作业补充练习" class="headerlink" title="第一次作业补充练习"></a>第一次作业补充练习</h2><p><a class="link"   href="https://www.luogu.com.cn/training/48079" >此链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>可以收藏起来，若有需求可以去做一些练习。</p>
<p>1、 <a class="link"   href="https://www.luogu.com.cn/problem/P5734" >处理字符串，主要考察大家对常用字符串处理库函数的运用。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>2、 <a class="link"   href="https://www.luogu.com.cn/problem/P1308" >单词统计，注意题干要求处理大小写字母。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>3、 <a class="link"   href="https://www.luogu.com.cn/problem/P1022" >改良计算器，为第一次上机第二道编程的拓展。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>4、 <a class="link"   href="https://www.luogu.com.cn/problem/P8652" >对于小数点后位数的处理。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>5、<a class="link"   href="https://www.luogu.com.cn/problem/P2293" >高精度开根，第一次上机第四道编程的拓展。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>猪脚说第二期</title>
    <url>/2023/07/14/%E7%8C%AA%E8%84%9A%E8%AF%B4%E7%AC%AC%E4%BA%8C%E6%9C%9F/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets2/IMG_0716.jpg"
                      alt="IMG_0716" style="zoom:33%;" 
                >

<blockquote>
<p><strong>写在前面 —— 关于理论与实验</strong></p>
<p>我们可以很负责地告诉大家，几乎所有的计算机软件核心专业课（如计算机组成原理、操作系统、编译原理、计算机网络等），都由理论和实验两部分构成。前者，基本建立在抽象的层面上，一般以<strong>文字表述和数学公式</strong>给出；后者，基本需要个人在实践中完成。实验的内容一般由指导书、手册等给出，需要<strong>自行阅读了解</strong>；而其中涉及的工具和方法，如虚拟机、编程工具、编程语言等，完全<strong>通过自学解决</strong>。</p>
<p>幸运的是，作为一门承上启下的课程，数据结构课的重点知识并非仅纯数学符号。由于我们的学习进度尚有限，这门课在日常教学中也融入了大量 C 语言代码，并且几乎可以当作“板子”。所谓板子，就是<strong>可以直接拷贝黏贴</strong>的东西，<del>每到考试，也会出现打板子、拼接板子等现象</del>。</p>
<p>这给我们两点启发。其一，很多知识在课件里就能找到，当同学们遇到困难时（如文件操作、结构体），不必等老师讲授，自行看课件、搬运代码，很多问题就能迎刃而解。其二，我们必须强调自学的重要性，善于通过各类渠道解决问题。举个例子，仅通过搜索引擎，就可以查询到近来上机出现的诸多问题。</p>
<p>此外，由于实验的基本形式是选填和编程题，而非从零开始迭代着制造一个东西，所以就没有指导书的必要。<strong>我们的“猪脚说”则作为上机实验的补充指导，解答共性问题、提供知识总结，希望对大家有所帮助。</strong></p>
</blockquote>
<h2 id="常见问题汇总"><a href="#常见问题汇总" class="headerlink" title="常见问题汇总"></a>常见问题汇总</h2><blockquote>
<p><strong>为什么我本地测试正确，提交运行却出现了多余字符？</strong></p>
</blockquote>
<p>数组是一片连续的内存空间，<strong>数组之外的内容是不可控的</strong>。当我们越界访问时，有可能成功，有可能报错，有可能读取到随机内容。因此，这类问题的主要原因是数组开得不够大和未初始化。</p>
<p><strong>(1) 数组大小。</strong>题目不一定给出明确的数据范围，如果有数据范围，比如 80，则开到100 比较合适，甚至 200、500 等都不过分。如果没有数据范围，则根据经验考虑，如字符数组开 512 或 1024 大小，整型数组开 200、1000 等。一般不会在数据范围的问题上为难大家，但如果开得和题目说的一样大，确实更容易出错（如忘了字符串末尾的<code>&#39;\0&#39;</code>，下标从 1 开始等）。</p>
<p><strong>(2) 初始化。</strong>很多时候都需要把一个数组或变量初始化成 0。考虑这样一种情况，我们逐个字符地构造一个字符串，结果最后忘了添加<code>&#39;\0&#39;</code>，<strong>如果这个字符数组先前被初始化成全 0，则字符串的后面还是有<code>&#39;\0&#39;</code>的</strong>；如果未初始化，字符串后面的内容则是未知的，极有可能出错。下面给出一些常见的初始化方式。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码都处在 main 函数中</span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;          <span class="comment">// 初始化为全 0</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">10</span>] = &#123;<span class="number">1</span>&#125;;          <span class="comment">// 仅 arr2[0] 为 1，其他都是 0</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;          <span class="comment">// 全部初始化为 &#x27;\0&#x27;，等价于 char str[10] = &#123;&#x27;\0&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环也是初始化的常见方式，千万不要觉得麻烦！</span></span><br><span class="line"><span class="type">int</span> arr3[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr3[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> arr4[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">        arr4[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>(3) 全局变量。</strong>全局变量会执行<strong>默认初始化</strong>，一般自动初始化成 0；且在各个函数中都能直接访问，简化了参数列表。但正如同先前谈到的代码风格问题，频繁使用全局变量并不是一个好习惯。一般地，只有需要很大的数组，如<code>int [1000000]</code>，或常量，如<code>const int MAX_LENGTH = 1024;</code>的时候，才会使用全局变量。</p>
<blockquote>
<p><strong>为什么错误输出和期望输出一模一样还会 WA？</strong></p>
</blockquote>
<p>这种问题多数是由于通过<code>printf(&quot;%c&quot;, c);</code>的方式输出导致的。在打印过程中，可能不慎打印了空白字符。空白字符在网页上显示不出来，但在评测机进行比对的时候，就会认为错误。解决的方法是，在本地把代码改成<code>printf(&quot;%c0&quot;, c);</code>（我们假设正确的输出中不含 0，如果有冲突就换一个字符），这样如果输出了诸如<code>a0b0c00</code>的内容，就说明在最后一个 0 的前面还输出了不可见字符。打印了空白字符很可能是为字符变量赋值或初始化的逻辑有漏洞引起的，需要结合代码具体分析。</p>
<blockquote>
<p><strong>为什么这种不合法的情况也还是会输出啊？</strong></p>
</blockquote>
<p>没有按照题目要求输出内容，多数是代码逻辑的问题引起的。我们仅以第一次作业的“拓展字符”为例，看一种典型的错误。伪代码如下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">遍历字符串:</span><br><span class="line">    <span class="keyword">if</span> (当前字符为 <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;-&#x27;</span> 的前后同为 a-z 或 A-Z 或 <span class="number">0</span><span class="number">-9</span>) &#123;</span><br><span class="line">            <span class="type">int</span> d = 后字符 - 前字符;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= d; i++) &#123;</span><br><span class="line">                print 前字符 + i；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        原样输出字符;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>对于合法的可拓展字符，这段代码可以成功拓展。考虑 “g - a” 这类情况，程序会先连续进入两个<code>if</code>，但是<code>d</code>算出来为负数，所以<code>for</code>循环不执行，好像也符合要求。但是，一旦进了第一个<code>if</code>，则<code>else</code>分支原样输出将不被执行。这就是典型的逻辑漏洞。</p>
<p>另外，多数情况下的“运行超时”都是死循环导致的，这与代码逻辑也密不可分。</p>
<p>解决逻辑问题的常见手段是调试。如果你尚未掌握自己所用 IDE 的调试方法，不妨在程序的多个地方<strong>打印变量的值</strong>，观察程序的运行过程；如果需要判断是否进入某个分支、循环多少次等，也可以采用打印的方法。通过有效的<strong>工具手段和纸面演算</strong>解决程序逻辑问题，是每个人必备的基本功。当然，<strong>将代码提取成函数</strong>，也有助于缩小错误的范围。</p>
<h2 id="qsort函数详解"><a href="#qsort函数详解" class="headerlink" title="qsort函数详解"></a><code>qsort</code>函数详解</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>C 标准库 ```<stdlib.h>```中。函数原型如下：</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```C</span><br><span class="line">void qsort(void *base, </span><br><span class="line">           size_t num, </span><br><span class="line">           size_t width, </span><br><span class="line">           int(*cmp)(const void* e1, const void* e2));</span><br></pre></td></tr></table></figure></div>

<p><strong>该函数可实现的功能是：按照某种自定义的规则（ <code>cmp</code>函数），对数组<code>base</code>的 <code>num</code>个元素进行排序。</strong></p>
<p>想要理解<code>qsort</code>函数的具体实现方式，我们首先引入<strong>回调函数</strong>的概念：</p>
<blockquote>
<p>回调函数就是一个<strong>通过函数指针调用的函数</strong>。如果把函数的指针作为<strong>参数</strong>传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。</p>
</blockquote>
<p>显然<code>qsort</code>函数的四个参数中，**<code>cmp</code>参数就是回调函数，我们需要使用它来指导<code>qsort</code>函数的进行**。当<code>qsort</code>函数想要确定某两个元素的排列顺序时，会将这两个元素的指针 p1 和 p2 传入<code>cmp</code>函数进行元素值的比较：</p>
<ul>
<li><p>如果<code>cmp</code>函数返回值小于 0，则 p1 所指向元素会被排在 p2 所指向元素的前面；</p>
</li>
<li><p>如果<code>cmp</code>函数返回值等于 0，则 p1 所指向元素与 p2 所指向元素的顺序不确定（因为<strong>在某种意义上</strong>两个相同的元素谁在前谁在后都无伤大雅）；</p>
</li>
<li><p>如果<code>cmp</code>函数返回值大于 0，则 p1 所指向元素会被排在 p2 所指向元素的后面。</p>
</li>
</ul>
<p>可是，<strong>设计者在设计<code>qsort</code>函数时，不知道使用者会排序什么类型的元素，<code>qsort</code>函数自身也不清楚数组元素的类型是什么，但是它又必须实现元素两两之间的比较与交换。</strong>怎么办呢？最高效的方式就是从数据的存储入手，我们只需要<strong>将两个数据所占有的内存的内容交换【可以表述成：将属于 p1 的若干个抽屉的内容全部取出，将属于 p2 的若干个抽屉的内容全部取出，两者交换（详见猪脚说第一期😋）】</strong>便可实现任意类型元素的排序了。</p>
<p>需要交换的字节大小视具体情况而定，这时候参数<code>width</code>与<code>cmp</code>函数里的<code>void *</code>的作用就体现出来了。</p>
<p><strong><code>void *</code>称为通用指针</strong>，它就像一个垃圾桶，什么地址都可以往里扔，我们需要做的只是<strong>在自己写的<code>cmp</code>函数里对扔进来的地址做强制类型转换</strong>，再通过<code>width</code>参数规定所交换字节内容的大小，如<code>sizeof(int)</code>、<code>sizeof(char)</code>、  <code>sizeof(struct Node)</code>等，就可以使<code>qsort</code>函数按你所需地对目标数组元素进行排序。</p>
<p>现在我们以一段实操代码为例，感受<code>qsort</code>函数的使用方式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span>*)e1 &lt; *(<span class="type">int</span>*)e2) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 也可写成如下形式：</span></span><br><span class="line">    <span class="comment">// int *a = (int *)e1;</span></span><br><span class="line">    <span class="comment">// int *b = (int *)e2;</span></span><br><span class="line">    <span class="comment">// return (*a &lt; *b) ? -1 : 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    qsort(a, <span class="number">1000</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	特别要注意，部分教程在 cmp 中直接写</span></span><br><span class="line"><span class="comment">	`return *a - *b;`</span></span><br><span class="line"><span class="comment">	这是有巨大隐患的。具体原因请结合 int 能表示的范围有限思考。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p>通过我们自己写的<code>cmp</code>函数得知，当返回值小于 0（即 e1 所指向元素小于 e2 所指向元素时），e1 所指向元素会被排列在 e2 所指向元素的前面，且每次<strong>严格按照<code>int</code>类型所占有的字节宽度为限度</strong>进行交换，由此可实现数组 a 中所有元素由小到大排序。</p>
<p>当然，若想实现元素由大到小排序，只需将<code>cmp</code>中内容改写为<code>return (*(int*)e1 &gt; *(int*)e2) ? -1 : 1;</code></p>
<p>值得注意的是，若对于<code>double</code>类型数组进行由小到大的排序，我们需将<code>cmp</code>函数写为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span> <span class="comment">// 调用 fabs 需要包含此头文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(*(<span class="type">double</span>*)e1 - *(<span class="type">double</span>*)e2) &gt; <span class="number">1e-7</span>)  <span class="comment">// 浮点数判断是否相等的方式：和极小量比较！</span></span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">double</span>*)e1 &gt; *(<span class="type">double</span>*)e2 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="学习结构体的意义在哪儿"><a href="#学习结构体的意义在哪儿" class="headerlink" title="学习结构体的意义在哪儿"></a>学习结构体的意义在哪儿</h2><blockquote>
<p>结构体的声明、定义和使用都相对简单，结合课件即可掌握。较新的内容是指向结构体的指针，<strong>建议忽略本质、注重语法和使用</strong>，随着一两周后链表的学习，很快即可上手。</p>
</blockquote>
<p>先来考虑这样一种需要处理的情形：一个班级里有若干学生，每个学生的学号、姓名、成绩三个信息需要被记录，现在我们需要对其中的某些学生的信息进行数据处理，声明结构体如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> number[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>显然，如果我们只需要记录一位学生，大可不必使用<code>struct student kid;</code>的定义形式，也不需要在后续访问变量时使用<code>kid.number</code>、<code>kid.name</code>、<code>kid.grade</code>如此繁杂的方式。我们只需要分别定义两个字符串数组、一个<code>int</code>类型变量即可，此时<strong>为了某种程度上的整洁而声明结构体类型、定义结构体变量反而显得多此一举</strong>。</p>
<p>可是，一个班级的整体数据肯定不能只由一位同学代表，往往我们需要处理多达上百个同学的数据，这时结构体的优势就开始显现。如果我们借助结构体变量的数组存储，那么只需要定义<code>struct student info[200];</code>后续每个学生的学号、姓名、成绩均可以作为成员储存在一个结构体变量中。</p>
<p>虽然我们仍可分别定义以下三个数组储存学生信息，每个学生的信息一一对应地储存于各数组中:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> stu_number[<span class="number">200</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> stu_name[<span class="number">200</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> stu_grade[<span class="number">200</span>];</span><br></pre></td></tr></table></figure></div>

<p>显然，若我们需要了解第 i+1 个学生的信息（假设数组下标从 0 开始），我们可以直接在<code>info[i]</code>这一结构体变量中全部寻得，也可以通过依次访问<code>stu_number[i]</code>、<code>stu_name[i]</code>、<code>stu_grade[i]</code>寻得。但前者不是更简洁方便、显得整体化吗？</p>
<p>因此，我们可以这样说：<strong>结构体存在的意义在有数组时才能体现。</strong></p>
<p>但是，如果只需完成类似于统计班级里有多少同学姓“王”、有多少同学成绩在 90 分以上这样的任务，大可以使用上述三个数组，用遍历的方法求得满足条件学生的总数，似乎数组完全可以代替结构体变量，并且不会导致任何工作量的增加。<strong>这是因为这样的任务并没有把学生的三个信息建立起联系，对某一个信息进行统计的时候可以完全不用顾虑其他信息与之对应。</strong></p>
<p>那么问题来了：当需要将学生的成绩按照<strong>由大到小</strong>的顺序输出，并同时输出每个同学对应的姓名与学号，使用哪种方式更好呢？</p>
<p>对于这个问题，刚刚学习了<code>qsort</code>函数的你想要进行实践。若你使用常规的数组存储，很快便遇到了困难。你并不知道<code>qsort</code>函数每次是对哪两个具体元素进行了比较，因此你单纯地将<code>stu_grade</code>数组排好了序，但其余两个数组与<code>stu_grade</code>数组的对应关系已经完全丧失，再无可能正确地输出每一个成绩所对应的姓名与学号。</p>
<p><strong>但如果用<code>qsort</code>函数对结构体进行排序呢？</strong></p>
<p>通过前文的讲解我们知道，我们的**<code>cmp</code>函数规则应该是对于每个结构体中的<code>grade</code>变量进行比较，但比较后的结果，是交换这个结构体变量所拥有的全部字节内容<strong>，而这个内容中既包含了<code>grade</code>、也包含了<code>number[]</code>和<code>name[]</code>，因此我们便做到了</strong>在保留原有成员变量一一对应关系的基础之上，对学生成绩进行了排序**。</p>
<p>综上所述，在排序这样一个实际例子中，结构体变量存在着至关重要的意义与价值。</p>
<p>当然，结构体还有许多的应用场景，比如大家后续所要学习的链表……这里我们就不再详述。</p>
<p>另值一提的是，请同学们看看如下代码是否正确：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> student*)e1-&gt;grade &lt; (<span class="keyword">struct</span> student*)e2-&gt;grade) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果<code>cmp</code>函数内容如上所示，则使用<code>qsort</code>函数排序会出现奇怪的错误。原因是因为**类型转换符<code>(type *)</code>的运算优先级低于箭头运算符<code>-&gt;</code>**。所以会先计算<code>e2-&gt;grade</code>，再去做类型转换。因此正确写法为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">struct</span> student*)e2)-&gt;grade &lt; ((<span class="keyword">struct</span> student*)e1)-&gt;grade) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="标准-C-库文件-I-O"><a href="#标准-C-库文件-I-O" class="headerlink" title="标准 C 库文件 I&#x2F;O"></a>标准 C 库文件 I&#x2F;O</h2><blockquote>
<p><strong>文件 I&#x2F;O，即文件的输入输出（Input &#x2F; Output）</strong>，几乎是每一个软件项目必备的模块。此外，我们称读取一个文件的内容为<strong>“读文件”</strong>，称编辑一个文件的内容为<strong>“写文件”</strong>。</p>
<p>以 macOS、Linux、Windows 为代表的多数操作系统，都引入了文件的概念。<strong>资源即文件。</strong>文件不仅包括屏幕上显示的一个个“文件”，还包括各类设备，如鼠标、键盘、打印机、屏幕（标准输出）、音响、U 盘等。一般来说，我们接触到的文件有两类 —— <strong>文本文件</strong>和<strong>二进制文件</strong>。前者，可以理解为<strong>字符构成的有序集合</strong>，如 filein.txt 文本文件、test.c 源代码文件；后者的典型代表是 a.exe 这类<strong>可执行文件</strong>。特别要注意，word 等工具编辑出的 .docx 文件属于二进制文件，是不能直接用我们接下来要讲到的文件操作函数处理的。</p>
<p>这门课程涉及的文件操作无非基本的读写，可以理解成<strong>程序中字符数组里的内容与文件间的交换</strong>。关于判断文件是否存在、文件的创建 &#x2F; 删除 &#x2F; 复制 &#x2F; 移动 &#x2F; 重命名等操作，感兴趣的同学可以自己了解。</p>
</blockquote>
<h3 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h3><p>操作系统中的文件构成一个<strong>树状结构</strong>。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/assets2/截屏2023-03-05 14.26.17.png"
                      alt="截屏2023-03-05 14.26.17" style="zoom:30%;" 
                >

<p>文件系统从一个根出发，<strong>每个文件夹就是树枝的分叉、每个文件就是树叶</strong>。这里的<strong>文件夹，就是目录</strong>。目录下可以包含若干文件，也可以为空。<strong>目录本身也是文件，是一种特殊的文件。目录中默认有两个隐藏的文件，文件名为<code>.</code>和<code>..</code>，分别表示自身和父目录。</strong></p>
<p>定位一个文件，就需要给出文件的路径。一种方法是从根开始，一路写到当前文件，如<code>D:\MyFiles\DSLearning\main.c</code>，这就表示打开 D 盘，进入 Myfiles 文件夹，进入 DSLearning 文件夹，就可以找到 main.c 文件。这种方式称为<strong>绝对路径</strong>。另一种方法是，以<strong>当前所在的目录为基准点，描述目标的相对位置</strong>。以上图为例，假设我们处在 gcctest 目录下，则 foo.c 文件可以直接写<code>foo.c</code>或<code>./foo.c</code>（因为<code>.</code>表示当前目录），libfoo.so 文件可以写成 <code>include/libfoo.so</code>，bank.c 文件可以写成<code>../IPCtest/bank.c</code>（因为<code>..</code>表示父目录）。</p>
<p>上文中提到“当前所在目录”，可以简单理解为<strong>程序运行的目录</strong>，即 .exe 文件所在的目录。一般来说，<strong>把文件和 .exe 文件放在一起，在函数调用时直接指定文件名即可</strong>。</p>
<h3 id="标准-C-库文件操作函数"><a href="#标准-C-库文件操作函数" class="headerlink" title="标准 C 库文件操作函数"></a>标准 C 库文件操作函数</h3><p>在学习 C 语言的第一天，我们就知道要<code>#include &lt;stdio.h&gt;</code>，std 即 standard，io 即上文所述。我们调用的<code>printf</code>等，正是 C 库提供的 I&#x2F;O 函数。调用以下函数，也应包含此头文件。</p>
<h4 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">FILE* <span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">	<span class="comment">// 打开文件，成功返回文件指针，出错返回 NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 关闭文件，成功返回 0，出错返回 -1</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>这里的“文件指针”<code>FILE*</code>，是在<code>&lt;stdio.h&gt;</code>中定义的一个<strong>结构体指针</strong>，该结构体包含了一个文件的各类信息。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此代码块内容仅供了解 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> cnt;			<span class="comment">// 剩余字节数</span></span><br><span class="line">    <span class="type">char</span> *ptr;			<span class="comment">// 下一个字符的位置</span></span><br><span class="line">    <span class="type">char</span> *base;			<span class="comment">// 缓冲区的位置</span></span><br><span class="line">    <span class="type">int</span> flag;			<span class="comment">// 文件访问模式</span></span><br><span class="line">    <span class="type">int</span> fd;				<span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="comment">// 还有很多</span></span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>获取了一个文件的文件指针，将其作为参数传递给其他函数，即可读写对应的文件。</strong>很多时候，文件打开会失败，则<code>fopen</code>返回<code>NULL</code>。因此，建议同学们以以下方式打开一个文件。</p>
  <div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示范代码，这部分代码位于 main 中</span></span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen error&quot;</span>); <span class="comment">// 此函数在 &lt;stdio.h&gt; 中，能帮助输出错误信息</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);               <span class="comment">// 此函数在 &lt;stdlib.h&gt; 中，能强制结束程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>fopen</code>函数的第一个参数为<strong>文件路径</strong>，前文已经说明。第二个参数指定打开方式，常见的是<code>&quot;r&quot;</code>和<code>&quot;w&quot;</code>。前者表示读，后者表示写。<strong>读文件，要求文件已经存在</strong>，否则会打开失败；写文件，<strong>默认不存在则创建</strong>，如果存在且已经有内容，则<strong>清空</strong>后从头开始写。</p>
</li>
<li><p>程序运行时默认已经打开了三个文件 —— 标准输入<code>stdin</code>、标准输出<code>stdout</code>、标准错误<code>stderr</code>，这是三个文件指针，分别对应键盘、屏幕、屏幕。</p>
</li>
</ul>
<blockquote>
<p>使用<code>fopen</code>打开一个文件，则应当使用<code>fclose</code>关闭。当然做编程题的时候不写也没事。但是，这种规范操作仍应当强调，即便你可能并不会在意。当然，如果日后你因为忘记 close 或 free 而导致一个实际项目出现 bug，你一定会有所感悟的。</p>
</blockquote>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>通过<code>fopen</code>获得文件指针后，可以调用相关 I&#x2F;O 函数读写文件。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> size, FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 以行为单位读取文件指针 fp 对应的文件中的内容，存到字符数组 str 中，一次最多读取 size 个字符</span></span><br><span class="line">    <span class="comment">// 读取成功返回 str，读到文件末返回 NULL</span></span><br><span class="line">	<span class="comment">// 此函数会读取换行符，这与 gets 不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 1</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">fgets(str, <span class="number">1024</span>, <span class="built_in">stdin</span>);  <span class="comment">// 从键盘读取字符串，基本等价 gets，但会读进换行符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 2</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);              <span class="comment">// 如果打开失败则结束程序</span></span><br><span class="line"><span class="keyword">while</span> (fgets(buffer, <span class="number">1024</span>, fp) != <span class="literal">NULL</span>) &#123; <span class="comment">// 逐行读取文件内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line">	<span class="comment">// 功能同 scanf，只是多了参数指出输入来源于哪个文件</span></span><br><span class="line">	<span class="comment">// 读到文件末返回 EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 1</span></span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">fscanf</span>(<span class="built_in">stdin</span>, <span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c); <span class="comment">// 同 scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span></span><br><span class="line"><span class="comment">// 【特别提醒】读字符串的时候，不要加 &amp; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码 2</span></span><br><span class="line"><span class="comment">// 从文件中读取空格分隔的若干学生的成绩（整数），求平均分并输出（一位小数）</span></span><br><span class="line"><span class="type">int</span> score, sum = <span class="number">0</span>, cnt = <span class="number">0</span>;                <span class="comment">// 很多同学都会忘记初始化</span></span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;scores.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;score) != EOF) &#123;</span><br><span class="line">    sum += score;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;average: %.1f\n&quot;</span>, sum * <span class="number">1.0</span> / cnt); <span class="comment">// 整数运算结果还是整数，你还记得这个细节吗</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 从 fp 所指的文件中读取一个字符，调用时可写 char c = fgetc(fp);</span></span><br><span class="line">	<span class="comment">// 读到文件末返回 EOF</span></span><br><span class="line">	<span class="comment">// 上一期猪脚说解释了为什么很多理应用 char 的地方写成了 int，这是合理且安全的</span></span><br><span class="line">	<span class="comment">// 我们自己在写程序时，也可以写 int c = fgetc(fp); printf(&quot;%c&quot;, c);</span></span><br></pre></td></tr></table></figure></div>

<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>这里仅提供函数原型，使用与非文件 I&#x2F;O 版本无异，只是多传入一个文件指针而已。<strong>写文件时，应指定<code>fopen</code>打开模式为<code>&quot;w&quot;</code>。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 将字符串 s 写入 fp 所指的文件中</span></span><br><span class="line">	<span class="comment">// 不同于 puts，此函数不会自动换行</span></span><br><span class="line">	<span class="comment">// fputs(s, stdout); 等价于 printf(&quot;%s&quot;, s);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line">	<span class="comment">// 类比 printf，当 fp 为 stdout 时等价于 printf</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br><span class="line">	<span class="comment">// 类比 putchar，当 fp 为 stdout 时等价于 putchar</span></span><br></pre></td></tr></table></figure></div>

<h3 id="文件偏移量"><a href="#文件偏移量" class="headerlink" title="文件偏移量"></a>文件偏移量</h3><p>我们在读写文件时，很自然地会认为我们是不断向文件尾部读取或添加内容。假如读完一个文件，还想再读一遍，一种做法是先 close 再 open。那我们能不能像实际编辑文件那样在读完一部分内容后，跳到前面再读一遍，或者是在文件中间插入内容呢。<strong>正如同使用 word 时的那个不断闪烁的光标，当我们操作文件的时候，FILE 结构体也在维护一个文件偏移量，它指的是距离文件头的字符数（准确是是字节数），文件的读写，都是从当前偏移量开始往后进行的。</strong></p>
<p><strong>使用<code>fopen</code>打开文件时，文件偏移量为 0，即光标位于文件头。</strong>当我们不断读取内容，光标不断后移，则文件偏移量不断增大。<strong>当文件偏移量等于文件字节数（一般等于文件字符数 &#x2F; 文件大小）的时候，就读到了文件末尾。</strong></p>
<p>一个很显然的想法是，<strong>不同的文件读取方式，每次文件偏移量的增量也不同。</strong>例如，刚打开一个文件（假设其中的内容足够多），连续调用两次**<code>fgetc</code>，则每次偏移量加一<strong>；调用</strong><code>fgets</code><strong>，则偏移量从第一行的第三个字符</strong>跳到行尾<strong>；再次</strong><code>fgets</code>，则偏移量跨过第二行跳到第二行行尾<strong>；进行<code>fscanf</code>，假设格式串为<code>&quot;(%d,%d)%c%lf&quot;</code>，且第三行的数据类型符合要求，则文件偏移量跳过 1 个字节</strong>吞掉**<code>(</code>、跳过 4 个字节<strong>读取</strong><code>int</code>、跳过 1 个字节<strong>吞掉</strong><code>,</code>、跳过 4 个字节<strong>读取</strong><code>int</code>、跳过 1 个字节<strong>吞掉</strong><code>)</code>、跳过 1 个字节<strong>读取</strong><code>char</code>、最后跳过 8 个字节<strong>读取</strong><code>double</code>。</p>
<p>介绍文件偏移量有助于我们理解文件的写入和读取顺序，如果想要<strong>手动设置文件偏移量</strong>，实现更加复杂的文件操作，请自行学习<code>fseek</code>等函数。</p>
<h2 id="第二次作业补充练习"><a href="#第二次作业补充练习" class="headerlink" title="第二次作业补充练习"></a>第二次作业补充练习</h2><p>1、<a class="link"   href="https://www.luogu.com.cn/problem/P1104" >按照结构体某一成员变量进行排序。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>2、<a class="link"   href="https://www.luogu.com.cn/problem/P1786" >稍微有一点难度的结构体排序。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>Author: diandian, Riccardo</em></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
